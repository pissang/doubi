
 (function(factory){
 	// AMD
 	if( typeof define !== "undefined" && define["amd"] ){
 		define( 'qtek',["exports"], factory.bind(window) );
 	// No module loader
 	}else{
 		factory( window["qtek"] = {} );
 	}

})(function(_exports){

/**
 * almond 0.2.5 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (typeof callback === 'function') {

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        config = cfg;
        if (config.deps) {
            req(config.deps, config.callback);
        }
        return req;
    };

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define('qtek/core/mixin/derive',['require'],function(require) {



/**
 * Extend a sub class from base class
 * @param makeDefaultOpt [object|function] default option of this sub class, method of the sub can use this.xxx to access this option
 * @param initialize [function](optional) Initialize after the sub class is instantiated
 * @param proto [object](optional) Prototype methods/properties of the sub class
 *
 * @return function
 */
function derive(makeDefaultOpt, initialize/*optional*/, proto/*optional*/) {

    if (typeof initialize == "object") {
        proto = initialize;
        initialize = null;
    }

    var _super = this;

    var propList;
    if (!(makeDefaultOpt instanceof Function)) {
        // Optimize the property iterate if it have been fixed
        propList = [];
        for (var propName in makeDefaultOpt) {
            if (makeDefaultOpt.hasOwnProperty(propName)) {
                propList.push(propName);
            }
        }
    }

    var sub = function(options) {

        // call super constructor
        _super.apply(this, arguments);

        if (makeDefaultOpt instanceof Function) {
            // call defaultOpt generate function each time
            // if it is a function, So we can make sure each 
            // property in the object is not shared by mutiple instances
            extend(this, makeDefaultOpt.call(this));
        } else {
            extendWithPropList(this, makeDefaultOpt, propList);
        }
        
        if (this.constructor === sub) {
            // PENDING
            if (options) {
                extend(this, options);
            }

            // Initialize function will be called in the order of inherit
            var base = sub;
            var initializers = sub.__initializers__;
            for (var i = 0; i < initializers.length; i++) {
                initializers[i].apply(this, arguments);
            }
        }
    };
    // save super constructor
    sub.__super__ = _super;
    // initialize function will be called after all the super constructor is called
    if (!_super.__initializers__) {
        sub.__initializers__ = [];
    } else {
        sub.__initializers__ = _super.__initializers__.slice();
    }
    if (initialize) {
        sub.__initializers__.push(initialize);
    }

    var Ctor = function() {};
    Ctor.prototype = _super.prototype;
    sub.prototype = new Ctor();
    sub.prototype.constructor = sub;
    extend(sub.prototype, proto);
    
    // extend the derive method as a static method;
    sub.derive = _super.derive;

    return sub;
}

function extend(target, source) {
    if (!source) {
        return;
    }
    for (var name in source) {
        if (source.hasOwnProperty(name)) {
            target[name] = source[name];
        }
    }
}

function extendWithPropList(target, source, propList) {
    for (var i = 0; i < propList.length; i++) {
        var propName = propList[i];
        target[propName] = source[propName];
    }   
}

return {
    derive : derive
}

});
define('qtek/core/mixin/notifier',[],function() {

    function Handler(action, context) {
        this.action = action;
        this.context = context;
    }

    return{
        trigger : function(name) {
            if (! this.hasOwnProperty('__handlers__')) {
                return;
            }
            if (!this.__handlers__.hasOwnProperty(name)) {
                return;
            }

            var hdls = this.__handlers__[name];
            var l = hdls.length, i = -1, args = arguments;
            // Optimize from backbone
            switch (args.length) {
                case 1: 
                    while (++i < l)
                        hdls[i].action.call(hdls[i].context);
                    return;
                case 2:
                    while (++i < l)
                        hdls[i].action.call(hdls[i].context, args[1]);
                    return;
                case 3:
                    while (++i < l)
                        hdls[i].action.call(hdls[i].context, args[1], args[2]);
                    return;
                case 4:
                    while (++i < l)
                        hdls[i].action.call(hdls[i].context, args[1], args[2], args[3]);
                    return;
                case 5:
                    while (++i < l)
                        hdls[i].action.call(hdls[i].context, args[1], args[2], args[3], args[4]);
                    return;
                default:
                    while (++i < l)
                        hdls[i].action.apply(hdls[i].context, Array.prototype.slice.call(args, 1));
                    return;
            }
        },
        
        on : function(name, action, context/*optional*/) {
            if (!name || !action) {
                return;
            }
            var handlers = this.__handlers__ || (this.__handlers__={});
            if (! handlers[name]) {
                handlers[name] = [];
            } else {
                if (this.has(name, action)) {
                    return;
                }   
            }
            var handler = new Handler(action, context || this);
            handlers[name].push(handler);

            return this;
        },

        once : function(name, action, context/*optional*/) {
            if (!name || !action) {
                return;
            }
            var self = this;
            function wrapper() {
                self.off(name, wrapper);
                action.apply(this, arguments);
            }
            return this.on(name, wrapper, context);
        },

        // Alias of on('before')
        before : function(name, action, context/*optional*/) {
            if (!name || !action) {
                return;
            }
            name = 'before' + name;
            return this.on(name, action, context);
        },

        // Alias of on('after')
        after : function(name, action, context/*optional*/) {
            if (!name || !action) {
                return;
            }
            name = 'after' + name;
            return this.on(name, action, context);
        },

        // Alias of once('success')
        success : function(action, context/*optional*/) {
            return this.once('success', action, context);
        },

        // Alias of once('error')
        error : function(action, context/*optional*/) {
            return this.once('error', action, context);
        },

        off : function(name, action/*optional*/) {
            
            var handlers = this.__handlers__ || (this.__handlers__={});

            if (!action) {
                handlers[name] = [];
                return;
            }
            if (handlers[name]) {
                var hdls = handlers[name];
                // Splice is evil!!
                var retains = [];
                for (var i = 0; i < hdls.length; i++) {
                    if (action && hdls[i].action !== action) {
                        retains.push(hdls[i]);
                    }
                }
                handlers[name] = retains;
            } 

            return this;
        },

        has : function(name, action) {
            var handlers = this.__handlers__;

            if (! handlers ||
                ! handlers[name]) {
                return false;
            }
            var hdls = handlers[name];
            for (var i = 0; i < hdls.length; i++) {
                if (hdls[i].action === action) {
                    return true;
                }
            }
        }
    }
    
});
define('qtek/core/util',['require'],function(require){
    
    var guid = 0;

	var util = {

		genGUID : function() {
			return ++guid;
		},

        relative2absolute : function(path, basePath) {
            if (!basePath || path.match(/^\//)) {
                return path;
            }
            var pathParts = path.split('/');
            var basePathParts = basePath.split('/');

            var item = pathParts[0];
            while(item === '.' || item === '..') {
                if (item === '..') {
                    basePathParts.pop();
                }
                pathParts.shift();
                item = pathParts[0];
            }
            return basePathParts.join('/') + '/' + pathParts.join('/');
        },

        extend : function(target, source) {
            if (source) {
                for (var name in source) {
                    if (source.hasOwnProperty(name)) {
                        target[name] = source[name];
                    }
                }
            }
            return target;
        },

        defaults : function(target, source) {
            if (source) {
                for (var propName in source) {
                    if (target[propName] === undefined) {
                        target[propName] = source[propName];
                    }
                }
            }
        },

        extendWithPropList : function(target, source, propList) {
            if (source) {
                for (var i = 0; i < propList.length; i++) {
                    var propName = propList[i];
                    target[propName] = source[propName];
                }
            }
            return target;
        },

        defaultsWithPropList : function(target, source, propList) {
            if (source) {
                for (var i = 0; i < propList.length; i++) {
                    var propName = propList[i];
                    if (target[propName] === undefined) {
                        target[propName] = source[propName];
                    }
                }
            }
            return target;
        },

        each : function(obj, iterator, context) {
            if (!(obj && iterator)) {
                return;
            }
            if (obj.forEach) {
                obj.forEach(iterator, context);
            } else if (obj.length === + obj.length) {
                for (var i = 0, len = obj.length; i < len; i++) {
                    iterator.call(context, obj[i], i, obj);
                }
            } else {
                for (var key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        iterator.call(context, obj[key], key, obj);
                    }
                }
            }
        },

        isObject : function(obj) {
            return obj === Object(obj);
        },

        isArray : function(obj) {
            return obj instanceof Array;
        },

        // Can be TypedArray
        isArrayLike : function(obj) {
            if (!obj) {
                return false;
            } else {
                return obj.length === + obj.length;
            }
        },

        clone : function(obj) {
            if (!util.isObject(obj)) {
                return obj;
            } else if (util.isArray(obj)) {
                return obj.slice();
            } else if (util.isArrayLike(obj)) { // is typed array
                var ret = new obj.constructor(obj.length);
                for (var i = 0; i < obj.length; i++) {
                    ret[i] = obj[i];
                }
                return ret;
            } else {
                return util.extend({}, obj);
            }
        }
	}

    return util;
});
define('qtek/core/Base',['require','./mixin/derive','./mixin/notifier','./util'],function(require){

    var deriveMixin = require("./mixin/derive");
    var notifierMixin = require("./mixin/notifier");
    var util = require("./util");

    var Base = function(options){
        
        this.__GUID__ = util.genGUID();
    }
    util.extend(Base, deriveMixin);
    util.extend(Base.prototype, notifierMixin);

    return Base;
});
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.2.0
 */

/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


(function(_global) {
  

  var shim = {};
  if (typeof(exports) === 'undefined') {
    if(typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
      shim.exports = {};
      define('glmatrix',[],function() {
        return shim.exports;
      });
    } else {
      // gl-matrix lives in a browser, define its namespaces in global
      shim.exports = typeof(window) !== 'undefined' ? window : _global;
    }
  }
  else {
    // gl-matrix lives in commonjs, define its namespaces in exports
    shim.exports = exports;
  }

  (function(exports) {
    /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


if(!GLMAT_EPSILON) {
    var GLMAT_EPSILON = 0.000001;
}

if(!GLMAT_ARRAY_TYPE) {
    var GLMAT_ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
}

if(!GLMAT_RANDOM) {
    var GLMAT_RANDOM = Math.random;
}

/**
 * @class Common utilities
 * @name glMatrix
 */
var glMatrix = {};

/**
 * Sets the type of array used when creating new vectors and matricies
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
glMatrix.setMatrixArrayType = function(type) {
    GLMAT_ARRAY_TYPE = type;
}

if(typeof(exports) !== 'undefined') {
    exports.glMatrix = glMatrix;
}

var degree = Math.PI / 180;

/**
* Convert Degree To Radian
*
* @param {Number} Angle in Degrees
*/
glMatrix.toRadian = function(a){
     return a * degree;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2 Dimensional Vector
 * @name vec2
 */

var vec2 = {};

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
vec2.create = function() {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for {@link vec2.divide}
 * @function
 */
vec2.div = vec2.divide;

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
vec2.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.distance}
 * @function
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.length}
 * @function
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
vec2.cross = function(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
vec2.random = function (out, scale) {
    scale = scale || 1.0;
    var r = GLMAT_RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2d = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat3 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat4 = function(out, a, m) {
    var x = a[0], 
        y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
};

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec2.forEach = (function() {
    var vec = vec2.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 2;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec2 = vec2;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */

var vec3 = {};

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
vec3.create = function() {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
};

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
vec3.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
vec3.fromValues = function(x, y, z) {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
vec3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
vec3.set = function(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
};

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
vec3.sub = vec3.subtract;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
};

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
vec3.mul = vec3.multiply;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
};

/**
 * Alias for {@link vec3.divide}
 * @function
 */
vec3.div = vec3.divide;

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
};

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
};

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
vec3.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
};

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
vec3.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
vec3.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.distance}
 * @function
 */
vec3.dist = vec3.distance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec3.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
vec3.sqrDist = vec3.squaredDistance;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
vec3.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.length}
 * @function
 */
vec3.len = vec3.length;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec3.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
vec3.sqrLen = vec3.squaredLength;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
vec3.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
};

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
vec3.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x*x + y*y + z*z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.cross = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
};

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
vec3.random = function (out, scale) {
    scale = scale || 1.0;

    var r = GLMAT_RANDOM() * 2.0 * Math.PI;
    var z = (GLMAT_RANDOM() * 2.0) - 1.0;
    var zScale = Math.sqrt(1.0-z*z) * scale;

    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
};

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12];
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13];
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14];
    return out;
};

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat3 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
};

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
vec3.transformQuat = function(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec3.forEach = (function() {
    var vec = vec3.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 3;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec3.str = function (a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec3 = vec3;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 4 Dimensional Vector
 * @name vec4
 */

var vec4 = {};

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
vec4.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
};

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
vec4.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
vec4.fromValues = function(x, y, z, w) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
vec4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
vec4.set = function(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
vec4.sub = vec4.subtract;

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
};

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
vec4.mul = vec4.multiply;

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
};

/**
 * Alias for {@link vec4.divide}
 * @function
 */
vec4.div = vec4.divide;

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
};

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
};

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
vec4.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
vec4.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
vec4.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.distance}
 * @function
 */
vec4.dist = vec4.distance;

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec4.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
vec4.sqrDist = vec4.squaredDistance;

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
vec4.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.length}
 * @function
 */
vec4.len = vec4.length;

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec4.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
vec4.sqrLen = vec4.squaredLength;

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
vec4.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
};

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
vec4.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var len = x*x + y*y + z*z + w*w;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
        out[3] = a[3] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
vec4.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
vec4.random = function (out, scale) {
    scale = scale || 1.0;

    //TODO: This is a pretty awful way of doing this. Find something better.
    out[0] = GLMAT_RANDOM();
    out[1] = GLMAT_RANDOM();
    out[2] = GLMAT_RANDOM();
    out[3] = GLMAT_RANDOM();
    vec4.normalize(out, out);
    vec4.scale(out, out, scale);
    return out;
};

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
vec4.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
};

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
vec4.transformQuat = function(out, a, q) {
    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec4.forEach = (function() {
    var vec = vec4.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 4;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec4.str = function (a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec4 = vec4;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2x2 Matrix
 * @name mat2
 */

var mat2 = {};

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
mat2.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
mat2.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
mat2.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a1 = a[1];
        out[1] = a[2];
        out[2] = a1;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }
    
    return out;
};

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

        // Calculate the determinant
        det = a0 * a3 - a2 * a1;

    if (!det) {
        return null;
    }
    det = 1.0 / det;
    
    out[0] =  a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] =  a0 * det;

    return out;
};

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.adjoint = function(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] =  a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] =  a0;

    return out;
};

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
mat2.determinant = function (a) {
    return a[0] * a[3] - a[2] * a[1];
};

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = a0 * b0 + a1 * b2;
    out[1] = a0 * b1 + a1 * b3;
    out[2] = a2 * b0 + a3 * b2;
    out[3] = a2 * b1 + a3 * b3;
    return out;
};

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
mat2.mul = mat2.multiply;

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a1 * s;
    out[1] = a0 * -s + a1 * c;
    out[2] = a2 *  c + a3 * s;
    out[3] = a2 * -s + a3 * c;
    return out;
};

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
mat2.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v1;
    out[2] = a2 * v0;
    out[3] = a3 * v1;
    return out;
};

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2.str = function (a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.mat2 = mat2;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2x3 Matrix
 * @name mat2d
 * 
 * @description 
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, b,
 *  c, d,
 *  tx,ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, b, 0
 *  c, d, 0
 *  tx,ty,1]
 * </pre>
 * The last column is ignored so the array is shorter and operations are faster.
 */

var mat2d = {};

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.create = function() {
    var out = new GLMAT_ARRAY_TYPE(6);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
mat2d.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.invert = function(out, a) {
    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
        atx = a[4], aty = a[5];

    var det = aa * ad - ab * ac;
    if(!det){
        return null;
    }
    det = 1.0 / det;

    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
};

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
mat2d.determinant = function (a) {
    return a[0] * a[3] - a[1] * a[2];
};

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.multiply = function (out, a, b) {
    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
        atx = a[4], aty = a[5],
        ba = b[0], bb = b[1], bc = b[2], bd = b[3],
        btx = b[4], bty = b[5];

    out[0] = aa*ba + ab*bc;
    out[1] = aa*bb + ab*bd;
    out[2] = ac*ba + ad*bc;
    out[3] = ac*bb + ad*bd;
    out[4] = ba*atx + bc*aty + btx;
    out[5] = bb*atx + bd*aty + bty;
    return out;
};

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
mat2d.mul = mat2d.multiply;


/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.rotate = function (out, a, rad) {
    var aa = a[0],
        ab = a[1],
        ac = a[2],
        ad = a[3],
        atx = a[4],
        aty = a[5],
        st = Math.sin(rad),
        ct = Math.cos(rad);

    out[0] = aa*ct + ab*st;
    out[1] = -aa*st + ab*ct;
    out[2] = ac*ct + ad*st;
    out[3] = -ac*st + ct*ad;
    out[4] = ct*atx + st*aty;
    out[5] = ct*aty - st*atx;
    return out;
};

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
mat2d.scale = function(out, a, v) {
    var vx = v[0], vy = v[1];
    out[0] = a[0] * vx;
    out[1] = a[1] * vy;
    out[2] = a[2] * vx;
    out[3] = a[3] * vy;
    out[4] = a[4] * vx;
    out[5] = a[5] * vy;
    return out;
};

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
mat2d.translate = function(out, a, v) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4] + v[0];
    out[5] = a[5] + v[1];
    return out;
};

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2d.str = function (a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.mat2d = mat2d;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 3x3 Matrix
 * @name mat3
 */

var mat3 = {};

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
mat3.create = function() {
    var out = new GLMAT_ARRAY_TYPE(9);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
mat3.fromMat4 = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
};

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
mat3.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
mat3.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }
    
    return out;
};

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b01 = a22 * a11 - a12 * a21,
        b11 = -a22 * a10 + a12 * a20,
        b21 = a21 * a10 - a11 * a20,

        // Calculate the determinant
        det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
};

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    out[0] = (a11 * a22 - a12 * a21);
    out[1] = (a02 * a21 - a01 * a22);
    out[2] = (a01 * a12 - a02 * a11);
    out[3] = (a12 * a20 - a10 * a22);
    out[4] = (a00 * a22 - a02 * a20);
    out[5] = (a02 * a10 - a00 * a12);
    out[6] = (a10 * a21 - a11 * a20);
    out[7] = (a01 * a20 - a00 * a21);
    out[8] = (a00 * a11 - a01 * a10);
    return out;
};

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
mat3.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
};

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b00 = b[0], b01 = b[1], b02 = b[2],
        b10 = b[3], b11 = b[4], b12 = b[5],
        b20 = b[6], b21 = b[7], b22 = b[8];

    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
};

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
mat3.mul = mat3.multiply;

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
mat3.translate = function(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],
        x = v[0], y = v[1];

    out[0] = a00;
    out[1] = a01;
    out[2] = a02;

    out[3] = a10;
    out[4] = a11;
    out[5] = a12;

    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
};

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.rotate = function (out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        s = Math.sin(rad),
        c = Math.cos(rad);

    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;

    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;

    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
mat3.scale = function(out, a, v) {
    var x = v[0], y = v[1];

    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];

    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];

    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
mat3.fromMat2d = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;

    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;

    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
};

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
mat3.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;

    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;

    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;

    return out;
};

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
mat3.normalFromMat4 = function (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

    return out;
};

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat3.str = function (a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + 
                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.mat3 = mat3;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 4x4 Matrix
 * @name mat4
 */

var mat4 = {};

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
mat4.create = function() {
    var out = new GLMAT_ARRAY_TYPE(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
mat4.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
mat4.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    
    return out;
};

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
mat4.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
mat4.mul = mat4.multiply;

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.translate = function (out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        a30, a31, a32, a33;

        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];
        a30 = a[12]; a31 = a[13]; a32 = a[14]; a33 = a[15];
    
    out[0] = a00 + a03*x;
    out[1] = a01 + a03*y;
    out[2] = a02 + a03*z;
    out[3] = a03;

    out[4] = a10 + a13*x;
    out[5] = a11 + a13*y;
    out[6] = a12 + a13*z;
    out[7] = a13;

    out[8] = a20 + a23*x;
    out[9] = a21 + a23*y;
    out[10] = a22 + a23*z;
    out[11] = a23;
    out[12] = a30 + a33*x;
    out[13] = a31 + a33*y;
    out[14] = a32 + a33*z;
    out[15] = a33;

    return out;
};
/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.scale = function(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Rotates a mat4 by the given angle
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.rotate = function (out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < GLMAT_EPSILON) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateX = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateY = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateZ = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslation = function (out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};

mat4.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.frustum = function (out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspective = function (out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.ortho = function (out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
mat4.lookAt = function (out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < GLMAT_EPSILON &&
        Math.abs(eyey - centery) < GLMAT_EPSILON &&
        Math.abs(eyez - centerz) < GLMAT_EPSILON) {
        return mat4.identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat4.str = function (a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + 
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.mat4 = mat4;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class Quaternion
 * @name quat
 */

var quat = {};

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
quat.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
quat.rotationTo = (function() {
    var tmpvec3 = vec3.create();
    var xUnitVec3 = vec3.fromValues(1,0,0);
    var yUnitVec3 = vec3.fromValues(0,1,0);

    return function(out, a, b) {
        var dot = vec3.dot(a, b);
        if (dot < -0.999999) {
            vec3.cross(tmpvec3, xUnitVec3, a);
            if (vec3.length(tmpvec3) < 0.000001)
                vec3.cross(tmpvec3, yUnitVec3, a);
            vec3.normalize(tmpvec3, tmpvec3);
            quat.setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            vec3.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot;
            return quat.normalize(out, out);
        }
    };
})();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
quat.setAxes = (function() {
    var matr = mat3.create();

    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];

        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];

        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];

        return quat.normalize(out, quat.fromMat3(out, matr));
    };
})();

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
quat.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
quat.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
quat.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
quat.set = vec4.set;

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
quat.identity = function(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
quat.setAxisAngle = function(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
};

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
quat.add = vec4.add;

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.multiply = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
};

/**
 * Alias for {@link quat.multiply}
 * @function
 */
quat.mul = quat.multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
quat.scale = vec4.scale;

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateX = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateY = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        by = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateZ = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bz = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
};

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
quat.calculateW = function (out, a) {
    var x = a[0], y = a[1], z = a[2];

    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
};

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
quat.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
quat.lerp = vec4.lerp;

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
quat.slerp = function (out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    var        omega, cosom, sinom, scale0, scale1;

    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if ( cosom < 0.0 ) {
        cosom = -cosom;
        bx = - bx;
        by = - by;
        bz = - bz;
        bw = - bw;
    }
    // calculate coefficients
    if ( (1.0 - cosom) > 0.000001 ) {
        // standard case (slerp)
        omega  = Math.acos(cosom);
        sinom  = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {        
        // "from" and "to" quaternions are very close 
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    
    return out;
};

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
quat.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
        invDot = dot ? 1.0/dot : 0;
    
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0*invDot;
    out[1] = -a1*invDot;
    out[2] = -a2*invDot;
    out[3] = a3*invDot;
    return out;
};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
quat.conjugate = function (out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
};

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 * @function
 */
quat.length = vec4.length;

/**
 * Alias for {@link quat.length}
 * @function
 */
quat.len = quat.length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
quat.squaredLength = vec4.squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
quat.sqrLen = quat.squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
quat.normalize = vec4.normalize;

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
quat.fromMat3 = function(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if ( fTrace > 0.0 ) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5/fRoot;  // 1/(4w)
        out[0] = (m[7]-m[5])*fRoot;
        out[1] = (m[2]-m[6])*fRoot;
        out[2] = (m[3]-m[1])*fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if ( m[4] > m[0] )
          i = 1;
        if ( m[8] > m[i*3+i] )
          i = 2;
        var j = (i+1)%3;
        var k = (i+2)%3;
        
        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[k*3+j] - m[j*3+k]) * fRoot;
        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
    }
    
    return out;
};

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
quat.str = function (a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.quat = quat;
}
;













  })(shim.exports);
})(this);

define('qtek/math/Vector3',['require','glmatrix'],function(require) {
    
    

    var glMatrix = require("glmatrix");
    var vec3 = glMatrix.vec3;

    /**
     * @constructor
     * @alias qtek.math.Vector3
     * @param {number} x
     * @param {number} y
     * @param {number} z
     */
    var Vector3 = function(x, y, z) {
        
        x = x || 0;
        y = y || 0;
        z = z || 0;

        /**
         * Storage of Vector3, read and write of x, y, z will change the values in _array
         * All methods also operate on the _array instead of x, y, z components
         * @type {Float32Array}
         */
        this._array = vec3.fromValues(x, y, z);

        /**
         * Dirty flag is used by the Node to determine
         * if the matrix is updated to latest
         * @type {boolean}
         */
        this._dirty = true;
    }

    Vector3.prototype= {

        constructor : Vector3,

        /**
         * @name x
         * @type {number}
         * @memberOf qtek.math.Vector3
         * @instance
         */
        get x() {
            return this._array[0];
        },

        set x(value) {
            this._array[0] = value;
            this._dirty = true;
        },

        /**
         * @name y
         * @type {number}
         * @memberOf qtek.math.Vector3
         * @instance
         */
        get y() {
            return this._array[1];
        },

        set y(value) {
            this._array[1] = value;
            this._dirty = true;
        },

        /**
         * @name z
         * @type {number}
         * @memberOf qtek.math.Vector3
         * @instance
         */
        get z() {
            return this._array[2];
        },

        set z(value) {
            this._array[2] = value;
            this._dirty = true;
        },

        /**
         * Add b to self
         * @param  {qtek.math.Vector3} b
         * @return {qtek.math.Vector3}
         */
        add : function(b) {
            vec3.add(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Set x, y and z components
         * @param  {number}  x
         * @param  {number}  y
         * @param  {number}  z
         * @return {qtek.math.Vector3}
         */
        set : function(x, y, z) {
            this._array[0] = x;
            this._array[1] = y;
            this._array[2] = z;
            this._dirty = true;
            return this;
        },

        /**
         * Set x, y and z components from array
         * @param  {Float32Array|number[]} arr
         * @return {qtek.math.Vector3}
         */
        setArray : function(arr) {
            this._array[0] = arr[0];
            this._array[1] = arr[1];
            this._array[2] = arr[2];

            this._dirty = true;
            return this;
        },

        /**
         * Clone a new Vector3
         * @return {qtek.math.Vector3}
         */
        clone : function() {
            return new Vector3( this.x, this.y, this.z );
        },

        /**
         * Copy from b
         * @param  {qtek.math.Vector3} b
         * @return {qtek.math.Vector3}
         */
        copy : function(b) {
            vec3.copy(this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Cross product of self and b, written to a Vector3 out
         * @param  {qtek.math.Vector3} out
         * @param  {qtek.math.Vector3} b
         * @return {qtek.math.Vector3}
         */
        cross : function(out, b) {
            vec3.cross(out._array, this._array, b._array);
            out._dirty = true;
            return this;
        },

        /**
         * Alias for distance
         * @param  {qtek.math.Vector3} b
         * @return {number}
         */
        dist : function(b) {
            return vec3.dist(this._array, b._array);
        },

        /**
         * Distance between self and b
         * @param  {qtek.math.Vector3} b
         * @return {number}
         */
        distance : function(b) {
            return vec3.distance(this._array, b._array);
        },

        /**
         * Alias for divide
         * @param  {qtek.math.Vector3} b
         * @return {qtek.math.Vector3}
         */
        div : function(b) {
            vec3.div(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Divide self by b
         * @param  {qtek.math.Vector3} b
         * @return {qtek.math.Vector3}
         */
        divide : function(b) {
            vec3.divide(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Dot product of self and b
         * @param  {qtek.math.Vector3} b
         * @return {number}
         */
        dot : function(b) {
            return vec3.dot(this._array, b._array);
        },

        /**
         * Alias of length
         * @return {number}
         */
        len : function() {
            return vec3.len(this._array);
        },

        /**
         * Calculate the length
         * @return {number}
         */
        length : function() {
            return vec3.length(this._array);
        },
        /**
         * Linear interpolation between a and b
         * @param  {qtek.math.Vector3} a
         * @param  {qtek.math.Vector3} b
         * @param  {number}  t
         * @return {qtek.math.Vector3}
         */
        lerp : function(a, b, t) {
            vec3.lerp(this._array, a._array, b._array, t);
            this._dirty = true;
            return this;
        },

        /**
         * Minimum of self and b
         * @param  {qtek.math.Vector3} b
         * @return {qtek.math.Vector3}
         */
        min : function(b) {
            vec2.min(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Maximum of self and b
         * @param  {qtek.math.Vector3} b
         * @return {qtek.math.Vector3}
         */
        max : function(b) {
            vec2.max(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Alias for multiply
         * @param  {qtek.math.Vector3} b
         * @return {qtek.math.Vector3}
         */
        mul : function(b) {
            vec3.mul(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Mutiply self and b
         * @param  {qtek.math.Vector3} b
         * @return {qtek.math.Vector3}
         */
        multiply : function(b) {
            vec3.multiply(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Negate self
         * @return {qtek.math.Vector3}
         */
        negate : function() {
            vec3.negate(this._array, this._array);
            this._dirty = true;
            return this;
        },

        /**
         * Normalize self
         * @return {qtek.math.Vector3}
         */
        normalize : function() {
            vec3.normalize(this._array, this._array);
            this._dirty = true;
            return this;
        },

        /**
         * Generate random x, y, z components with a given scale
         * @param  {number} scale
         * @return {qtek.math.Vector3}
         */
        random : function(scale) {
            vec3.random(this._array, scale);
            this._dirty = true;
            return this;
        },

        /**
         * Scale self
         * @param  {number}  scale
         * @return {qtek.math.Vector3}
         */
        scale : function(s) {
            vec3.scale(this._array, this._array, s);
            this._dirty = true;
            return this;
        },

        /**
         * Scale b and add to self
         * @param  {qtek.math.Vector3} b
         * @param  {number}  scale
         * @return {qtek.math.Vector3}
         */
        scaleAndAdd : function(b, s) {
            vec3.scaleAndAdd(this._array, this._array, b._array, s);
            this._dirty = true;
            return this;
        },

        /**
         * Alias for squaredDistance
         * @param  {qtek.math.Vector3} b
         * @return {number}
         */
        sqrDist : function(b) {
            return vec3.sqrDist(this._array, b._array);
        },

        /**
         * Squared distance between self and b
         * @param  {qtek.math.Vector3} b
         * @return {number}
         */
        squaredDistance : function(b) {
            return vec3.squaredDistance(this._array, b._array);
        },

        /**
         * Alias for squaredLength
         * @return {number}
         */
        sqrLen : function() {
            return vec3.sqrLen(this._array);
        },

        /**
         * Squared length of self
         * @return {number}
         */
        squaredLength : function() {
            return vec3.squaredLength(this._array);
        },

        /**
         * Alias for subtract
         * @param  {qtek.math.Vector3} b
         * @return {qtek.math.Vector3}
         */
        sub : function(b) {
            vec3.sub(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Subtract b from self
         * @param  {qtek.math.Vector3} b
         * @return {qtek.math.Vector3}
         */
        subtract : function(b) {
            vec3.subtract(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Transform self with a Matrix3 m
         * @param  {qtek.math.Matrix3} m
         * @return {qtek.math.Vector3}
         */
        transformMat3 : function(m) {
            vec3.transformMat3(this._array, this._array, m._array);
            this._dirty = true;
            return this;
        },

        /**
         * Transform self with a Matrix4 m
         * @param  {qtek.math.Matrix4} m
         * @return {qtek.math.Vector3}
         */
        transformMat4 : function(m) {
            vec3.transformMat4(this._array, this._array, m._array);
            this._dirty = true;
            return this;
        },
        /**
         * Transform self with a Quaternion q
         * @param  {qtek.math.Quaternion} q
         * @return {qtek.math.Vector3}
         */
        transformQuat : function(q) {
            vec3.transformQuat(this._array, this._array, q._array);
            this._dirty = true;
            return this;
        },

        /**
         * Trasnform self into projection space with m
         * @param  {qtek.math.Matrix4} m
         * @return {qtek.math.Vector3}
         */
        applyProjection : function(m) {
            var v = this._array;
            m = m._array;

            // Perspective projection
            if (m[15] === 0) {
                var w = -1 / v[2];
                v[0] = m[0] * v[0] * w;
                v[1] = m[5] * v[1] * w;
                v[2] = (m[10] * v[2] + m[14]) * w;
            } else {
                v[0] = m[0] * v[0] + m[12];
                v[1] = m[5] * v[1] + m[13];
                v[2] = m[10] * v[2] + m[14];
            }
            this._dirty = true;

            return this;
        },
        
        setEulerFromQuaternion : function(q) {
            // var sqx = q.x * q.x;
            // var sqy = q.y * q.y;
            // var sqz = q.z * q.z;
            // var sqw = q.w * q.w;
            // this.x = Math.atan2( 2 * ( q.y * q.z + q.x * q.w ), ( -sqx - sqy + sqz + sqw ) );
            // this.y = Math.asin( -2 * ( q.x * q.z - q.y * q.w ) );
            // this.z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqx - sqy - sqz + sqw ) );

            // return this;
        },

        toString : function() {
            return "[" + Array.prototype.join.call(this._array, ",") + "]";
        },
    }

    // Supply methods that are not in place
    
    /**
     * @param  {qtek.math.Vector3} out
     * @param  {qtek.math.Vector3} a
     * @param  {qtek.math.Vector3} b
     * @return {qtek.math.Vector3}
     */
    Vector3.add = function(out, a, b) {
        vec3.add(out._array, a._array, b._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Vector3} out
     * @param  {number}  x
     * @param  {number}  y
     * @param  {number}  z
     * @return {qtek.math.Vector3}  
     */
    Vector3.set = function(out, x, y, z) {
        vec3.set(out._array, x, y, z);
        out._dirty = true;
    }

    /**
     * @param  {qtek.math.Vector3} out
     * @param  {qtek.math.Vector3} b
     * @return {qtek.math.Vector3}
     */
    Vector3.copy = function(out, b) {
        vec3.copy(out._array, b._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Vector3} out
     * @param  {qtek.math.Vector3} a
     * @param  {qtek.math.Vector3} b
     * @return {qtek.math.Vector3}
     */
    Vector3.cross = function(out, a, b) {
        vec3.cross(out._array, a._array, b._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Vector3} a
     * @param  {qtek.math.Vector3} b
     * @return {number}
     */
    Vector3.dist = function(a, b) {
        return vec3.distance(a._array, b._array);
    }

    /**
     * @method
     * @param  {qtek.math.Vector3} a
     * @param  {qtek.math.Vector3} b
     * @return {number}
     */
    Vector3.distance = Vector3.dist;

    /**
     * @param  {qtek.math.Vector3} out
     * @param  {qtek.math.Vector3} a
     * @param  {qtek.math.Vector3} b
     * @return {qtek.math.Vector3}
     */
    Vector3.div = function(out, a, b) {
        vec3.divide(out._array, a._array, b._array);
        out._dirty = true;
        return out;
    }

    /**
     * @method
     * @param  {qtek.math.Vector3} out
     * @param  {qtek.math.Vector3} a
     * @param  {qtek.math.Vector3} b
     * @return {qtek.math.Vector3}
     */
    Vector3.divide = Vector3.div;

    /**
     * @param  {qtek.math.Vector3} a
     * @param  {qtek.math.Vector3} b
     * @return {number}
     */
    Vector3.dot = function(a, b) {
        return vec3.dot(a._array, b._array);
    }

    /**
     * @param  {qtek.math.Vector3} a
     * @return {number}
     */
    Vector3.len = function(b) {
        return vec3.length(b._array);
    }

    // Vector3.length = Vector3.len;

    /**
     * @param  {qtek.math.Vector3} out
     * @param  {qtek.math.Vector3} a
     * @param  {qtek.math.Vector3} b
     * @param  {number}  t
     * @return {qtek.math.Vector3}
     */
    Vector3.lerp = function(out, a, b, t) {
        vec3.lerp(out._array, a._array, b._array, t);
        out._dirty = true;
        return out;
    }
    /**
     * @param  {qtek.math.Vector3} out
     * @param  {qtek.math.Vector3} a
     * @param  {qtek.math.Vector3} b
     * @return {qtek.math.Vector3}
     */
    Vector3.min = function(out, a, b) {
        vec3.min(out._array, a._array, b._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Vector3} out
     * @param  {qtek.math.Vector3} a
     * @param  {qtek.math.Vector3} b
     * @return {qtek.math.Vector3}
     */
    Vector3.max = function(out, a, b) {
        vec3.max(out._array, a._array, b._array);
        out._dirty = true;
        return out;
    }
    /**
     * @param  {qtek.math.Vector3} out
     * @param  {qtek.math.Vector3} a
     * @param  {qtek.math.Vector3} b
     * @return {qtek.math.Vector3}
     */
    Vector3.mul = function(out, a, b) {
        vec3.multiply(out._array, a._array, b._array);
        out._dirty = true;
        return out;
    }
    /**
     * @method
     * @param  {qtek.math.Vector3} out
     * @param  {qtek.math.Vector3} a
     * @param  {qtek.math.Vector3} b
     * @return {qtek.math.Vector3}
     */
    Vector3.multiply = Vector3.mul;
    /**
     * @param  {qtek.math.Vector3} out
     * @param  {qtek.math.Vector3} a
     * @return {qtek.math.Vector3}
     */
    Vector3.negate = function(out, a) {
        vec3.negate(out._array, a._array);
        out._dirty = true;
        return out;
    }
    /**
     * @param  {qtek.math.Vector3} out
     * @param  {qtek.math.Vector3} a
     * @return {qtek.math.Vector3}
     */
    Vector3.normalize = function(out, a) {
        vec3.normalize(out._array, a._array);
        out._dirty = true;
        return out;
    }
    /**
     * @param  {qtek.math.Vector3} out
     * @param  {number}  scale
     * @return {qtek.math.Vector3}
     */
    Vector3.random = function(out, scale) {
        vec3.random(out._array, scale);
        out._dirty = true;
        return out;
    }
    /**
     * @param  {qtek.math.Vector3} out
     * @param  {qtek.math.Vector3} a
     * @param  {number}  scale
     * @return {qtek.math.Vector3}
     */
    Vector3.scale = function(out, a, scale) {
        vec3.scale(out._array, a._array, scale);
        out._dirty = true;
        return out;
    }
    /**
     * @param  {qtek.math.Vector3} out
     * @param  {qtek.math.Vector3} a
     * @param  {qtek.math.Vector3} b
     * @param  {number}  scale
     * @return {qtek.math.Vector3}
     */
    Vector3.scaleAndAdd = function(out, a, b, scale) {
        vec3.scaleAndAdd(out._array, a._array, b._array, scale);
        out._dirty = true;
        return out;
    }
    /**
     * @param  {qtek.math.Vector3} a
     * @param  {qtek.math.Vector3} b
     * @return {number}
     */
    Vector3.sqrDist = function(a, b) {
        return vec3.sqrDist(a._array, b._array);
    }
    /**
     * @method
     * @param  {qtek.math.Vector3} a
     * @param  {qtek.math.Vector3} b
     * @return {number}
     */
    Vector3.squaredDistance = Vector3.sqrDist;
    /**
     * @param  {qtek.math.Vector3} a
     * @return {number}
     */
    Vector3.sqrLen = function(a) {
        return vec3.sqrLen(a._array);
    }
    /**
     * @method
     * @param  {qtek.math.Vector3} a
     * @return {number}
     */
    Vector3.squaredLength = Vector3.sqrLen;

    /**
     * @param  {qtek.math.Vector3} out
     * @param  {qtek.math.Vector3} a
     * @param  {qtek.math.Vector3} b
     * @return {qtek.math.Vector3}
     */
    Vector3.sub = function(out, a, b) {
        vec3.subtract(out._array, a._array, b._array);
        out._dirty = true;
        return out;
    }
    /**
     * @method
     * @param  {qtek.math.Vector3} out
     * @param  {qtek.math.Vector3} a
     * @param  {qtek.math.Vector3} b
     * @return {qtek.math.Vector3}
     */
    Vector3.subtract = Vector3.sub;

    /**
     * @param  {qtek.math.Vector3} out
     * @param  {qtek.math.Vector3} a
     * @param  {Matrix3} m
     * @return {qtek.math.Vector3}
     */
    Vector3.transformMat3 = function(out, a, m) {
        vec3.transformMat3(out._array, a._array, m._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Vector3} out
     * @param  {qtek.math.Vector3} a
     * @param  {qtek.math.Matrix4} m
     * @return {qtek.math.Vector3}
     */
    Vector3.transformMat4 = function(out, a, m) {
        vec3.transformMat4(out._array, a._array, m._array);
        out._dirty = true;
        return out;
    }
    /**
     * @param  {qtek.math.Vector3} out
     * @param  {qtek.math.Vector3} a
     * @param  {qtek.math.Quaternion} q
     * @return {qtek.math.Vector3}
     */
    Vector3.transformQuat = function(out, a, q) {
        vec3.transformQuat(out._array, a._array, m._array);
        out._dirty = true;
        return out;
    }
    /**
     * @type {qtek.math.Vector3}
     */
    Vector3.POSITIVE_X = new Vector3(1, 0, 0);
    /**
     * @type {qtek.math.Vector3}
     */
    Vector3.NEGATIVE_X = new Vector3(-1, 0, 0);
    /**
     * @type {qtek.math.Vector3}
     */
    Vector3.POSITIVE_Y = new Vector3(0, 1, 0);
    /**
     * @type {qtek.math.Vector3}
     */
    Vector3.NEGATIVE_Y = new Vector3(0, -1, 0);
    /**
     * @type {qtek.math.Vector3}
     */
    Vector3.POSITIVE_Z = new Vector3(0, 0, 1);
    /**
     * @type {qtek.math.Vector3}
     */
    Vector3.NEGATIVE_Z = new Vector3(0, 0, -1);
    /**
     * @type {qtek.math.Vector3}
     */
    Vector3.UP = new Vector3(0, 1, 0);
    /**
     * @type {qtek.math.Vector3}
     */
    Vector3.ZERO = new Vector3(0, 0, 0);

    return Vector3;
} );
define('qtek/math/Quaternion',['require','glmatrix'],function(require) {

    

    var glMatrix = require("glmatrix");
    var quat = glMatrix.quat;

    /**
     * @constructor
     * @alias qtek.math.Quaternion
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @param {number} w
     */
    var Quaternion = function(x, y, z, w) {

        x = x || 0;
        y = y || 0;
        z = z || 0;
        w = w === undefined ? 1 : w;

        /**
         * Storage of Quaternion, read and write of x, y, z, w will change the values in _array
         * All methods also operate on the _array instead of x, y, z, w components
         * @type {Float32Array}
         */
        this._array = quat.fromValues(x, y, z, w);

        /**
         * Dirty flag is used by the Node to determine
         * if the matrix is updated to latest
         * @type {boolean}
         */
        this._dirty = true;
    }

    Quaternion.prototype = {

        constructor : Quaternion,

        /**
         * @name x
         * @type {number}
         * @memberOf qtek.math.Quaternion
         * @instance
         */
        get x() {
            return this._array[0];
        },

        set x(value) {
            this._array[0] = value;
            this._dirty = true;
        },

        /**
         * @name y
         * @type {number}
         * @memberOf qtek.math.Quaternion
         * @instance
         */
        get y() {
            return this._array[1];
        },

        set y(value) {
            this._array[1] = value;
            this._dirty = true;
        },

        /**
         * @name z
         * @type {number}
         * @memberOf qtek.math.Quaternion
         * @instance
         */
        get z() {
            return this._array[2];
        },

        set z(value) {
            this._array[2] = value;
            this._dirty = true;
        },

        /**
         * @name w
         * @type {number}
         * @memberOf qtek.math.Quaternion
         * @instance
         */
        get w() {
            return this._array[3];
        },

        set w(value) {
            this._array[3] = value;
            this._dirty = true;
        },

        /**
         * Add b to self
         * @param  {qtek.math.Quaternion} b
         * @return {qtek.math.Quaternion}
         */
        add : function(b) {
            quat.add( this._array, this._array, b._array );
            this._dirty = true;
            return this;
        },

        /**
         * Calculate the w component from x, y, z component
         * @return {qtek.math.Quaternion}
         */
        calculateW : function() {
            quat.calculateW(this._array, this._array);
            this._dirty = true;
            return this;
        },

        /**
         * Set x, y and z components
         * @param  {number}  x
         * @param  {number}  y
         * @param  {number}  z
         * @param  {number}  w
         * @return {qtek.math.Quaternion}
         */
        set : function(x, y, z, w) {
            this._array[0] = x;
            this._array[1] = y;
            this._array[2] = z;
            this._array[3] = w;
            this._dirty = true;
            return this;
        },

        /**
         * Set x, y, z and w components from array
         * @param  {Float32Array|number[]} arr
         * @return {qtek.math.Quaternion}
         */
        setArray : function(arr) {
            this._array[0] = arr[0];
            this._array[1] = arr[1];
            this._array[2] = arr[2];
            this._array[3] = arr[3];

            this._dirty = true;
            return this;
        },

        /**
         * Clone a new Quaternion
         * @return {qtek.math.Quaternion}
         */
        clone : function() {
            return new Quaternion( this.x, this.y, this.z, this.w );
        },

        /**
         * Calculates the conjugate of self If the quaternion is normalized, 
         * this function is faster than invert and produces the same result.
         * 
         * @return {qtek.math.Quaternion}
         */
        conjugate : function() {
            quat.conjugate(this._array, this._array);
            this._dirty = true;
            return this;
        },

        /**
         * Copy from b
         * @param  {qtek.math.Quaternion} b
         * @return {qtek.math.Quaternion}
         */
        copy : function(b) {
            quat.copy(this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Dot product of self and b
         * @param  {qtek.math.Quaternion} b
         * @return {number}
         */
        dot : function(b) {
            return quat.dot(this._array, b._array);
        },

        /**
         * Set from the given 3x3 rotation matrix
         * @param  {qtek.math.Matrix3} m
         * @return {qtek.math.Quaternion}
         */
        fromMat3 : function(m) {
            quat.fromMat3(this._array, m._array);
            this._dirty = true;
            return this;
        },

        /**
         * Set from the given 4x4 rotation matrix
         * The 4th column and 4th row will be droped
         * @param  {qtek.math.Matrix4} m
         * @return {qtek.math.Quaternion}
         */
        fromMat4 : (function() {
            var mat3 = glMatrix.mat3;
            var m3 = mat3.create();
            return function(m) {
                mat3.fromMat4(m3, m._array);
                // TODO Not like mat4, mat3 in glmatrix seems to be row-based
                mat3.transpose(m3, m3);
                quat.fromMat3(this._array, m3);
                this._dirty = true;
                return this;
            }
        })(),

        /**
         * Set to identity quaternion
         * @return {qtek.math.Quaternion}
         */
        identity : function() {
            quat.identity(this._array);
            this._dirty = true;
            return this;
        },
        /**
         * Invert self
         * @return {qtek.math.Quaternion}
         */
        invert : function() {
            quat.invert(this._array, this._array);
            this._dirty = true;
            return this;
        },
        /**
         * Alias of length
         * @return {number}
         */
        len : function() {
            return quat.len(this._array);
        },

        /**
         * Calculate the length
         * @return {number}
         */
        length : function() {
            return quat.length(this._array);
        },

        /**
         * Linear interpolation between a and b
         * @param  {qtek.math.Quaternion} a
         * @param  {qtek.math.Quaternion} b
         * @param  {number}  t
         * @return {qtek.math.Quaternion}
         */
        lerp : function(a, b, t) {
            quat.lerp(this._array, a._array, b._array, t);
            this._dirty = true;
            return this;
        },

        /**
         * Alias for multiply
         * @param  {qtek.math.Quaternion} b
         * @return {qtek.math.Quaternion}
         */
        mul : function(b) {
            quat.mul(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Alias for multiplyLeft
         * @param  {qtek.math.Quaternion} a
         * @return {qtek.math.Quaternion}
         */
        mulLeft : function(a) {
            quat.multiply(this._array, a._array, this._array);
            this._dirty = true;
            return this;
        },

        /**
         * Mutiply self and b
         * @param  {qtek.math.Quaternion} b
         * @return {qtek.math.Quaternion}
         */
        multiply : function(b) {
            quat.multiply(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Mutiply a and self
         * Quaternion mutiply is not commutative, so the result of mutiplyLeft is different with multiply.
         * @param  {qtek.math.Quaternion} a
         * @return {qtek.math.Quaternion}
         */
        multiplyLeft : function(a) {
            quat.multiply(this._array, a._array, this._array);
            this._dirty = true;
            return this;
        },

        /**
         * Normalize self
         * @return {qtek.math.Quaternion}
         */
        normalize : function() {
            quat.normalize(this._array, this._array);
            this._dirty = true;
            return this;
        },

        /**
         * Rotate self by a given radian about X axis
         * @param {number} rad
         * @return {qtek.math.Quaternion}
         */
        rotateX : function(rad) {
            quat.rotateX(this._array, this._array, rad); 
            this._dirty = true;
            return this;
        },

        /**
         * Rotate self by a given radian about Y axis
         * @param {number} rad
         * @return {qtek.math.Quaternion}
         */
        rotateY : function(rad) {
            quat.rotateY(this._array, this._array, rad);
            this._dirty = true;
            return this;
        },

        /**
         * Rotate self by a given radian about Z axis
         * @param {number} rad
         * @return {qtek.math.Quaternion}
         */
        rotateZ : function(rad) {
            quat.rotateZ(this._array, this._array, rad);
            this._dirty = true;
            return this;
        },

        /**
         * Sets self to represent the shortest rotation from Vector3 a to Vector3 b.
         * a and b needs to be normalized
         * @param  {qtek.math.Vector3} a
         * @param  {qtek.math.Vector3} b
         * @return {qtek.math.Quaternion}
         */
        rotationTo : function(a, b) {
            quat.rotationTo(this._array, a._array, b._array);
            this._dirty = true;
            return this;
        },
        /**
         * Sets self with values corresponding to the given axes
         * @param {qtek.math.Vector3} view
         * @param {qtek.math.Vector3} right
         * @param {qtek.math.Vector3} up
         * @return {qtek.math.Quaternion}
         */
        setAxes : function(view, right, up) {
            quat.setAxes(this._array, view._array, right._array, up._array);
            this._dirty = true;
            return this;
        },

        /**
         * Sets self with a rotation axis and rotation angle
         * @param {qtek.math.Vector3} axis
         * @param {number} rad
         * @return {qtek.math.Quaternion}
         */
        setAxisAngle : function(axis, rad) {
            quat.setAxisAngle(this._array, axis._array, rad);
            this._dirty = true;
            return this;
        },
        /**
         * Perform spherical linear interpolation between a and b
         * @param  {qtek.math.Quaternion} a
         * @param  {qtek.math.Quaternion} b
         * @param  {number} t
         * @return {qtek.math.Quaternion}
         */
        slerp : function(a, b, t) {
            quat.slerp(this._array, a._array, b._array, t);
            this._dirty = true;
            return this;
        },

        /**
         * Alias for squaredLength
         * @return {number}
         */
        sqrLen : function() {
            return quat.sqrLen(this._array);
        },

        /**
         * Squared length of self
         * @return {number}
         */
        squaredLength : function() {
            return quat.squaredLength(this._array);
        },

        // Set quaternion from euler angle
        setFromEuler : function(v) {
            
        },

        toString : function() {
            return "[" + Array.prototype.join.call(this._array, ",") + "]";
        }
    }

    // Supply methods that are not in place
    
    /**
     * @param  {qtek.math.Quaternion} out
     * @param  {qtek.math.Quaternion} a
     * @param  {qtek.math.Quaternion} b
     * @return {qtek.math.Quaternion}
     */
    Quaternion.add = function(out, a, b) {
        quat.add(out._array, a._array, b._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Quaternion} out
     * @param  {number}     x
     * @param  {number}     y
     * @param  {number}     z
     * @param  {number}     w
     * @return {qtek.math.Quaternion}
     */
    Quaternion.set = function(out, x, y, z, w) {
        quat.set(out._array, x, y, z, w);
        out._dirty = true;
    }

    /**
     * @param  {qtek.math.Quaternion} out
     * @param  {qtek.math.Quaternion} b
     * @return {qtek.math.Quaternion}
     */
    Quaternion.copy = function(out, b) {
        quat.copy(out._array, b._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Quaternion} out
     * @param  {qtek.math.Quaternion} a
     * @return {qtek.math.Quaternion}
     */
    Quaternion.calculateW = function(out, a) {
        quat.calculateW(out._array, a._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Quaternion} out
     * @param  {qtek.math.Quaternion} a
     * @return {qtek.math.Quaternion}
     */
    Quaternion.conjugate = function(out, a) {
        quat.conjugate(out._array, a._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Quaternion} out
     * @return {qtek.math.Quaternion}
     */
    Quaternion.identity = function(out) {
        quat.identity(out._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Quaternion} out
     * @param  {qtek.math.Quaternion} a
     * @return {qtek.math.Quaternion}
     */
    Quaternion.invert = function(out, a) {
        quat.invert(out._array, a._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Quaternion} a
     * @param  {qtek.math.Quaternion} b
     * @return {number}
     */
    Quaternion.dot = function(a, b) {
        return quat.dot(a._array, b._array);
    }

    /**
     * @param  {qtek.math.Quaternion} a
     * @return {number}
     */
    Quaternion.len = function(a) {
        return quat.length(a._array);
    }

    // Quaternion.length = Quaternion.len;

    /**
     * @param  {qtek.math.Quaternion} out
     * @param  {qtek.math.Quaternion} a
     * @param  {qtek.math.Quaternion} b
     * @param  {number}     t
     * @return {qtek.math.Quaternion}
     */
    Quaternion.lerp = function(out, a, b, t) {
        quat.lerp(out._array, a._array, b._array, t);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Quaternion} out
     * @param  {qtek.math.Quaternion} a
     * @param  {qtek.math.Quaternion} b
     * @param  {number}     t
     * @return {qtek.math.Quaternion}
     */
    Quaternion.slerp = function(out, a, b, t) {
        quat.slerp(out._array, a._array, b._array, t);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Quaternion} out
     * @param  {qtek.math.Quaternion} a
     * @param  {qtek.math.Quaternion} b
     * @return {qtek.math.Quaternion}
     */
    Quaternion.mul = function(out, a, b) {
        quat.multiply(out._array, a._array, b._array);
        out._dirty = true;
        return out;
    }

    /**
     * @method
     * @param  {qtek.math.Quaternion} out
     * @param  {qtek.math.Quaternion} a
     * @param  {qtek.math.Quaternion} b
     * @return {qtek.math.Quaternion}
     */
    Quaternion.multiply = Quaternion.mul;

    /**
     * @param  {qtek.math.Quaternion} out
     * @param  {qtek.math.Quaternion} a
     * @param  {number}     rad
     * @return {qtek.math.Quaternion}
     */
    Quaternion.rotateX = function(out, a, rad) {
        quat.rotateX(out._array, a._array, rad);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Quaternion} out
     * @param  {qtek.math.Quaternion} a
     * @param  {number}     rad
     * @return {qtek.math.Quaternion}
     */
    Quaternion.rotateY = function(out, a, rad) {
        quat.rotateY(out._array, a._array, rad);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Quaternion} out
     * @param  {qtek.math.Quaternion} a
     * @param  {number}     rad
     * @return {qtek.math.Quaternion}
     */
    Quaternion.rotateZ = function(out, a, rad) {
        quat.rotateZ(out._array, a._array, rad);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Quaternion} out
     * @param  {qtek.math.Vector3}    axis
     * @param  {number}     rad
     * @return {qtek.math.Quaternion}
     */
    Quaternion.setAxisAngle = function(out, axis, rad) {
        quat.setAxisAngle(out._array, axis._array, rad);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Quaternion} out
     * @param  {qtek.math.Quaternion} a
     * @return {qtek.math.Quaternion}
     */
    Quaternion.normalize = function(out, a) {
        quat.normalize(out._array, a._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Quaternion} a
     * @return {number}
     */
    Quaternion.sqrLen = function(a) {
        return quat.sqrLen(a._array);
    }

    /**
     * @method
     * @param  {qtek.math.Quaternion} a
     * @return {number}
     */
    Quaternion.squaredLength = Quaternion.sqrLen;

    /**
     * @param  {qtek.math.Quaternion} out
     * @param  {qtek.math.Matrix3}    m
     * @return {qtek.math.Quaternion}
     */
    Quaternion.fromMat3 = function(out, m) {
        quat.fromMat3(out._array, m._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Quaternion} out
     * @param  {qtek.math.Vector3}    view
     * @param  {qtek.math.Vector3}    right
     * @param  {qtek.math.Vector3}    up
     * @return {qtek.math.Quaternion}
     */
    Quaternion.setAxes = function(out, view, right, up) {
        quat.setAxes(out._array, view._array, right._array, up._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Quaternion} out
     * @param  {qtek.math.Vector3}    a
     * @param  {qtek.math.Vector3}    b
     * @return {qtek.math.Quaternion}
     */
    Quaternion.rotationTo = function(out, a, b) {
        quat.rotationTo(out._array, a._array, b._array);
        out._dirty = true;
        return out;
    }

    return Quaternion;
});
define('qtek/math/Matrix4',['require','glmatrix','./Vector3'],function(require) {

    

    var glMatrix = require("glmatrix");
    var Vector3 = require("./Vector3");
    var mat4 = glMatrix.mat4;
    var vec3 = glMatrix.vec3;
    var mat3 = glMatrix.mat3;
    var quat = glMatrix.quat;

    function makeProperty(n) {
        return {
            set : function(value) {
                this._array[n] = value;
                this._dirty = true;
            },
            get : function() {
                return this._array[n];
            }
        }
    }

    /**
     * @constructor
     * @alias qtek.math.Matrix4
     */
    var Matrix4 = function() {

        this._axisX = new Vector3();
        this._axisY = new Vector3();
        this._axisZ = new Vector3();

        /**
         * Storage of Matrix4
         * @type {Float32Array}
         */
        this._array = mat4.create();

        /**
         * @type {boolean}
         */
        this._dirty = true;
    };

    Matrix4.prototype = {

        constructor : Matrix4,

        /**
         * Z Axis of local transform
         * @name forward
         * @type {qtek.math.Vector3}
         * @memberOf qtek.math.Matrix4
         * @instance
         */
        get forward() {
            var el = this._array;
            this._axisZ.set(el[8], el[9], el[10]);
            return this._axisZ;
        },

        // TODO Here has a problem
        // If only set an item of vector will not work
        set forward(v) {
            var el = this._array;
            v = v._array;
            el[8] = v[0];
            el[9] = v[1];
            el[10] = v[2];

            this._dirty = true;
        },

        /**
         * Y Axis of local transform
         * @name up
         * @type {qtek.math.Vector3}
         * @memberOf qtek.math.Matrix4
         * @instance
         */
        get up() {
            var el = this._array;
            this._axisY.set(el[4], el[5], el[6]);
            return this._axisY;
        },

        set up(v) {
            var el = this._array;
            v = v._array;
            el[4] = v[0];
            el[5] = v[1];
            el[6] = v[2];

            this._dirty = true;
        },

        /**
         * X Axis of local transform
         * @name right
         * @type {qtek.math.Vector3}
         * @memberOf qtek.math.Matrix4
         * @instance
         */
        get right() {
            var el = this._array;
            this._axisX.set(el[0], el[1], el[2]);
            return this._axisX;
        },

        set right(v) {
            var el = this._array;
            v = v._array;
            el[0] = v[0];
            el[1] = v[1];
            el[2] = v[2];

            this._dirty = true;
        },

        /**
         * Calculate the adjugate of self, in-place
         * @return {qtek.math.Matrix4}
         */
        adjoint : function() {
            mat4.adjoint(this._array, this._array);
            this._dirty = true;
            return this;
        },

        /**
         * Clone a new Matrix4
         * @return {qtek.math.Matrix4}
         */
        clone : function() {
            return (new Matrix4()).copy(this);
        },

        /**
         * Copy from b
         * @param  {qtek.math.Matrix4} b
         * @return {qtek.math.Matrix4}
         */
        copy : function(a) {
            mat4.copy(this._array, a._array);
            this._dirty = true;
            return this;
        },

        /**
         * Calculate matrix determinant
         * @return {number}
         */
        determinant : function() {
            return mat4.determinant(this._array);
        },

        /**
         * Set upper 3x3 part from quaternion
         * @param  {qtek.math.Quaternion} q
         * @return {qtek.math.Matrix4}
         */
        fromQuat : function(q) {
            mat4.fromQuat(this._array, q._array);
            this._dirty = true;
            return this;
        },

        /**
         * Set from a quaternion rotation and a vector translation
         * @param  {qtek.math.Quaternion} q
         * @param  {qtek.math.Vector3} v
         * @return {qtek.math.Matrix4}
         */
        fromRotationTranslation : function(q, v) {
            mat4.fromRotationTranslation(this._array, q._array, v._array);
            this._dirty = true;
            return this;
        },

        /**
         * Set from Matrix2d, it is used when converting a 2d shape to 3d space.
         * In 3d space it is equivalent to ranslate on xy plane and rotate about z axis
         * @param  {qtek.math.Matrix2d} m2d
         * @return {qtek.math.Matrix4}
         */
        fromMat2d : function(m2d) {
            Matrix4.fromMat2d(this, m2d);
            return this;
        },

        /**
         * Set from frustum bounds
         * @param  {number} left
         * @param  {number} right
         * @param  {number} bottom
         * @param  {number} top
         * @param  {number} near
         * @param  {number} far
         * @return {qtek.math.Matrix4}
         */
        frustum : function(left, right, bottom, top, near, far) {
            mat4.frustum(this._array, left, right, bottom, top, near, far);
            this._dirty = true;
            return this;
        },

        /**
         * Set to a identity matrix
         * @return {qtek.math.Matrix4}
         */
        identity : function() {
            mat4.identity(this._array);
            this._dirty = true;
            return this;
        },

        /**
         * Invert self
         * @return {qtek.math.Matrix4}
         */
        invert : function() {
            mat4.invert(this._array, this._array);
            this._dirty = true;
            return this;
        },

        /**
         * Set as a matrix with the given eye position, focal point, and up axis
         * @param  {qtek.math.Vector3} eye
         * @param  {qtek.math.Vector3} center
         * @param  {qtek.math.Vector3} up
         * @return {qtek.math.Matrix4}
         */
        lookAt : function(eye, center, up) {
            mat4.lookAt(this._array, eye._array, center._array, up._array);
            this._dirty = true;
            return this;
        },

        /**
         * Alias for mutiply
         * @param  {qtek.math.Matrix4} b
         * @return {qtek.math.Matrix4}
         */
        mul : function(b) {
            mat4.mul(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Alias for multiplyLeft
         * @param  {qtek.math.Matrix4} a
         * @return {qtek.math.Matrix4}
         */
        mulLeft : function(a) {
            mat4.mul(this._array, a._array, this._array);
            this._dirty = true;
            return this;
        },

        /**
         * Multiply self and b
         * @param  {qtek.math.Matrix4} b
         * @return {qtek.math.Matrix4}
         */
        multiply : function(b) {
            mat4.multiply(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Multiply a and self, a is on the left
         * @param  {qtek.math.Matrix3} a
         * @return {qtek.math.Matrix3}
         */
        multiplyLeft : function(a) {
            mat4.multiply(this._array, a._array, this._array);
            this._dirty = true;
            return this;
        },

        /**
         * Set as a orthographic projection matrix
         * @param  {number} left
         * @param  {number} right
         * @param  {number} bottom
         * @param  {number} top
         * @param  {number} near
         * @param  {number} far
         * @return {qtek.math.Matrix4}
         */
        ortho : function(left, right, bottom, top, near, far) {
            mat4.ortho(this._array, left, right, bottom, top, near, far);
            this._dirty = true;
            return this;
        },
        /**
         * Set as a perspective projection matrix
         * @param  {number} fovy
         * @param  {number} aspect
         * @param  {number} near
         * @param  {number} far
         * @return {qtek.math.Matrix4}
         */
        perspective : function(fovy, aspect, near, far) {
            mat4.perspective(this._array, fovy, aspect, near, far);
            this._dirty = true;
            return this;
        },

        /**
         * Rotate self by rad about axis
         * @param  {number}   rad
         * @param  {qtek.math.Vector3} axis
         * @return {qtek.math.Matrix4}
         */
        rotate : function(rad, axis) {
            mat4.rotate(this._array, this._array, rad, axis._array);
            this._dirty = true;
            return this;
        },

        /**
         * Rotate self by a given radian about X axis
         * @param {number} rad
         * @return {qtek.math.Matrix4}
         */
        rotateX : function(rad) {
            mat4.rotateX(this._array, this._array, rad);
            this._dirty = true;
            return this;
        },

        /**
         * Rotate self by a given radian about Y axis
         * @param {number} rad
         * @return {qtek.math.Matrix4}
         */
        rotateY : function(rad) {
            mat4.rotateY(this._array, this._array, rad);
            this._dirty = true;
            return this;
        },

        /**
         * Rotate self by a given radian about Z axis
         * @param {number} rad
         * @return {qtek.math.Matrix4}
         */
        rotateZ : function(rad) {
            mat4.rotateZ(this._array, this._array, rad);
            this._dirty = true;
            return this;
        },

        /**
         * Scale self by s
         * @param  {qtek.math.Vector3}  s
         * @return {qtek.math.Matrix4}
         */
        scale : function(v) {
            mat4.scale(this._array, this._array, v._array);
            this._dirty = true;
            return this;
        },

        /**
         * Translate self by v
         * @param  {qtek.math.Vector3}  v
         * @return {qtek.math.Matrix4}
         */
        translate : function(v) {
            mat4.translate(this._array, this._array, v._array);
            this._dirty = true;
            return this;
        },

        /**
         * Transpose self, in-place.
         * @return {qtek.math.Matrix2}
         */
        transpose : function() {
            mat4.transpose(this._array, this._array);
            this._dirty = true;
            return this;
        },

        /**
         * Decompose a matrix to SRT
         * @param {qtek.math.Vector3} scale
         * @param {qtek.math.Quaternion} rotation
         * @param {qtek.math.Vector} position
         * @see http://msdn.microsoft.com/en-us/library/microsoft.xna.framework.matrix.decompose.aspx
         */
        decomposeMatrix : (function() {

            var x = vec3.create();
            var y = vec3.create();
            var z = vec3.create();

            var m3 = mat3.create();

            return function(scale, rotation, position) {

                var el = this._array;
                vec3.set(x, el[0], el[1], el[2]);
                vec3.set(y, el[4], el[5], el[6]);
                vec3.set(z, el[8], el[9], el[10]);

                scale.x = vec3.length(x);
                scale.y = vec3.length(y);
                scale.z = vec3.length(z);

                position.set(el[12], el[13], el[14]);

                mat3.fromMat4(m3, el);
                // Not like mat4, mat3 in glmatrix seems to be row-based
                mat3.transpose(m3, m3);

                m3[0] /= scale.x;
                m3[1] /= scale.x;
                m3[2] /= scale.x;

                m3[3] /= scale.y;
                m3[4] /= scale.y;
                m3[5] /= scale.y;

                m3[6] /= scale.z;
                m3[7] /= scale.z;
                m3[8] /= scale.z;

                quat.fromMat3(rotation._array, m3);
                quat.normalize(rotation._array, rotation._array);

                scale._dirty = true;
                rotation._dirty = true;
                position._dirty = true;
            }
        })(),

        toString : function() {
            return "[" + Array.prototype.join.call(this._array, ",") + "]";
        }
    }

    // Object.defineProperty(Matrix4.prototype, 'm00', makeProperty(0));
    // Object.defineProperty(Matrix4.prototype, 'm01', makeProperty(1));
    // Object.defineProperty(Matrix4.prototype, 'm02', makeProperty(2));
    // Object.defineProperty(Matrix4.prototype, 'm03', makeProperty(3));
    // Object.defineProperty(Matrix4.prototype, 'm10', makeProperty(4));
    // Object.defineProperty(Matrix4.prototype, 'm11', makeProperty(5));
    // Object.defineProperty(Matrix4.prototype, 'm12', makeProperty(6));
    // Object.defineProperty(Matrix4.prototype, 'm13', makeProperty(7));
    // Object.defineProperty(Matrix4.prototype, 'm20', makeProperty(8));
    // Object.defineProperty(Matrix4.prototype, 'm21', makeProperty(9));
    // Object.defineProperty(Matrix4.prototype, 'm22', makeProperty(10));
    // Object.defineProperty(Matrix4.prototype, 'm23', makeProperty(11));
    // Object.defineProperty(Matrix4.prototype, 'm30', makeProperty(12));
    // Object.defineProperty(Matrix4.prototype, 'm31', makeProperty(13));
    // Object.defineProperty(Matrix4.prototype, 'm32', makeProperty(14));
    // Object.defineProperty(Matrix4.prototype, 'm33', makeProperty(15));

    /**
     * @param  {qtek.math.Matrix4} out
     * @param  {qtek.math.Matrix4} a
     * @return {qtek.math.Matrix4}
     */
    Matrix4.adjoint = function(out, a) {
        mat4.adjoint(out._array, a._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix4} out
     * @param  {qtek.math.Matrix4} a
     * @return {qtek.math.Matrix4}
     */
    Matrix4.copy = function(out, a) {
        mat4.copy(out._array, a._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix4} a
     * @return {number}
     */
    Matrix4.determinant = function(a) {
        return mat4.determinant(a._array);
    }

    /**
     * @param  {qtek.math.Matrix4} out
     * @return {qtek.math.Matrix4}
     */
    Matrix4.identity = function(out) {
        mat4.identity(out._array);
        out._dirty = true;
        return out;
    }
    
    /**
     * @param  {qtek.math.Matrix4} out
     * @param  {number}  left
     * @param  {number}  right
     * @param  {number}  bottom
     * @param  {number}  top
     * @param  {number}  near
     * @param  {number}  far
     * @return {qtek.math.Matrix4}
     */
    Matrix4.ortho = function(out, left, right, bottom, top, near, far) {
        mat4.ortho(out._array, left, right, bottom, top, near, far);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix4} out
     * @param  {number}  fovy
     * @param  {number}  aspect
     * @param  {number}  near
     * @param  {number}  far
     * @return {qtek.math.Matrix4}
     */
    Matrix4.perspective = function(out, fovy, aspect, near, far) {
        mat4.perspective(out._array, fovy, aspect, near, far);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix4} out
     * @param  {qtek.math.Vector3} eye
     * @param  {qtek.math.Vector3} center
     * @param  {qtek.math.Vector3} up
     * @return {qtek.math.Matrix4}
     */
    Matrix4.lookAt = function(out, eye, center, up) {
        mat4.lookAt(out._array, eye._array, center._array, up._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix4} out
     * @param  {qtek.math.Matrix4} a
     * @return {qtek.math.Matrix4}
     */
    Matrix4.invert = function(out, a) {
        mat4.invert(out._array, a._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix4} out
     * @param  {qtek.math.Matrix4} a
     * @param  {qtek.math.Matrix4} b
     * @return {qtek.math.Matrix4}
     */
    Matrix4.mul = function(out, a, b) {
        mat4.mul(out._array, a._array, b._array);
        out._dirty = true;
        return out;
    }

    /**
     * @method
     * @param  {qtek.math.Matrix4} out
     * @param  {qtek.math.Matrix4} a
     * @param  {qtek.math.Matrix4} b
     * @return {qtek.math.Matrix4}
     */
    Matrix4.multiply = Matrix4.mul;

    /**
     * @param  {qtek.math.Matrix4}    out
     * @param  {qtek.math.Quaternion} q
     * @return {qtek.math.Matrix4}
     */
    Matrix4.fromQuat = function(out, q) {
        mat4.fromQuat(out._array, q._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix4}    out
     * @param  {qtek.math.Quaternion} q
     * @param  {qtek.math.Vector3}    v
     * @return {qtek.math.Matrix4}
     */
    Matrix4.fromRotationTranslation = function(out, q, v) {
        mat4.fromRotationTranslation(out._array, q._array, v._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix4} m4
     * @param  {qtek.math.Matrix2d} m2d
     * @return {qtek.math.Matrix4}
     */
    Matrix4.fromMat2d = function(m4, m2d) {
        m4._dirty = true;
        var m2d = m2d._array;
        var m4 = m4._array;

        m4[0] = m2d[0];
        m4[4] = m2d[2];
        m4[12] = m2d[4];

        m4[1] = m2d[1];
        m4[5] = m2d[3];
        m4[13] = m2d[5];

        return m4;
    }

    /**
     * @param  {qtek.math.Matrix4} out
     * @param  {qtek.math.Matrix4} a
     * @param  {number}  rad
     * @param  {qtek.math.Vector3} axis
     * @return {qtek.math.Matrix4}
     */
    Matrix4.rotate = function(out, a, rad, axis) {
        mat4.rotate(out._array, a._array, rad, axis._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix4} out
     * @param  {qtek.math.Matrix4} a
     * @param  {number}  rad
     * @return {qtek.math.Matrix4}
     */
    Matrix4.rotateX = function(out, a, rad) {
        mat4.rotateX(out._array, a._array, rad);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix4} out
     * @param  {qtek.math.Matrix4} a
     * @param  {number}  rad
     * @return {qtek.math.Matrix4}
     */
    Matrix4.rotateY = function(out, a, rad) {
        mat4.rotateY(out._array, a._array, rad);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix4} out
     * @param  {qtek.math.Matrix4} a
     * @param  {number}  rad
     * @return {qtek.math.Matrix4}
     */
    Matrix4.rotateZ = function(out, a, rad) {
        mat4.rotateZ(out._array, a._array, rad);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix4} out
     * @param  {qtek.math.Matrix4} a
     * @param  {qtek.math.Vector3} v
     * @return {qtek.math.Matrix4}
     */
    Matrix4.scale = function(out, a, v) {
        mat4.scale(out._array, a._array, v._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix4} out
     * @param  {qtek.math.Matrix4} a
     * @return {qtek.math.Matrix4}
     */
    Matrix4.transpose = function(out, a) {
        mat4.transpose(out._array, a._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix4} out
     * @param  {qtek.math.Matrix4} a
     * @param  {qtek.math.Vector3} v
     * @return {qtek.math.Matrix4}
     */
    Matrix4.translate = function(out, a, v) {
        mat4.translate(out._array, a._array, v._array);
        out._dirty = true;
        return out;
    }

    return Matrix4;
});
define('qtek/math/Matrix3',['require','glmatrix'],function(require) {

    

    var glMatrix = require("glmatrix");
    var mat3 = glMatrix.mat3;

    function makeProperty(n) {
        return {
            configurable : false,
            set : function(value) {
                this._array[n] = value;
                this._dirty = true;
            },
            get : function() {
                return this._array[n];
            }
        }
    }

    /**
     * @constructor
     * @alias qtek.math.Matrix3
     */
    var Matrix3 = function() {

        /**
         * Storage of Matrix3
         * @type {Float32Array}
         */
        this._array = mat3.create();

        /**
         * @type {boolean}
         */
        this._dirty = true;
    };

    Matrix3.prototype = {

        constructor : Matrix3,

        /**
         * Calculate the adjugate of self, in-place
         * @return {qtek.math.Matrix3}
         */
        adjoint : function() {
            mat3.adjoint(this._array, this._array);
            this._dirty = true;
            return this;
        },

        /**
         * Clone a new Matrix3
         * @return {qtek.math.Matrix3}
         */
        clone : function() {
            return (new Matrix3()).copy(this);
        },

        /**
         * Copy from b
         * @param  {qtek.math.Matrix3} b
         * @return {qtek.math.Matrix3}
         */
        copy : function(b) {
            mat3.copy(this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Calculate matrix determinant
         * @return {number}
         */
        determinant : function() {
            return mat3.determinant(this._array);
        },

        /**
         * Copy the values from Matrix2d a
         * @param  {qtek.math.Matrix2d} a
         * @return {qtek.math.Matrix3}
         */
        fromMat2d : function(a) {
            mat3.fromMat2d(this._array, a._array);
            this._dirty = true;
            return this;
        },

        /**
         * Copies the upper-left 3x3 values of Matrix4
         * @param  {qtek.math.Matrix4} a
         * @return {qtek.math.Matrix3}
         */
        fromMat4 : function(a) {
            mat3.fromMat4(this._array, a._array);
            this._dirty = true;
            return this;
        },

        /**
         * Calculates a rotation matrix from the given quaternion
         * @param  {qtek.math.Quaternion} q
         * @return {qtek.math.Matrix3}
         */
        fromQuat : function(q) {
            mat3.fromQuat(this._array, q._array);
            this._dirty = true;
            return this;
        },

        /**
         * Set to a identity matrix
         * @return {qtek.math.Matrix3}
         */
        identity : function() {
            mat3.identity(this._array);
            this._dirty = true;
            return this;
        },

        /**
         * Invert self
         * @return {qtek.math.Matrix3}
         */
        invert : function() {
            mat3.invert(this._array, this._array);
            this._dirty = true;
            return this;
        },

        /**
         * Alias for mutiply
         * @param  {qtek.math.Matrix3} b
         * @return {qtek.math.Matrix3}
         */
        mul : function(b) {
            mat3.mul(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Alias for multiplyLeft
         * @param  {qtek.math.Matrix3} a
         * @return {qtek.math.Matrix3}
         */
        mulLeft : function(a) {
            mat3.mul(this._array, a._array, this._array);
            this._dirty = true;
            return this;
        },

        /**
         * Multiply self and b
         * @param  {qtek.math.Matrix3} b
         * @return {qtek.math.Matrix3}
         */
        multiply : function(b) {
            mat3.multiply(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Multiply a and self, a is on the left
         * @param  {qtek.math.Matrix3} a
         * @return {qtek.math.Matrix3}
         */
        multiplyLeft : function(a) {
            mat3.multiply(this._array, a._array, this._array);
            this._dirty = true;
            return this;
        },

        /**
         * Rotate self by a given radian
         * @param  {number}   rad
         * @return {qtek.math.Matrix3}
         */
        rotate : function(rad) {
            mat3.rotate(this._array, this._array, rad);
            this._dirty = true;
            return this;
        },

        /**
         * Scale self by s
         * @param  {qtek.math.Vector2}  s
         * @return {qtek.math.Matrix3}
         */
        scale : function(v) {
            mat3.scale(this._array, this._array, v._array);
            this._dirty = true;
            return this;
        },

        /**
         * Translate self by v
         * @param  {qtek.math.Vector2}  v
         * @return {qtek.math.Matrix3}
         */
        translate : function(v) {
            mat3.translate(this._array, this._array, v._array);
            this._dirty = true;
            return this;
        },
        /**
         * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
         * @param {qtek.math.Matrix4} a
         */
        normalFromMat4 : function(a) {
            mat3.normalFromMat4(this._array, a._array);
            this._dirty = true;
            return this;
        },

        /**
         * Transpose self, in-place.
         * @return {qtek.math.Matrix2}
         */
        transpose : function() {
            mat3.transpose(this._array, this._array);
            this._dirty = true;
            return this;
        },
        toString : function() {
            return "[" + Array.prototype.join.call(this._array, ",") + "]";
        }
    }
    /**
     * @param  {qtek.math.Matrix3} out
     * @param  {qtek.math.Matrix3} a
     * @return {qtek.math.Matrix3}
     */
    Matrix3.adjoint = function(out, a) {
        mat3.adjoint(out._array, a._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix3} out
     * @param  {qtek.math.Matrix3} a
     * @return {qtek.math.Matrix3}
     */
    Matrix3.copy = function(out, a) {
        mat3.copy(out._array, a._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix3} a
     * @return {number}
     */
    Matrix3.determinant = function(a) {
        return mat3.determinant(a._array);
    }

    /**
     * @param  {qtek.math.Matrix3} out
     * @return {qtek.math.Matrix3}
     */
    Matrix3.identity = function(out) {
        mat3.identity(out._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix3} out
     * @param  {qtek.math.Matrix3} a
     * @return {qtek.math.Matrix3}
     */
    Matrix3.invert = function(out, a) {
        mat3.invert(out._array, a._array);
        return out;
    }

    /**
     * @param  {qtek.math.Matrix3} out
     * @param  {qtek.math.Matrix3} a
     * @param  {qtek.math.Matrix3} b
     * @return {qtek.math.Matrix3}
     */
    Matrix3.mul = function(out, a, b) {
        mat3.mul(out._array, a._array, b._array);
        out._dirty = true;
        return out;
    }

    /**
     * @method
     * @param  {qtek.math.Matrix3} out
     * @param  {qtek.math.Matrix3} a
     * @param  {qtek.math.Matrix3} b
     * @return {qtek.math.Matrix3}
     */
    Matrix3.multiply = Matrix3.mul;
    
    /**
     * @param  {qtek.math.Matrix3}  out
     * @param  {qtek.math.Matrix2d} a
     * @return {qtek.math.Matrix3}
     */
    Matrix3.fromMat2d = function(out, a) {
        mat3.fromMat2d(out._array, a._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix3} out
     * @param  {qtek.math.Matrix4} a
     * @return {qtek.math.Matrix3}
     */
    Matrix3.fromMat4 = function(out, a) {
        mat3.fromMat4(out._array, a._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix3}    out
     * @param  {qtek.math.Quaternion} a
     * @return {qtek.math.Matrix3}
     */
    Matrix3.fromQuat = function(out, q) {
        mat3.fromQuat(out._array, q._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix3} out
     * @param  {qtek.math.Matrix4} a
     * @return {qtek.math.Matrix3}
     */
    Matrix3.normalFromMat4 = function(out, a) {
        mat3.normalFromMat4(out._array, a._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix3} out
     * @param  {qtek.math.Matrix3} a
     * @param  {number}  rad
     * @return {qtek.math.Matrix3}
     */
    Matrix3.rotate = function(out, a, rad) {
        mat3.rotate(out._array, a._array, rad);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix3} out
     * @param  {qtek.math.Matrix3} a
     * @param  {qtek.math.Vector2} v
     * @return {qtek.math.Matrix3}
     */
    Matrix3.scale = function(out, a, v) {
        mat3.scale(out._array, a._array, v._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix3} out
     * @param  {qtek.math.Matrix3} a
     * @return {qtek.math.Matrix3}
     */
    Matrix3.transpose = function(out, a) {
        mat3.transpose(out._array, a._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix3} out
     * @param  {qtek.math.Matrix3} a
     * @param  {qtek.math.Vector2} v
     * @return {qtek.math.Matrix3}
     */
    Matrix3.translate = function(out, a, v) {
        mat3.translate(out._array, a._array, v._array);
        out._dirty = true;
        return out;
    }

    return Matrix3;
});
define('qtek/Node',['require','./core/Base','./core/util','./math/Vector3','./math/Quaternion','./math/Matrix4','./math/Matrix3','glmatrix'],function(require) {
    
    

    var Base = require("./core/Base");
    var util = require("./core/util");
    var Vector3 = require("./math/Vector3");
    var Quaternion = require("./math/Quaternion");
    var Matrix4 = require("./math/Matrix4");
    var Matrix3 = require("./math/Matrix3");
    var glMatrix = require('glmatrix');
    var mat4 = glMatrix.mat4;

    var nameId = 0;

    /**
     * @constructor qtek.Node
     */
    var Node = Base.derive(
    /** @lends qtek.Node# */
    {
        /**
         * Scene node name
         * @type {string}
         */
        name: '',

        /**
         * Position relative to its parent node. aka translation.
         * @type {qtek.math.Vector3}
         */
        position: null,
        
        /**
         * Rotation relative to its parent node. Represented with a quaternion
         * @type {qtek.math.Quaternion}
         */
        rotation: null,
        
        /**
         * Scale relative to its parent node
         * @type {qtek.math.Vector3}
         */
        scale: null,

        /**
         * Affine transform matrix relative to its root scene.
         * @type {qtek.math.Matrix4}
         */
        worldTransform: null,

        /**
         * Affine transform matrix relative to its parent node.
         * Composite with position, rotation and scale.
         * @type {qtek.math.Matrix4}
         */
        localTransform: null,
        
        /**
         * Parent of current scene node
         * @type {qtek.Node}
         */
        parent : null,
        
        /**
         * The root scene attached to. Null if it is a isolated node
         * @type {qtek.Scene}
         */
        scene : null,

        /**
         * If the local transform is update from SRT(scale, rotation, translation, which is position here) each frame
         * @type {boolean}
         */
        autoUpdateLocalTransform : true,

        _needsUpdateWorldTransform : true,

        _inIterating : false,

        // Depth for transparent queue sorting
        __depth : 0

    }, function() {

        if (!this.name) {
            this.name = 'NODE_' + (nameId++);
        }

        if (!this.position) {
            this.position = new Vector3();
        }
        if (!this.rotation) {
            this.rotation = new Quaternion();
        }
        if (!this.scale) {
            this.scale = new Vector3(1, 1, 1);
        }

        this.worldTransform = new Matrix4();
        this.localTransform = new Matrix4();

        this._children = [];

    },
    /**@lends qtek.Node.prototype. */
    {

        /**
         * If node and its chilren visible
         * @type {Boolean}
         * @memberOf qtek.Node
         * @instance
         */
        visible : true,

        /**
         * Return true if it is a renderable scene node, like Mesh and ParticleSystem
         * @return {boolean}
         */
        isRenderable : function() {
            return false;
        },

        /**
         * Set the name of the scene node
         * @param {string} name
         */
        setName : function(name) {
            if (this.scene) {
                delete this.scene._nodeRepository[this.name];
                this.scene._nodeRepository[name] = this;
            }
            this.name = name;
        },

        /**
         * Add a child node
         * @param {qtek.Node} node
         */
        add : function(node) {
            if (this._inIterating) {
                console.warn('Add operation can cause unpredictable error when in iterating');
            }
            if (node.parent === this) {
                return;
            }
            if (node.parent) {
                node.parent.remove(node);
            }
            node.parent = this;
            this._children.push(node);

            if (this.scene && this.scene !== node.scene) {
                node.traverse(this._addSelfToScene, this);
            }
        },

        /**
         * Remove the specified child scene node
         * @param {qtek.Node} node
         */
        remove : function(node) {
            if (this._inIterating) {
                console.warn('Remove operation can cause unpredictable error when in iterating');
            }

            this._children.splice(this._children.indexOf(node), 1);
            node.parent = null;

            if (this.scene) {
                node.traverse(this._removeSelfFromScene, this);
            }
        },

        _removeSelfFromScene : function(descendant) {
            descendant.scene.removeFromScene(descendant);
            descendant.scene = null;
        },

        _addSelfToScene : function(descendant, parent) {
            parent.scene.addToScene(descendant);
            descendant.scene = parent.scene;
        },

        /**
         * Return true if it is ancestor of the given scene node
         * @param {qtek.Node} node
         */
        isAncestor : function(node) {
            var parent = node.parent;
            while(parent) {
                if (parent === this) {
                    return true;
                }
                parent = parent.parent;
            }
            return false;
        },

        /**
         * Get a new created array of all its children nodes
         * @return {qtek.Node[]}
         */
        children : function() {
            return this._children.slice();
        },

        childAt : function(idx) {
            return this._children[idx];
        },

        /**
         * Get first child have the given name
         * @param {string} name
         * @return {qtek.Node}
         */
        getChildByName : function(name) {
            for (var i = 0; i < this._children.length; i++) {
                if (this._children[i].name === name) {
                    return this._children[i];
                }
            }
        },

        /**
         * Get first descendant have the given name
         * @param {string} name
         * @return {qtek.Node}
         */
        getDescendantByName : function(name) {
            for (var i = 0; i < this._children.length; i++) {
                var child = this._children[i];
                if (child.name === name) {
                    return child;
                } else {
                    var res = child.getDescendantByName(name);
                    if (res) {
                        return res;
                    }
                }
            }
        },

        /**
         * Depth first traverse all its descendant scene nodes and
         * @param {Function} callback
         * @param {Node} [parent]
         * @param {Function} [ctor]
         */
        traverse : function(callback, parent, ctor) {
            
            this._inIterating = true;

            if (ctor === undefined || this.constructor === ctor) {
                callback(this, parent);
            }
            var _children = this._children;
            for(var i = 0, len = _children.length; i < len; i++) {
                _children[i].traverse(callback, this, ctor);
            }

            this._inIterating = false;
        },

        /**
         * Set the local transform and decompose to SRT
         * @param {qtek.math.Matrix4} matrix
         */
        setLocalTransform : function(matrix) {
            mat4.copy(this.localTransform._array, matrix._array);
            this.decomposeLocalTransform();
        },

        /**
         * Decompose the local transform to SRT
         */
        decomposeLocalTransform : function() {
            this.localTransform.decomposeMatrix(this.scale, this.rotation, this.position);
        },

        /**
         * Set the world transform and decompose to SRT
         * @param {qtek.math.Matrix4} matrix
         */
        setWorldTransform : function(matrix) {
            mat4.copy(this.worldTransform._array, matrix._array);
            this.decomposeWorldTransform();
        },

        /**
         * Decompose the world transform to SRT
         * @method
         */
        decomposeWorldTransform : (function() {
            
            var tmp = mat4.create();

            return function(matrix) {
                // Assume world transform is updated
                if (this.parent) {
                    mat4.invert(tmp, this.parent.worldTransform._array);
                    mat4.multiply(this.localTransform._array, tmp, this.worldTransform._array);
                } else {
                    mat4.copy(this.localTransform._array, matrix._array);
                }
                this.localTransform.decomposeMatrix(this.scale, this.rotation, this.position);
            }
        })(),

        /**
         * Update local transform from SRT
         * Notice that local transform will not be updated if _dirty mark of position, rotation, scale is all false
         */
        updateLocalTransform : function() {
            var position = this.position;
            var rotation = this.rotation;
            var scale = this.scale;

            if (position._dirty || scale._dirty || rotation._dirty) {
                var m = this.localTransform._array;

                // Transform order, scale->rotation->position
                mat4.fromRotationTranslation(m, rotation._array, position._array);

                mat4.scale(m, m, scale._array);

                rotation._dirty = false;
                scale._dirty = false;
                position._dirty = false;

                this._needsUpdateWorldTransform = true;
            }
        },

        /**
         * Update world transform, assume its parent world transform have been updated
         */
        updateWorldTransform : function() {
            if (this.parent) {
                mat4.multiply(
                    this.worldTransform._array,
                    this.parent.worldTransform._array,
                    this.localTransform._array
                )
            } else {
                mat4.copy(
                    this.worldTransform._array, this.localTransform._array 
                )
            }
        },

        /**
         * Update local transform and world transform recursively
         * @param {boolean} forceUpdateWorld 
         */
        update : function(forceUpdateWorld) {
            if (this.autoUpdateLocalTransform) {
                this.updateLocalTransform();
            } else {
                // Transform is manually setted
                forceUpdateWorld = true;
            }

            if (forceUpdateWorld || this._needsUpdateWorldTransform) {
                this.updateWorldTransform();
                forceUpdateWorld = true;
                this._needsUpdateWorldTransform = false;
            }
            
            for(var i = 0, len = this._children.length; i < len; i++) {
                this._children[i].update(forceUpdateWorld);
            }
        },

        /**
         * Get world position, extracted from world transform
         * @param  {math.Vector3} [out]
         * @return {math.Vector3}
         */
        getWorldPosition : function(out) {
            var m = this.worldTransform._array;
            if (out) {
                out._array[0] = m[12];
                out._array[1] = m[13];
                out._array[2] = m[14];
                return out;
            } else {
                return new Vector3(m[12], m[13], m[14]);
            }
        },

        /**
         * Get cloned node
         * @return {Node}
         */
        clone : function() {
            // TODO Name
            var node = new this.constructor();
            node.position.copy(this.position);
            node.rotation.copy(this.rotation);
            node.scale.copy(this.scale);

            for (var i = 0; i < this._children.length; i++) {
                node.add(this._children[i].clone());
            }
            return node;
        },

        /**
         * Rotate the node around a axis by angle degrees, axis passes through point
         * @param {math.Vector3} point Center point
         * @param {math.Vector3} axis  Center axis
         * @param {number}       angle Rotation angle
         * @see http://docs.unity3d.com/Documentation/ScriptReference/Transform.RotateAround.html
         * @method
         */
        rotateAround : (function() {
            var v = new Vector3();
            var RTMatrix = new Matrix4();

            // TODO improve performance
            return function(point, axis, angle) {

                v.copy(this.position).subtract(point);

                this.localTransform.identity();
                // parent node
                this.localTransform.translate(point);
                this.localTransform.rotate(angle, axis);

                RTMatrix.fromRotationTranslation(this.rotation, v);
                this.localTransform.multiply(RTMatrix);
                this.localTransform.scale(this.scale);

                this.decomposeLocalTransform();
                this._needsUpdateWorldTransform = true;
            }
        })(),

        /**
         * @param {math.Vector3} target
         * @param {math.Vector3} [up]
         * @see http://www.opengl.org/sdk/docs/man2/xhtml/gluLookAt.xml
         * @method
         */
        lookAt : (function() {
            var m = new Matrix4();
            var scaleVector = new Vector3();
            return function(target, up) {
                m.lookAt(this.position, target, up || this.localTransform.up).invert();
                m.decomposeMatrix(scaleVector, this.rotation, this.position);
            }
        })()
    });

    return Node;
});
define('qtek/math/BoundingBox',['require','./Vector3','glmatrix'],function(require) {

    var Vector3 = require("./Vector3");
    var glMatrix = require('glmatrix');
    var mat4 = glMatrix.mat4;
    var vec3 = glMatrix.vec3;

    var vec3TransformMat4 = vec3.transformMat4;
    var vec3Copy = vec3.copy;
    var vec3Set = vec3.set;

    /**
     * Axis aligned bounding box
     * @constructor
     * @alias qtek.math.BoundingBox
     * @param {qtek.math.Vector3} [min]
     * @param {qtek.math.Vector3} [max]
     */
    var BoundingBox = function(min, max) {

        /**
         * Minimum coords of bounding box
         * @type {qtek.math.Vector3}
         */
        this.min = min || new Vector3(Infinity, Infinity, Infinity);

        /**
         * Maximum coords of bounding box
         * @type {qtek.math.Vector3}
         */
        this.max = max || new Vector3(-Infinity, -Infinity, -Infinity);

        // Cube vertices
        var vertices = [];
        for (var i = 0; i < 8; i++) {
            vertices[i] = vec3.fromValues(0, 0, 0);
        }

        /**
         * Eight coords of bounding box
         * @type {Float32Array[]}
         */
        this.vertices = vertices;
    }

    BoundingBox.prototype = {
        
        constructor : BoundingBox,
        /**
         * Update min and max coords from a vertices array
         * @param  {array} vertices
         */
        updateFromVertices : function(vertices) {
            if (vertices.length > 0) {
                var _min = this.min._array;
                var _max = this.max._array;
                vec3Copy(_min, vertices[0]);
                vec3Copy(_max, vertices[0]);
                for (var i = 1; i < vertices.length; i++) {
                    var vertex = vertices[i];

                    _min[0] = Math.min(vertex[0], _min[0]);
                    _min[1] = Math.min(vertex[1], _min[1]);
                    _min[2] = Math.min(vertex[2], _min[2]);

                    _max[0] = Math.max(vertex[0], _max[0]);
                    _max[1] = Math.max(vertex[1], _max[1]);
                    _max[2] = Math.max(vertex[2], _max[2]);
                }
                this.min._dirty = true;
                this.max._dirty = true;
            }
        },

        /**
         * Union operation with another bounding box
         * @param  {qtek.math.BoundingBox} bbox
         */
        union : function(bbox) {
            vec3.min(this.min._array, this.min._array, bbox.min._array);
            vec3.max(this.max._array, this.max._array, bbox.max._array);
            this.min._dirty = true;
            this.max._dirty = true;
        },

        /**
         * If intersect with another bounding box
         * @param  {qtek.math.BoundingBox} bbox
         * @return {boolean}
         */
        intersectBoundingBox : function(bbox) {
            var _min = this.min._array;
            var _max = this.max._array;

            var _min2 = bbox.min._array;
            var _max2 = bbox.max._array;

            return ! (_min[0] > _max2[0] || _min[1] > _max2[1] || _min[2] > _max2[1]
                || _max[0] < _min2[0] || _max[1] < _min2[1] || _max[2] < _min2[2]);
        },

        /**
         * Apply an affine transform matrix to the bounding box 
         * @param  {qtek.math.Matrix4} matrix
         */
        applyTransform : function(matrix) {
            if (this.min._dirty || this.max._dirty) {
                this.updateVertices();
                this.min._dirty = false;
                this.max._dirty = false;
            }

            var m4 = matrix._array;
            var _min = this.min._array;
            var _max = this.max._array;
            var vertices = this.vertices;

            var v = vertices[0];
            vec3TransformMat4(v, v, m4);
            vec3Copy(_min, v);
            vec3Copy(_max, v);

            for (var i = 1; i < 8; i++) {
                v = vertices[i];
                vec3TransformMat4(v, v, m4);

                _min[0] = Math.min(v[0], _min[0]);
                _min[1] = Math.min(v[1], _min[1]);
                _min[2] = Math.min(v[2], _min[2]);

                _max[0] = Math.max(v[0], _max[0]);
                _max[1] = Math.max(v[1], _max[1]);
                _max[2] = Math.max(v[2], _max[2]);
            }

            this.min._dirty = true;
            this.max._dirty = true;
        },

        /**
         * Apply an projection matrix to the bounding box
         * @param  {qtek.math.Matrix4} matrix
         */
        applyProjection : function(matrix) {
            if (this.min._dirty || this.max._dirty) {
                this.updateVertices();
                this.min._dirty = false;
                this.max._dirty = false;
            }

            var m = matrix._array;
            // min in min z
            var v1 = this.vertices[0];
            // max in min z
            var v2 = this.vertices[3];
            // max in max z
            var v3 = this.vertices[7];

            var _min = this.min._array;
            var _max = this.max._array;

            if (m[15] === 1) {  // Orthographic projection
                _min[0] = m[0] * v1[0] + m[12];
                _min[1] = m[5] * v1[1] + m[13];
                _max[2] = m[10] * v1[2] + m[14];

                _max[0] = m[0] * v3[0] + m[12];
                _max[1] = m[5] * v3[1] + m[13];
                _min[2] = m[10] * v3[2] + m[14];
            } else {
                var w = -1 / v1[2];
                _min[0] = m[0] * v1[0] * w;
                _min[1] = m[5] * v1[1] * w;
                _max[2] = (m[10] * v1[2] + m[14]) * w;

                w = -1 / v2[2];
                _max[0] = m[0] * v2[0] * w;
                _max[1] = m[5] * v2[1] * w;

                w = -1 / v3[2];
                _min[2] = (m[10] * v3[2] + m[14]) * w;
            }
            this.min._dirty = true;
            this.max._dirty = true;
        },

        updateVertices : function() {
            var min = this.min._array;
            var max = this.max._array;
            var vertices = this.vertices;
            //--- min z
            // min x
            vec3Set(vertices[0], min[0], min[1], min[2]);
            vec3Set(vertices[1], min[0], max[1], min[2]);
            // max x
            vec3Set(vertices[2], max[0], min[1], min[2]);
            vec3Set(vertices[3], max[0], max[1], min[2]);

            //-- max z
            vec3Set(vertices[4], min[0], min[1], max[2]);
            vec3Set(vertices[5], min[0], max[1], max[2]);
            vec3Set(vertices[6], max[0], min[1], max[2]);
            vec3Set(vertices[7], max[0], max[1], max[2]);
        },
        /**
         * Copy values from another bounding box
         * @param  {qtek.math.BoundingBox} bbox
         */
        copy : function(bbox) {
            vec3Copy(this.min._array, bbox.min._array);
            vec3Copy(this.max._array, bbox.max._array);
            this.min._dirty = true;
            this.max._dirty = true;
        },

        /**
         * Clone a new bounding box
         * @return {qtek.math.BoundingBox}
         */
        clone : function() {
            var boundingBox = new BoundingBox();
            boundingBox.copy(this);
            return boundingBox;
        }
    };

    return BoundingBox;
});
define('qtek/math/Plane',['require','./Vector3','glmatrix'],function(require) {

    var Vector3 = require('./Vector3');
    var glmatrix = require('glmatrix');
    var vec3 = glmatrix.vec3;
    var mat4 = glmatrix.mat4;
    var vec4 = glmatrix.vec4;

    /**
     * @constructor
     * @alias qtek.math.Plane
     * @param {qtek.math.Vector3} [normal]
     * @param {number} [distance]
     */
    var Plane = function(normal, distance) {
        /**
         * Normal of the plane
         * @type {qtek.math.Vector3}
         */
        this.normal = normal || new Vector3(0, 1, 0);

        /**
         * Constant of the plane equation, used as distance to the origin
         * @type {number}
         */
        this.distance = distance || 0;
    }

    Plane.prototype = {

        constructor : Plane,

        /**
         * Distance from given point to plane
         * @param  {qtek.math.Vector3} point
         * @return {number}
         */
        distanceToPoint : function(point) {
            return vec3.dot(point._array, this.normal._array) - this.distance;
        },

        /**
         * Calculate the projection on the plane of point
         * @param  {qtek.math.Vector3} point
         * @param  {qtek.math.Vector3} out
         * @return {qtek.math.Vector3}
         */
        projectPoint : function(point, out) {
            if (!out) {
                out = new Vector3();
            }
            var d = this.distanceToPoint(point);
            vec3.scaleAndAdd(out._array, point._array, this.normal._array, -d);
            out._dirty = true;
            return out;
        },

        /**
         * Normalize the plane's normal and calculate distance
         */
        normalize : function() {
            var invLen = 1 / vec3.len(this.normal._array);
            vec3.scale(this.normal._array, invLen);
            this.distance *= invLen;
        },

        /**
         * If the plane intersect a frustum
         * @param  {qtek.math.Frustum} Frustum
         * @return {boolean}
         */
        intersectFrustum : function(frustum) {
            // Check if all coords of frustum is on plane all under plane
            var coords = frustum.vertices;
            var normal = this.normal._array;
            var onPlane = vec3.dot(coords[0]._array, normal) > this.distance;
            for (var i = 1; i < 8; i++) {
                if ((vec3.dot(coords[i]._array, normal) > this.distance) != onPlane) {
                    return true;
                } 
            }
        },

        /**
         * Calculate the intersection point between plane and a given line
         * @method
         * @param {qtek.math.Vector3} start start point of line
         * @param {qtek.math.Vector3} end end point of line
         * @param {qtek.math.Vector3} [out]
         * @return {qtek.math.Vector3}
         */
        intersectLine : (function() {
            var rd = vec3.create();
            return function(start, end, out) {
                var d0 = this.distanceToPoint(start);
                var d1 = this.distanceToPoint(end);
                if ((d0 > 0 && d1 > 0) || (d0 < 0 && d1 < 0)) {
                    return null;
                }
                // Ray intersection
                var pn = this.normal._array;
                var d = this.distance;
                var ro = start._array;
                // direction
                vec3.sub(rd, end._array, start._array);
                vec3.normalize(rd, rd);

                var divider = vec3.dot(pn, rd);
                // ray is parallel to the plane
                if (divider == 0) {
                    return null;
                }
                if (!out) {
                    out = new Vector3();
                }
                var t = (vec3.dot(pn, ro) - d) / divider;
                vec3.scaleAndAdd(out._array, ro, rd, -t);
                out._dirty = true;
                return out;
            };
        })(),

        /**
         * Apply an affine transform matrix to plane
         * @method
         * @return {qtek.math.Matrix4}
         */
        applyTransform : (function() {
            var inverseTranspose = mat4.create();
            var normalv4 = vec4.create();
            var pointv4 = vec4.create();
            pointv4[3] = 1;
            return function(m4) {
                m4 = m4._array;
                // Transform point on plane
                vec3.scale(pointv4, this.normal._array, this.distance);
                vec4.transformMat4(pointv4, pointv4, m4);
                this.distance = vec3.dot(pointv4, this.normal._array);
                // Transform plane normal
                mat4.invert(inverseTranspose, m4);
                mat4.transpose(inverseTranspose, inverseTranspose);
                normalv4[3] = 0;
                vec3.copy(normalv4, this.normal._array);
                vec4.transformMat4(normalv4, normalv4, inverseTranspose);
                vec3.copy(this.normal._array, normalv4);
            }
        })(),

        /**
         * Copy from another plane
         * @param  {qtek.math.Vector3} plane
         */
        copy : function(plane) {
            vec3.copy(this.normal._array, plane.normal._array);
            this.normal._dirty = true;
            this.distance = plane.distance;
        },

        /**
         * Clone a new plane
         * @return {qtek.math.Plane}
         */
        clone : function() {
            var plane = new Plane();
            plane.copy(this);
            return plane;
        }
    }

    return Plane;
});
define('qtek/math/Frustum',['require','./Vector3','./BoundingBox','./Plane','glmatrix'],function(require) {

    var Vector3 = require('./Vector3');
    var BoundingBox = require('./BoundingBox');
    var Plane = require('./Plane');
    var glmatrix = require('glmatrix');

    var vec3 = glmatrix.vec3;

    /**
     * @constructor
     * @alias qtek.math.Frustum
     */
    var Frustum = function() {

        /**
         * Eight planes to enclose the frustum
         * @type {qtek.math.Plane[]}
         */
        this.planes = [];

        for (var i = 0; i < 6; i++) {
            this.planes.push(new Plane());
        }

        /**
         * Bounding box of frustum
         * @type {qtek.math.BoundingBox}
         */
        this.boundingBox = new BoundingBox();

        /**
         * Eight vertices of frustum
         * @type {Float32Array[]}
         */
        this.vertices = [];
        for (var i = 0; i < 8; i++) {
            this.vertices[i] = vec3.fromValues(0, 0, 0);
        }
    };

    Frustum.prototype = {

        // http://web.archive.org/web/20120531231005/http://crazyjoke.free.fr/doc/3D/plane%20extraction.pdf
        /**
         * Set frustum from a projection matrix
         * @param {qtek.math.Matrix4} projectionMatrix
         */
        setFromProjection : function(projectionMatrix) {

            var planes = this.planes;
            var m = projectionMatrix._array;
            var m0 = m[0], m1 = m[1], m2 = m[2], m3 = m[3];
            var m4 = m[4], m5 = m[5], m6 = m[6], m7 = m[7];
            var m8 = m[8], m9 = m[9], m10 = m[10], m11 = m[11];
            var m12 = m[12], m13 = m[13], m14 = m[14], m15 = m[15];

            // Update planes
            vec3.set(planes[0].normal._array, m3 - m0, m7 - m4, m11 - m8);
            planes[0].distance = -(m15 - m12);
            planes[0].normalize();

            vec3.set(planes[1].normal._array, m3 + m0, m7 + m4, m11 + m8);
            planes[1].distance = -(m15 + m12);
            planes[1].normalize();
            
            vec3.set(planes[2].normal._array, m3 + m1, m7 + m5, m11 + m9);
            planes[2].distance = -(m15 + m13);
            planes[2].normalize();
            
            vec3.set(planes[3].normal._array, m3 - m1, m7 - m5, m11 - m9);
            planes[3].distance = -(m15 - m13);
            planes[3].normalize();
            
            vec3.set(planes[4].normal._array, m3 - m2, m7 - m6, m11 - m10);
            planes[4].distance = -(m15 - m14);
            planes[4].normalize();
            
            vec3.set(planes[5].normal._array, m3 + m2, m7 + m6, m11 + m10);
            planes[5].distance = -(m15 + m14);
            planes[5].normalize();

            // Perspective projection
            if (m15 === 0)  {
                var aspect = m5 / m0;
                var zNear = -m14 / (m10 - 1);
                var zFar = -m14 / (m10 + 1);
                var farY = -zFar / m5;
                var nearY = -zNear / m5;
                // Update bounding box
                this.boundingBox.min.set(-farY * aspect, -farY, zFar);
                this.boundingBox.max.set(farY * aspect, farY, zNear);
                // update vertices
                var vertices = this.vertices;
                //--- min z
                // min x
                vec3.set(vertices[0], -farY * aspect, -farY, zFar);
                vec3.set(vertices[1], -farY * aspect, farY, zFar);
                // max x
                vec3.set(vertices[2], farY * aspect, -farY, zFar);
                vec3.set(vertices[3], farY * aspect, farY, zFar);
                //-- max z
                vec3.set(vertices[4], -nearY * aspect, -nearY, zNear);
                vec3.set(vertices[5], -nearY * aspect, nearY, zNear);
                vec3.set(vertices[6], nearY * aspect, -nearY, zNear);
                vec3.set(vertices[7], nearY * aspect, nearY, zNear);
            } else { // Orthographic projection
                var left = (-1 - m12) / m0;
                var right = (1 - m12) / m0;
                var top = (1 - m13) / m5;
                var bottom = (-1 - m13) / m5;
                var near = (-1 - m14) / m10;
                var far = (1 - m14) / m10;

                this.boundingBox.min.set(left, bottom, far);
                this.boundingBox.max.set(right, top, near);
                // Copy the vertices from bounding box directly
                for (var i = 0; i < 8; i++) {
                    vec3.copy(this.vertices[i], this.boundingBox.vertices[i]);
                }
            }
        },

        /**
         * Apply a affine transform matrix and set to the given bounding box
         * @method
         * @param {qtek.math.BoundingBox}
         * @param {qtek.math.Matrix4}
         * @return {qtek.math.BoundingBox}
         */
        getTransformedBoundingBox : (function() {
            
            var tmpVec3 = vec3.create();

            return function(bbox, matrix) {
                var vertices = this.vertices;

                var m4 = matrix._array;
                var _min = bbox.min._array;
                var _max = bbox.max._array;
                var v = vertices[0];
                vec3.transformMat4(tmpVec3, v, m4);
                vec3.copy(_min, tmpVec3);
                vec3.copy(_max, tmpVec3);

                for (var i = 1; i < 8; i++) {
                    v = vertices[i];
                    vec3.transformMat4(tmpVec3, v, m4);

                    _min[0] = Math.min(tmpVec3[0], _min[0]);
                    _min[1] = Math.min(tmpVec3[1], _min[1]);
                    _min[2] = Math.min(tmpVec3[2], _min[2]);

                    _max[0] = Math.max(tmpVec3[0], _max[0]);
                    _max[1] = Math.max(tmpVec3[1], _max[1]);
                    _max[2] = Math.max(tmpVec3[2], _max[2]);
                }

                bbox.min._dirty = true;
                bbox.max._dirty = true;

                return bbox;
            };
        }) ()
    }
    return Frustum;
});
define('qtek/math/Ray',['require','../core/Base','./Vector3','glmatrix'],function(require) {

    var Base = require('../core/Base');
    var Vector3 = require('./Vector3');
    var glMatrix = require('glmatrix');
    var vec3 = glMatrix.vec3;

    /**
     * @constructor
     * @alias qtek.math.Ray
     * @param {qtek.math.Vector3} [origin]
     * @param {qtek.math.Vector3} [direction]
     */
    var Ray = function(origin, direction) {
        /**
         * @type {qtek.math.Vector3}
         */
        this.origin = origin || new Vector3();
        /**
         * @type {qtek.math.Vector3}
         */
        this.direction = direction || new Vector3();
    }
    Ray.prototype = {
        
        constructor : Ray,

        // http://www.siggraph.org/education/materials/HyperGraph/raytrace/rayplane_intersection.htm
        /**
         * Calculate intersection point between ray and a give plane
         * @param  {qtek.math.Plane} plane
         * @param  {qtek.math.Vector3} [out]
         * @return {qtek.math.Vector3}
         */
        intersectPlane : function(plane, out) {
            var pn = plane.normal._array;
            var d = plane.distance;
            var ro = this.origin._array;
            var rd = this.direction._array;

            var divider = vec3.dot(pn, rd);
            // ray is parallel to the plane
            if (divider == 0) {
                return null;
            }
            if (!out) {
                out = new Vector3();
            }
            var t = (vec3.dot(pn, ro) - d) / divider;
            vec3.scaleAndAdd(out._array, ro, rd, -t);
            out._dirty = true;
            return out;
        },

        /**
         * Mirror the ray against plane
         * @param  {qtek.math.Plane} plane
         */
        mirrorAgainstPlane : function(plane) {
            // Distance to plane
            var d = vec3.dot(plane.normal._array, this.direction._array);
            vec3.scaleAndAdd(this.direction._array, this.direction._array, plane.normal._array, -d * 2);
            this.direction_dirty = true;
        },

        // http://www.graphics.cornell.edu/pubs/1997/MT97.html
        intersectTriangle : function() {
            
        }
    };

    return Ray;
});
define('qtek/Camera',['require','./Node','./math/Matrix4','./math/Frustum','./math/BoundingBox','./math/Ray','glmatrix'],function(require) {

    var Node = require("./Node");
    var Matrix4 = require("./math/Matrix4");
    var Frustum = require("./math/Frustum");
    var BoundingBox = require("./math/BoundingBox");
    var Ray = require("./math/Ray");

    var glMatrix = require('glmatrix');
    var mat4 = glMatrix.mat4;
    var vec3 = glMatrix.vec3;
    var vec4 = glMatrix.vec4;

    /**
     * @constructor qtek.Camera
     */
    var Camera = Node.derive(function() {
        /** @lends qtek.Camera# */
        return {
            /**
             * Camera projection matrix
             * @type {qtek.math.Matrix4}
             */
            projectionMatrix : new Matrix4(),

            /**
             * Inverse of camera projection matrix
             * @type {qtek.math.Matrix4}
             */
            invProjectionMatrix : new Matrix4(),

            /**
             * View matrix, equal to inverse of camera's world matrix
             * @type {qtek.math.Matrix4}
             */
            viewMatrix : new Matrix4(),

            /**
             * Camera frustum in view space
             * @type {qtek.math.Frustum}
             */
            frustum : new Frustum(),

            /**
             * Scene bounding box in view space
             * Used when camera needs to adujst the near and far plane automatically
             * so that the view frustum contains the visible objects as tightly as possible.
             * Notice:
             *  updated after rendering (in the step of frustum culling passingly)
             *  So may be not so accurate, but saves a lot of calculation
             *  
             * @type {qtek.math.BoundingBox}
             */
            //TODO : In case of one camera to multiple scenes
            sceneBoundingBoxLastFrame : new BoundingBox()
        }
    }, function() {
        this.update(true);
    },
    /** @lends qtek.Camera.prototype */
    {
        
        update : function(force) {
            Node.prototype.update.call(this, force);
            mat4.invert(this.viewMatrix._array, this.worldTransform._array);
            
            this.updateProjectionMatrix();
            mat4.invert(this.invProjectionMatrix._array, this.projectionMatrix._array);

            this.frustum.setFromProjection(this.projectionMatrix);
        },
        /**
         * Update projection matrix, called after update
         */
        updateProjectionMatrix : function(){},

        /**
         * Cast a picking ray from camera near plane to far plane
         * @method
         * @param {qtek.math.Vector2} ndc
         * @param {qtek.math.Ray} [out]
         * @return {qtek.math.Ray}
         */
        castRay : (function() {
            var v4 = vec4.create();
            return function(ndc, out) {
                var ray = out !== undefined ? out : new Ray();
                var x = ndc._array[0];
                var y = ndc._array[1];
                vec4.set(v4, x, y, -1, 1);
                vec4.transformMat4(v4, v4, this.invProjectionMatrix._array);
                vec4.transformMat4(v4, v4, this.worldTransform._array);
                vec3.scale(ray.origin._array, v4, 1 / v4[3]);

                vec4.set(v4, x, y, 1, 1);
                vec4.transformMat4(v4, v4, this.invProjectionMatrix._array);
                vec4.transformMat4(v4, v4, this.worldTransform._array);
                vec3.scale(v4, v4, 1 / v4[3]);
                vec3.sub(ray.direction._array, v4, ray.origin._array);

                vec3.normalize(ray.direction._array, ray.direction._array);
                ray.direction._dirty = true;
                ray.origin._dirty = true;
                
                return ray;
            }
        })()
    });

    return Camera;
});
/**
 * http://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14
 */
define('qtek/core/glenum',[],function() {

return {
    /* ClearBufferMask */
    DEPTH_BUFFER_BIT               : 0x00000100,
    STENCIL_BUFFER_BIT             : 0x00000400,
    COLOR_BUFFER_BIT               : 0x00004000,
    
    /* BeginMode */
    POINTS                         : 0x0000,
    LINES                          : 0x0001,
    LINE_LOOP                      : 0x0002,
    LINE_STRIP                     : 0x0003,
    TRIANGLES                      : 0x0004,
    TRIANGLE_STRIP                 : 0x0005,
    TRIANGLE_FAN                   : 0x0006,
    
    /* AlphaFunction (not supported in ES20) */
    /*      NEVER */
    /*      LESS */
    /*      EQUAL */
    /*      LEQUAL */
    /*      GREATER */
    /*      NOTEQUAL */
    /*      GEQUAL */
    /*      ALWAYS */
    
    /* BlendingFactorDest */
    ZERO                           : 0,
    ONE                            : 1,
    SRC_COLOR                      : 0x0300,
    ONE_MINUS_SRC_COLOR            : 0x0301,
    SRC_ALPHA                      : 0x0302,
    ONE_MINUS_SRC_ALPHA            : 0x0303,
    DST_ALPHA                      : 0x0304,
    ONE_MINUS_DST_ALPHA            : 0x0305,
    
    /* BlendingFactorSrc */
    /*      ZERO */
    /*      ONE */
    DST_COLOR                      : 0x0306,
    ONE_MINUS_DST_COLOR            : 0x0307,
    SRC_ALPHA_SATURATE             : 0x0308,
    /*      SRC_ALPHA */
    /*      ONE_MINUS_SRC_ALPHA */
    /*      DST_ALPHA */
    /*      ONE_MINUS_DST_ALPHA */
    
    /* BlendEquationSeparate */
    FUNC_ADD                       : 0x8006,
    BLEND_EQUATION                 : 0x8009,
    BLEND_EQUATION_RGB             : 0x8009, /* same as BLEND_EQUATION */
    BLEND_EQUATION_ALPHA           : 0x883D,
    
    /* BlendSubtract */
    FUNC_SUBTRACT                  : 0x800A,
    FUNC_REVERSE_SUBTRACT          : 0x800B,
    
    /* Separate Blend Functions */
    BLEND_DST_RGB                  : 0x80C8,
    BLEND_SRC_RGB                  : 0x80C9,
    BLEND_DST_ALPHA                : 0x80CA,
    BLEND_SRC_ALPHA                : 0x80CB,
    CONSTANT_COLOR                 : 0x8001,
    ONE_MINUS_CONSTANT_COLOR       : 0x8002,
    CONSTANT_ALPHA                 : 0x8003,
    ONE_MINUS_CONSTANT_ALPHA       : 0x8004,
    BLEND_COLOR                    : 0x8005,
    
    /* Buffer Objects */
    ARRAY_BUFFER                   : 0x8892,
    ELEMENT_ARRAY_BUFFER           : 0x8893,
    ARRAY_BUFFER_BINDING           : 0x8894,
    ELEMENT_ARRAY_BUFFER_BINDING   : 0x8895,
    
    STREAM_DRAW                    : 0x88E0,
    STATIC_DRAW                    : 0x88E4,
    DYNAMIC_DRAW                   : 0x88E8,
    
    BUFFER_SIZE                    : 0x8764,
    BUFFER_USAGE                   : 0x8765,
    
    CURRENT_VERTEX_ATTRIB          : 0x8626,
    
    /* CullFaceMode */
    FRONT                          : 0x0404,
    BACK                           : 0x0405,
    FRONT_AND_BACK                 : 0x0408,
    
    /* DepthFunction */
    /*      NEVER */
    /*      LESS */
    /*      EQUAL */
    /*      LEQUAL */
    /*      GREATER */
    /*      NOTEQUAL */
    /*      GEQUAL */
    /*      ALWAYS */
    
    /* EnableCap */
    /* TEXTURE_2D */
    CULL_FACE                      : 0x0B44,
    BLEND                          : 0x0BE2,
    DITHER                         : 0x0BD0,
    STENCIL_TEST                   : 0x0B90,
    DEPTH_TEST                     : 0x0B71,
    SCISSOR_TEST                   : 0x0C11,
    POLYGON_OFFSET_FILL            : 0x8037,
    SAMPLE_ALPHA_TO_COVERAGE       : 0x809E,
    SAMPLE_COVERAGE                : 0x80A0,
    
    /* ErrorCode */
    NO_ERROR                       : 0,
    INVALID_ENUM                   : 0x0500,
    INVALID_VALUE                  : 0x0501,
    INVALID_OPERATION              : 0x0502,
    OUT_OF_MEMORY                  : 0x0505,
    
    /* FrontFaceDirection */
    CW                             : 0x0900,
    CCW                            : 0x0901,
    
    /* GetPName */
    LINE_WIDTH                     : 0x0B21,
    ALIASED_POINT_SIZE_RANGE       : 0x846D,
    ALIASED_LINE_WIDTH_RANGE       : 0x846E,
    CULL_FACE_MODE                 : 0x0B45,
    FRONT_FACE                     : 0x0B46,
    DEPTH_RANGE                    : 0x0B70,
    DEPTH_WRITEMASK                : 0x0B72,
    DEPTH_CLEAR_VALUE              : 0x0B73,
    DEPTH_FUNC                     : 0x0B74,
    STENCIL_CLEAR_VALUE            : 0x0B91,
    STENCIL_FUNC                   : 0x0B92,
    STENCIL_FAIL                   : 0x0B94,
    STENCIL_PASS_DEPTH_FAIL        : 0x0B95,
    STENCIL_PASS_DEPTH_PASS        : 0x0B96,
    STENCIL_REF                    : 0x0B97,
    STENCIL_VALUE_MASK             : 0x0B93,
    STENCIL_WRITEMASK              : 0x0B98,
    STENCIL_BACK_FUNC              : 0x8800,
    STENCIL_BACK_FAIL              : 0x8801,
    STENCIL_BACK_PASS_DEPTH_FAIL   : 0x8802,
    STENCIL_BACK_PASS_DEPTH_PASS   : 0x8803,
    STENCIL_BACK_REF               : 0x8CA3,
    STENCIL_BACK_VALUE_MASK        : 0x8CA4,
    STENCIL_BACK_WRITEMASK         : 0x8CA5,
    VIEWPORT                       : 0x0BA2,
    SCISSOR_BOX                    : 0x0C10,
    /*      SCISSOR_TEST */
    COLOR_CLEAR_VALUE              : 0x0C22,
    COLOR_WRITEMASK                : 0x0C23,
    UNPACK_ALIGNMENT               : 0x0CF5,
    PACK_ALIGNMENT                 : 0x0D05,
    MAX_TEXTURE_SIZE               : 0x0D33,
    MAX_VIEWPORT_DIMS              : 0x0D3A,
    SUBPIXEL_BITS                  : 0x0D50,
    RED_BITS                       : 0x0D52,
    GREEN_BITS                     : 0x0D53,
    BLUE_BITS                      : 0x0D54,
    ALPHA_BITS                     : 0x0D55,
    DEPTH_BITS                     : 0x0D56,
    STENCIL_BITS                   : 0x0D57,
    POLYGON_OFFSET_UNITS           : 0x2A00,
    /*      POLYGON_OFFSET_FILL */
    POLYGON_OFFSET_FACTOR          : 0x8038,
    TEXTURE_BINDING_2D             : 0x8069,
    SAMPLE_BUFFERS                 : 0x80A8,
    SAMPLES                        : 0x80A9,
    SAMPLE_COVERAGE_VALUE          : 0x80AA,
    SAMPLE_COVERAGE_INVERT         : 0x80AB,
    
    /* GetTextureParameter */
    /*      TEXTURE_MAG_FILTER */
    /*      TEXTURE_MIN_FILTER */
    /*      TEXTURE_WRAP_S */
    /*      TEXTURE_WRAP_T */
    
    COMPRESSED_TEXTURE_FORMATS     : 0x86A3,
    
    /* HintMode */
    DONT_CARE                      : 0x1100,
    FASTEST                        : 0x1101,
    NICEST                         : 0x1102,
    
    /* HintTarget */
    GENERATE_MIPMAP_HINT            : 0x8192,
    
    /* DataType */
    BYTE                           : 0x1400,
    UNSIGNED_BYTE                  : 0x1401,
    SHORT                          : 0x1402,
    UNSIGNED_SHORT                 : 0x1403,
    INT                            : 0x1404,
    UNSIGNED_INT                   : 0x1405,
    FLOAT                          : 0x1406,
    
    /* PixelFormat */
    DEPTH_COMPONENT                : 0x1902,
    ALPHA                          : 0x1906,
    RGB                            : 0x1907,
    RGBA                           : 0x1908,
    LUMINANCE                      : 0x1909,
    LUMINANCE_ALPHA                : 0x190A,
    
    /* PixelType */
    /*      UNSIGNED_BYTE */
    UNSIGNED_SHORT_4_4_4_4         : 0x8033,
    UNSIGNED_SHORT_5_5_5_1         : 0x8034,
    UNSIGNED_SHORT_5_6_5           : 0x8363,
    
    /* Shaders */
    FRAGMENT_SHADER                  : 0x8B30,
    VERTEX_SHADER                    : 0x8B31,
    MAX_VERTEX_ATTRIBS               : 0x8869,
    MAX_VERTEX_UNIFORM_VECTORS       : 0x8DFB,
    MAX_VARYING_VECTORS              : 0x8DFC,
    MAX_COMBINED_TEXTURE_IMAGE_UNITS : 0x8B4D,
    MAX_VERTEX_TEXTURE_IMAGE_UNITS   : 0x8B4C,
    MAX_TEXTURE_IMAGE_UNITS          : 0x8872,
    MAX_FRAGMENT_UNIFORM_VECTORS     : 0x8DFD,
    SHADER_TYPE                      : 0x8B4F,
    DELETE_STATUS                    : 0x8B80,
    LINK_STATUS                      : 0x8B82,
    VALIDATE_STATUS                  : 0x8B83,
    ATTACHED_SHADERS                 : 0x8B85,
    ACTIVE_UNIFORMS                  : 0x8B86,
    ACTIVE_ATTRIBUTES                : 0x8B89,
    SHADING_LANGUAGE_VERSION         : 0x8B8C,
    CURRENT_PROGRAM                  : 0x8B8D,
    
    /* StencilFunction */
    NEVER                          : 0x0200,
    LESS                           : 0x0201,
    EQUAL                          : 0x0202,
    LEQUAL                         : 0x0203,
    GREATER                        : 0x0204,
    NOTEQUAL                       : 0x0205,
    GEQUAL                         : 0x0206,
    ALWAYS                         : 0x0207,
    
    /* StencilOp */
    /*      ZERO */
    KEEP                           : 0x1E00,
    REPLACE                        : 0x1E01,
    INCR                           : 0x1E02,
    DECR                           : 0x1E03,
    INVERT                         : 0x150A,
    INCR_WRAP                      : 0x8507,
    DECR_WRAP                      : 0x8508,
    
    /* StringName */
    VENDOR                         : 0x1F00,
    RENDERER                       : 0x1F01,
    VERSION                        : 0x1F02,
    
    /* TextureMagFilter */
    NEAREST                        : 0x2600,
    LINEAR                         : 0x2601,
    
    /* TextureMinFilter */
    /*      NEAREST */
    /*      LINEAR */
    NEAREST_MIPMAP_NEAREST         : 0x2700,
    LINEAR_MIPMAP_NEAREST          : 0x2701,
    NEAREST_MIPMAP_LINEAR          : 0x2702,
    LINEAR_MIPMAP_LINEAR           : 0x2703,
    
    /* TextureParameterName */
    TEXTURE_MAG_FILTER             : 0x2800,
    TEXTURE_MIN_FILTER             : 0x2801,
    TEXTURE_WRAP_S                 : 0x2802,
    TEXTURE_WRAP_T                 : 0x2803,
    
    /* TextureTarget */
    TEXTURE_2D                     : 0x0DE1,
    TEXTURE                        : 0x1702,
    
    TEXTURE_CUBE_MAP               : 0x8513,
    TEXTURE_BINDING_CUBE_MAP       : 0x8514,
    TEXTURE_CUBE_MAP_POSITIVE_X    : 0x8515,
    TEXTURE_CUBE_MAP_NEGATIVE_X    : 0x8516,
    TEXTURE_CUBE_MAP_POSITIVE_Y    : 0x8517,
    TEXTURE_CUBE_MAP_NEGATIVE_Y    : 0x8518,
    TEXTURE_CUBE_MAP_POSITIVE_Z    : 0x8519,
    TEXTURE_CUBE_MAP_NEGATIVE_Z    : 0x851A,
    MAX_CUBE_MAP_TEXTURE_SIZE      : 0x851C,
    
    /* TextureUnit */
    TEXTURE0                       : 0x84C0,
    TEXTURE1                       : 0x84C1,
    TEXTURE2                       : 0x84C2,
    TEXTURE3                       : 0x84C3,
    TEXTURE4                       : 0x84C4,
    TEXTURE5                       : 0x84C5,
    TEXTURE6                       : 0x84C6,
    TEXTURE7                       : 0x84C7,
    TEXTURE8                       : 0x84C8,
    TEXTURE9                       : 0x84C9,
    TEXTURE10                      : 0x84CA,
    TEXTURE11                      : 0x84CB,
    TEXTURE12                      : 0x84CC,
    TEXTURE13                      : 0x84CD,
    TEXTURE14                      : 0x84CE,
    TEXTURE15                      : 0x84CF,
    TEXTURE16                      : 0x84D0,
    TEXTURE17                      : 0x84D1,
    TEXTURE18                      : 0x84D2,
    TEXTURE19                      : 0x84D3,
    TEXTURE20                      : 0x84D4,
    TEXTURE21                      : 0x84D5,
    TEXTURE22                      : 0x84D6,
    TEXTURE23                      : 0x84D7,
    TEXTURE24                      : 0x84D8,
    TEXTURE25                      : 0x84D9,
    TEXTURE26                      : 0x84DA,
    TEXTURE27                      : 0x84DB,
    TEXTURE28                      : 0x84DC,
    TEXTURE29                      : 0x84DD,
    TEXTURE30                      : 0x84DE,
    TEXTURE31                      : 0x84DF,
    ACTIVE_TEXTURE                 : 0x84E0,
    
    /* TextureWrapMode */
    REPEAT                         : 0x2901,
    CLAMP_TO_EDGE                  : 0x812F,
    MIRRORED_REPEAT                : 0x8370,
    
    /* Uniform Types */
    FLOAT_VEC2                     : 0x8B50,
    FLOAT_VEC3                     : 0x8B51,
    FLOAT_VEC4                     : 0x8B52,
    INT_VEC2                       : 0x8B53,
    INT_VEC3                       : 0x8B54,
    INT_VEC4                       : 0x8B55,
    BOOL                           : 0x8B56,
    BOOL_VEC2                      : 0x8B57,
    BOOL_VEC3                      : 0x8B58,
    BOOL_VEC4                      : 0x8B59,
    FLOAT_MAT2                     : 0x8B5A,
    FLOAT_MAT3                     : 0x8B5B,
    FLOAT_MAT4                     : 0x8B5C,
    SAMPLER_2D                     : 0x8B5E,
    SAMPLER_CUBE                   : 0x8B60,
    
    /* Vertex Arrays */
    VERTEX_ATTRIB_ARRAY_ENABLED        : 0x8622,
    VERTEX_ATTRIB_ARRAY_SIZE           : 0x8623,
    VERTEX_ATTRIB_ARRAY_STRIDE         : 0x8624,
    VERTEX_ATTRIB_ARRAY_TYPE           : 0x8625,
    VERTEX_ATTRIB_ARRAY_NORMALIZED     : 0x886A,
    VERTEX_ATTRIB_ARRAY_POINTER        : 0x8645,
    VERTEX_ATTRIB_ARRAY_BUFFER_BINDING : 0x889F,
    
    /* Shader Source */
    COMPILE_STATUS                 : 0x8B81,
    
    /* Shader Precision-Specified Types */
    LOW_FLOAT                      : 0x8DF0,
    MEDIUM_FLOAT                   : 0x8DF1,
    HIGH_FLOAT                     : 0x8DF2,
    LOW_INT                        : 0x8DF3,
    MEDIUM_INT                     : 0x8DF4,
    HIGH_INT                       : 0x8DF5,
    
    /* Framebuffer Object. */
    FRAMEBUFFER                    : 0x8D40,
    RENDERBUFFER                   : 0x8D41,
    
    RGBA4                          : 0x8056,
    RGB5_A1                        : 0x8057,
    RGB565                         : 0x8D62,
    DEPTH_COMPONENT16              : 0x81A5,
    STENCIL_INDEX                  : 0x1901,
    STENCIL_INDEX8                 : 0x8D48,
    DEPTH_STENCIL                  : 0x84F9,
    
    RENDERBUFFER_WIDTH             : 0x8D42,
    RENDERBUFFER_HEIGHT            : 0x8D43,
    RENDERBUFFER_INTERNAL_FORMAT   : 0x8D44,
    RENDERBUFFER_RED_SIZE          : 0x8D50,
    RENDERBUFFER_GREEN_SIZE        : 0x8D51,
    RENDERBUFFER_BLUE_SIZE         : 0x8D52,
    RENDERBUFFER_ALPHA_SIZE        : 0x8D53,
    RENDERBUFFER_DEPTH_SIZE        : 0x8D54,
    RENDERBUFFER_STENCIL_SIZE      : 0x8D55,
    
    FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE           : 0x8CD0,
    FRAMEBUFFER_ATTACHMENT_OBJECT_NAME           : 0x8CD1,
    FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL         : 0x8CD2,
    FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE : 0x8CD3,
    
    COLOR_ATTACHMENT0              : 0x8CE0,
    DEPTH_ATTACHMENT               : 0x8D00,
    STENCIL_ATTACHMENT             : 0x8D20,
    DEPTH_STENCIL_ATTACHMENT       : 0x821A,
    
    NONE                           : 0,
    
    FRAMEBUFFER_COMPLETE                      : 0x8CD5,
    FRAMEBUFFER_INCOMPLETE_ATTACHMENT         : 0x8CD6,
    FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT : 0x8CD7,
    FRAMEBUFFER_INCOMPLETE_DIMENSIONS         : 0x8CD9,
    FRAMEBUFFER_UNSUPPORTED                   : 0x8CDD,
    
    FRAMEBUFFER_BINDING            : 0x8CA6,
    RENDERBUFFER_BINDING           : 0x8CA7,
    MAX_RENDERBUFFER_SIZE          : 0x84E8,
    
    INVALID_FRAMEBUFFER_OPERATION  : 0x0506,
    
    /* WebGL-specific enums */
    UNPACK_FLIP_Y_WEBGL            : 0x9240,
    UNPACK_PREMULTIPLY_ALPHA_WEBGL : 0x9241,
    CONTEXT_LOST_WEBGL             : 0x9242,
    UNPACK_COLORSPACE_CONVERSION_WEBGL : 0x9243,
    BROWSER_DEFAULT_WEBGL          : 0x9244,
}
});
define('qtek/core/Cache',[],function() {

    var Cache = function() {

        this._contextId = 0;

        this._caches = [];

        this._context = {};
    }

    Cache.prototype = {

        use : function(contextId, documentSchema) {

            if (! this._caches[contextId]) {
                this._caches[contextId] = {};

                if (documentSchema) {
                    this._caches[contextId] = documentSchema();
                }
            }
            this._contextId = contextId;

            this._context = this._caches[contextId];
        },

        put : function(key, value) {
            this._context[key] = value;
        },

        get : function(key) {
            return this._context[key];
        },

        dirty : function(field) {
            field = field || "";
            var key = "__dirty__" + field;
            this.put(key, true)
        },
        
        dirtyAll : function(field) {
            field = field || "";
            var key = "__dirty__" + field;
            for (var i = 0; i < this._caches.length; i++) {
                if (this._caches[i]) {
                    this._caches[i][key] = true;
                }
            }
        },

        fresh : function(field) {
            field = field || "";
            var key = "__dirty__" + field;
            this.put(key, false);
        },

        freshAll : function(field) {
            field = field || "";
            var key = "__dirty__" + field;
            for (var i = 0; i < this._caches.length; i++) {
                if (this._caches[i]) {
                    this._caches[i][key] = false;
                }
            }
        },

        isDirty : function(field) {
            field = field || "";
            var key = "__dirty__" + field;
            return  !this._context.hasOwnProperty(key)
                    || this._context[key] === true
        },

        clearContext : function() {
            this._caches[this._contextId] = {};
            this._context = {};
        },

        deleteContext : function(contextId) {
            this._caches[contextId] = {};
            this._context = {};
        },

        'delete' : function(key) {
            delete this._context[key];
        },

        clearAll : function() {
            this._caches = {};
        },

        getContext : function() {
            return this._context;
        },

        miss : function(key) {
            return ! this._context.hasOwnProperty(key);
        }
    }

    Cache.prototype.constructor = Cache;

    return Cache;

});
define('qtek/Geometry',['require','./core/Base','./core/util','./core/glenum','./core/Cache'],function(require) {
    
    'use strict'

    var Base = require("./core/Base");
    var util = require("./core/util");
    var glenum = require("./core/glenum");
    var Cache = require("./core/Cache");

    // PENDING put the buffer data in attribute ? 
    function Attribute(name, type, size, semantic, isDynamic) {
        this.name = name;
        this.type = type;
        this.size = size;
        if (semantic) {
            this.semantic = semantic;
        }
        if (isDynamic) {
            this._isDynamic = true;
            this.value = [];
        } else {
            this._isDynamic = false;
            this.value = null
        }
    }

    Attribute.prototype.init = function(nVertex) {
        if (!this._isDynamic) {
            if (!this.value || this.value.length != nVertex * this.size) {
                var ArrayConstructor;
                switch(this.type) {
                    case "byte":
                        ArrayConstructor = Int8Array;
                        break;
                    case "ubyte":
                        ArrayConstructor = Uint8Array;
                        break;
                    case "short":
                        ArrayConstructor = Int16Array;
                        break;
                    case "ushort":
                        ArrayConstructor = Uint16Array;
                        break;
                    default:
                        ArrayConstructor = Float32Array;
                        break;
                }
                this.value = new ArrayConstructor(nVertex * this.size);
            }
        } else {
            console.warn('Dynamic geometry not support init method');
        }
    }

    Attribute.prototype.clone = function(copyValue) {
        var ret = new Attribute(this.name, this.type, this.size, this.semantic, this._isDynamic);
        if (copyValue) {
            console.warn('todo');
        }

        return ret;
    }

    function AttributeBuffer(name, type, buffer, size, semantic) {
        this.name = name;
        this.type = type;
        this.buffer = buffer;
        this.size = size;
        this.semantic = semantic;

        // To be set in mesh
        // symbol in the shader
        this.symbol = '';
    }

    function IndicesBuffer(buffer, count) {
        this.buffer = buffer;
        this.count = count;
    }

    function notImplementedWarn() {
        console.warn('Geometry doesn\'t implement this method, use DynamicGeometry or StaticGeometry instead');
    }

    /**
     * @constructor qtek.Geometry
     */
    var Geometry = Base.derive(
    /** @lends qtek.Geometry# */
    {
        /**
         * @type {qtek.math.BoundingBox}
         */
        boundingBox : null,
        
        /**
         * Vertex attributes
         * @type {object}
         */
        attributes : {},

        faces : null,

        /**
         * @type {boolean}
         */
        useFace : true,

        //Max Value of Uint16, i.e. 0xffff
        chunkSize : 65535
        
    }, function() {
        // Use cache
        this._cache = new Cache();

        this._attributeList = Object.keys(this.attributes);
    },
    /** @lends qtek.Geometry.prototype */
    {
        /**
         * Mark attributes in geometry is dirty
         * @method
         */
        dirty : notImplementedWarn,
        /**
         * @method
         * @return {boolean}
         */
        isDirty : notImplementedWarn,
        /**
         * Create a new attribute
         * @method
         * @param {string} name
         * @param {string} type
         * @param {number} size
         * @param {string} [semantic]
         */
        createAttribute: notImplementedWarn,
        /**
         * Remove attribute
         * @method
         * @param {string} name
         */
        removeAttribute: notImplementedWarn,
        /**
         * @method
         * @return {number}
         */
        getVertexNumber : notImplementedWarn,
        /**
         * @method
         * @return {number}
         */
        getFaceNumber : notImplementedWarn,
        /**
         * @method
         * @return {boolean}
         */
        isUseFace : notImplementedWarn,
        /**
         * @method
         * @return {boolean}
         */
        isStatic : notImplementedWarn,

        getEnabledAttributes : notImplementedWarn,
        getBufferChunks : notImplementedWarn,

        /**
         * @method
         */
        generateVertexNormals : notImplementedWarn,
        /**
         * @method
         */
        generateFaceNormals : notImplementedWarn,
        /**
         * @method
         * @return {boolean}
         */
        isUniqueVertex : notImplementedWarn,
        /**
         * @method
         */
        generateUniqueVertex : notImplementedWarn,
        /**
         * @method
         */
        generateTangents : notImplementedWarn,
        /**
         * @method
         */
        generateBarycentric : notImplementedWarn,
        /**
         * @method
         * @param {qtek.math.Matrix4} matrix
         */
        applyTransform : notImplementedWarn,
        /**
         * @method
         * @param {WebGLRenderingContext} gl
         */
        dispose : notImplementedWarn
    });

    Geometry.STATIC_DRAW = glenum.STATIC_DRAW;
    Geometry.DYNAMIC_DRAW = glenum.DYNAMIC_DRAW;
    Geometry.STREAM_DRAW = glenum.STREAM_DRAW;

    Geometry.AttributeBuffer = AttributeBuffer;
    Geometry.IndicesBuffer = IndicesBuffer;
    Geometry.Attribute = Attribute;

    return Geometry
});
/**
 *
 * PENDING: use perfermance hint and remove the array after the data is transfered?
 * static draw & dynamic draw?
 */
define('qtek/DynamicGeometry',['require','./Geometry','./core/util','./math/Vector3','./math/BoundingBox','./core/glenum','glmatrix'],function(require) {

    

    var Geometry = require("./Geometry");
    var util = require("./core/util");
    var Vector3 = require("./math/Vector3");
    var BoundingBox = require("./math/BoundingBox");
    var glenum = require("./core/glenum");
    var glMatrix = require("glmatrix");
    var vec3 = glMatrix.vec3;
    var vec2 = glMatrix.vec2;
    var mat2 = glMatrix.mat2;
    var mat4 = glMatrix.mat4;

    var arrSlice = Array.prototype.slice;

    /**
     * @constructor qtek.DynamicGeometry
     */
    var DynamicGeometry = Geometry.derive(function() {
        /** @lends qtek.DynamicGeometry# */
        return {
            attributes : {
                 position : new Geometry.Attribute('position', 'float', 3, 'POSITION', true),
                 texcoord0 : new Geometry.Attribute('texcoord0', 'float', 2, 'TEXCOORD_0', true),
                 texcoord1 : new Geometry.Attribute('texcoord1', 'float', 2, 'TEXCOORD_1', true),
                 normal : new Geometry.Attribute('normal', 'float', 3, 'NORMAL', true),
                 tangent : new Geometry.Attribute('tangent', 'float', 4, 'TANGENT', true),
                 color : new Geometry.Attribute('color', 'float', 4, 'COLOR', true),
                 // Skinning attributes
                 // Each vertex can be bind to 4 bones, because the 
                 // sum of weights is 1, so the weights is stored in vec3 and the last
                 // can be calculated by 1-w.x-w.y-w.z
                 weight : new Geometry.Attribute('weight', 'float', 3, 'WEIGHT', true),
                 joint : new Geometry.Attribute('joint', 'float', 4, 'JOINT', true),
                 // For wireframe display
                 // http://codeflow.org/entries/2012/aug/02/easy-wireframe-display-with-barycentric-coordinates/
                 barycentric : new Geometry.Attribute('barycentric', 'float', 3, null, true)
            },

            hint : glenum.DYNAMIC_DRAW,

            // Face is list of triangles, each face
            // is an array of the vertex indices of triangle
            
            /**
             * @type {array}
             */
            faces : [],
            
            _isDirty : true,

            _enabledAttributes : null,

            // Typed Array of each geometry chunk
            // [{
            //     attributeArrays:{
            //         position : TypedArray
            //     },
            //     indicesArray : null
            // }]
            _arrayChunks : []
        }
    }, 
    /** @lends qtek.DynamicGeometry.prototype */
    {
        updateBoundingBox : function() {
            if (!this.boundingBox) {
                this.boundingBox = new BoundingBox();
            }
            this.boundingBox.updateFromVertices(this.attributes.position.value);
        },
        // Overwrite the dirty method
        dirty : function(field) {
            if (! field) {
                this.dirty("indices");
                for (var name in this.attributes) {
                    this.dirty(name);
                }
                return;
            }
            this._cache.dirtyAll(field);

            this._isDirty = true;
            this._enabledAttributes = null;
        },

        getVertexNumber : function() {
            return this.attributes.position.value.length;
        },

        getFaceNumber : function() {
            return this.faces.length;
        },

        isUseFace : function() {
            return this.useFace && (this.faces.length > 0);
        },

        isSplitted : function() {
            return this.getVertexNumber() > this.chunkSize;
        },
        
        isStatic : function() {
            return false;
        },

        isDirty : function() {
            return this._isDirty;
        },

        createAttribute: function(name, type, size, semantic) {
            var attrib = new Geometry.Attribute(name, type, size, semantic, true);
            this.attributes[name] = attrib;
            this._attributeList.push(name);
            return attrib;
        },

        removeAttribute: function(name) {
            var idx = this._attributeList.indexOf(name);
            if (idx >= 0) {
                this._attributeList.splice(idx, 1);
                delete this.attributes[name];
                return true;
            }
            return false;
        },

        /**
         * Get enabled attributes map
         * Attribute which has the same vertex number with position is treated as a enabled attribute
         * @return {object}
         */
        getEnabledAttributes : function() {
            // Cache
            if (this._enabledAttributes) {
                return this._enabledAttributes;
            }

            var result = {};
            var nVertex = this.getVertexNumber();

            for (var i = 0; i < this._attributeList.length; i++) {
                var name = this._attributeList[i];
                var attrib = this.attributes[name];
                if (attrib.value.length) {
                    if (attrib.value.length === nVertex) {
                        result[name] = attrib;
                    }
                }
            }

            this._enabledAttributes = result;

            return result;
        },

        _getDirtyAttributes : function() {

            var attributes = this.getEnabledAttributes();
            
            if (this._cache.miss('chunks')) {
                return attributes;
            } else {
                var result = {};
                var noDirtyAttributes = true;
                for (var name in attributes) {
                    var attrib = attributes[name];
                    if (this._cache.isDirty(name)) {
                        result[name] = attributes[name];
                        noDirtyAttributes = false;
                    }
                }
                if (! noDirtyAttributes) {
                    return result;
                }
            }
        },

        getChunkNumber : function() {
            return this._arrayChunks.length;
        },

        getBufferChunks : function(_gl) {

            this._cache.use(_gl.__GLID__);

            if (this._isDirty) {
                var dirtyAttributes = this._getDirtyAttributes();

                var isFacesDirty = this._cache.isDirty('indices');
                isFacesDirty = isFacesDirty && this.isUseFace();
                
                if (dirtyAttributes) {
                    this._updateAttributesAndIndicesArrays(dirtyAttributes, isFacesDirty);
                    this._updateBuffer(_gl, dirtyAttributes, isFacesDirty);

                    for (var name in dirtyAttributes) {
                        this._cache.fresh(name);
                    }
                    this._cache.fresh('indices');
                    this._isDirty = false;
                }
            }
            return this._cache.get("chunks");
        },

        _updateAttributesAndIndicesArrays : function(attributes, isFacesDirty) {

            var self = this
            var nVertex = this.getVertexNumber();
            
            var verticesReorganizedMap = [];
            var reorganizedFaces = [];

            var ArrayConstructors = {};
            for (var name in attributes) {
                // Type can be byte, ubyte, short, ushort, float
                switch(type) {
                    case "byte":
                        ArrayConstructors[name] = Int8Array;
                        break;
                    case "ubyte":
                        ArrayConstructors[name] = Uint8Array;
                        break;
                    case "short":
                        ArrayConstructors[name] = Int16Array;
                        break;
                    case "ushort":
                        ArrayConstructors[name] = Uint16Array;
                        break;
                    default:
                        ArrayConstructors[name] = Float32Array;
                        break;
                }
            }

            var newChunk = function(chunkIdx) {
                if (self._arrayChunks[chunkIdx]) {
                    return self._arrayChunks[chunkIdx];
                }
                var chunk = {
                    attributeArrays : {},
                    indicesArray : null
                };

                for (var name in attributes) {
                    chunk.attributeArrays[name] = null;
                }

                for (var i = 0; i < nVertex; i++) {
                    verticesReorganizedMap[i] = -1;
                }
                
                self._arrayChunks.push(chunk);
                return chunk;
            }

            var attribNameList = Object.keys(attributes);
            // Split large geometry into chunks because index buffer
            // only support uint16 which means each draw call can only
             // have at most 65535 vertex data
            if (nVertex > this.chunkSize && this.isUseFace()) {
                var vertexCursor = 0;
                var chunkIdx = 0;
                var currentChunk;

                var chunkFaceStart = [0];
                var vertexUseCount = [];

                for (i = 0; i < nVertex; i++) {
                    vertexUseCount[i] = -1;
                    verticesReorganizedMap[i] = -1;
                }
                if (isFacesDirty) {
                    for (i = 0; i < this.faces.length; i++) {
                        reorganizedFaces[i] = [0, 0, 0];
                    }
                }

                currentChunk = newChunk(chunkIdx);

                var vertexCount = 0;
                for (var i = 0; i < this.faces.length; i++) {
                    var face = this.faces[i];
                    var reorganizedFace = reorganizedFaces[i];

                    // newChunk
                    if (vertexCount+3 > this.chunkSize) {
                        chunkIdx++;
                        chunkFaceStart[chunkIdx] = i;
                        vertexCount = 0;
                        currentChunk = newChunk(chunkIdx);
                    }

                    for (var f = 0; f < 3; f++) {
                        var ii = face[f];
                        var isNew = verticesReorganizedMap[ii] === -1; 

                        for (var k = 0; k < attribNameList.length; k++) {
                            var name = attribNameList[k];
                            var attribArray = currentChunk.attributeArrays[name];
                            var values = attributes[name].value;
                            var size = attributes[name].size;
                            if (! attribArray) {
                                // Here use array to put data temporary because i can't predict
                                // the size of chunk precisely.
                                attribArray = currentChunk.attributeArrays[name] = [];
                            }
                            if (isNew) {
                                if (size === 1) {
                                    attribArray[vertexCount] = values[ii];
                                }
                                for (var j = 0; j < size; j++) {
                                    attribArray[vertexCount * size + j] = values[ii][j];
                                }
                            }
                        }
                        if (isNew) {
                            verticesReorganizedMap[ii] = vertexCount;
                            reorganizedFace[f] = vertexCount;
                            vertexCount++;
                        } else {
                            reorganizedFace[f] = verticesReorganizedMap[ii];
                        }
                    }
                }
                //Create typedArray from existed array
                for (var c = 0; c < this._arrayChunks.length; c++) {
                    var chunk = this._arrayChunks[c];
                    for (var name in chunk.attributeArrays) {
                        var array = chunk.attributeArrays[name];
                        if (array instanceof Array) {
                            chunk.attributeArrays[name] = new ArrayConstructors[name](array);
                        }
                    }
                }

                if (isFacesDirty) {
                    var chunkStart, chunkEnd, cursor, chunk;
                    for (var c = 0; c < this._arrayChunks.length; c++) {
                        chunkStart = chunkFaceStart[c];
                        chunkEnd = chunkFaceStart[c+1] || this.faces.length;
                        cursor = 0;
                        chunk = this._arrayChunks[c];
                        var indicesArray = chunk.indicesArray;
                        if (! indicesArray) {
                            indicesArray = chunk.indicesArray = new Uint16Array((chunkEnd-chunkStart)*3);
                        }

                        for (var i = chunkStart; i < chunkEnd; i++) {
                            indicesArray[cursor++] = reorganizedFaces[i][0];
                            indicesArray[cursor++] = reorganizedFaces[i][1];
                            indicesArray[cursor++] = reorganizedFaces[i][2];
                        }
                    }
                }
            } else {
                var chunk = newChunk(0);
                // Use faces
                if (isFacesDirty) {
                    var indicesArray = chunk.indicesArray;
                    if (! indicesArray) {
                        indicesArray = chunk.indicesArray = new Uint16Array(this.faces.length*3);
                    }
                    var cursor = 0;
                    for (var i = 0; i < this.faces.length; i++) {
                        indicesArray[cursor++] = this.faces[i][0];
                        indicesArray[cursor++] = this.faces[i][1];
                        indicesArray[cursor++] = this.faces[i][2];
                    }
                }
                for (var name in attributes) {
                    var values = attributes[name].value;
                    var type = attributes[name].type;
                    var size = attributes[name].size;
                    var attribArray = chunk.attributeArrays[name];
                    
                    var arrSize = nVertex * size;
                    if (! attribArray || attribArray.length !== arrSize) {
                        attribArray = new ArrayConstructors[name](arrSize);
                        chunk.attributeArrays[name] = attribArray;
                    }

                    if (size === 1) {
                        for (var i = 0; i < values.length; i++) {
                            attribArray[i] = values[i];
                        }
                    } else {
                        var cursor = 0;
                        for (var i = 0; i < values.length; i++) {
                            for (var j = 0; j < size; j++) {
                                attribArray[cursor++] = values[i][j];
                            }
                        }
                    }
                }
            }
        },

        _updateBuffer : function(_gl, dirtyAttributes, isFacesDirty) {
            var chunks = this._cache.get("chunks");
            var firstUpdate = false;
            if (! chunks) {
                chunks = [];
                // Intialize
                for (var i = 0; i < this._arrayChunks.length; i++) {
                    chunks[i] = {
                        attributeBuffers : [],
                        indicesBuffer : null
                    }
                }
                this._cache.put("chunks", chunks);
                firstUpdate = true;
            }
            for (var cc = 0; cc < this._arrayChunks.length; cc++) {
                var chunk = chunks[cc];
                if (! chunk) {
                    chunk = chunks[cc] = {
                        attributeBuffers : [],
                        indicesBuffer : null
                    }
                }
                var attributeBuffers = chunk.attributeBuffers;
                var indicesBuffer = chunk.indicesBuffer;
                
                var arrayChunk = this._arrayChunks[cc];
                var attributeArrays = arrayChunk.attributeArrays;
                var indicesArray = arrayChunk.indicesArray;

                var count = 0;
                var prevSearchIdx = 0;
                for (var name in dirtyAttributes) {
                    var attribute = dirtyAttributes[name];
                    var type = attribute.type;
                    var semantic = attribute.semantic;
                    var size = attribute.size;

                    var bufferInfo;
                    if (!firstUpdate) {
                        for (var i = prevSearchIdx; i < attributeBuffers.length; i++) {
                            if (attributeBuffers[i].name === name) {
                                bufferInfo = attributeBuffers[i];
                                prevSearchIdx = i + 1;
                                break;
                            }
                        }
                        if (!bufferInfo) {
                            for (var i = prevSearchIdx - 1; i >= 0; i--) {
                                if (attributeBuffers[i].name === name) {
                                    bufferInfo = attributeBuffers[i];
                                    prevSearchIdx = i;
                                    break;
                                }
                            }
                        }
                    }

                    var buffer;
                    if (bufferInfo) {
                        buffer = bufferInfo.buffer
                    } else {
                        buffer = _gl.createBuffer();
                    }
                    //TODO: Use BufferSubData?
                    _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                    _gl.bufferData(_gl.ARRAY_BUFFER, attributeArrays[name], this.hint);

                    attributeBuffers[count++] = new Geometry.AttributeBuffer(name, type, buffer, size, semantic);
                }
                attributeBuffers.length = count;

                if (isFacesDirty) {
                    if (! indicesBuffer) {
                        indicesBuffer = new Geometry.IndicesBuffer(_gl.createBuffer(), indicesArray.length);
                        chunk.indicesBuffer = indicesBuffer;
                    }
                    _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, indicesBuffer.buffer);
                    _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, indicesArray, this.hint);   
                }
            }
        },

        generateVertexNormals : function() {
            var faces = this.faces
            var len = faces.length
            var positions = this.attributes.position.value
            var normals = this.attributes.normal.value
            var normal = vec3.create();

            var v12 = vec3.create(), v23 = vec3.create();

            var difference = positions.length - normals.length;
            for (var i = 0; i < normals.length; i++) {
                vec3.set(normals[i], 0.0, 0.0, 0.0);
            }
            for (var i = normals.length; i < positions.length; i++) {
                //Use array instead of Float32Array
                normals[i] = [0.0, 0.0, 0.0];
            }

            for (var f = 0; f < len; f++) {

                var face = faces[f];
                var i1 = face[0];
                var i2 = face[1];
                var i3 = face[2];
                var p1 = positions[i1];
                var p2 = positions[i2];
                var p3 = positions[i3];

                vec3.sub(v12, p1, p2);
                vec3.sub(v23, p2, p3);
                vec3.cross(normal, v12, v23);
                // Weighted by the triangle area
                vec3.add(normals[i1], normals[i1], normal);
                vec3.add(normals[i2], normals[i2], normal);
                vec3.add(normals[i3], normals[i3], normal);
            }
            for (var i = 0; i < normals.length; i++) {
                vec3.normalize(normals[i], normals[i]);
            }
        },

        generateFaceNormals : function() {
            if (! this.isUniqueVertex()) {
                this.generateUniqueVertex();
            }

            var faces = this.faces;
            var len = faces.length;
            var positions = this.attributes.position.value;
            var normals = this.attributes.normal.value;
            var normal = vec3.create();

            var v12 = vec3.create(), v23 = vec3.create();

            var isCopy = normals.length === positions.length;
            //   p1
            //  /  \
            // p3---p2
            for (var i = 0; i < len; i++) {
                var face = faces[i];
                var i1 = face[0];
                var i2 = face[1];
                var i3 = face[2];
                var p1 = positions[i1];
                var p2 = positions[i2];
                var p3 = positions[i3];

                vec3.sub(v12, p1, p2);
                vec3.sub(v23, p2, p3);
                vec3.cross(normal, v12, v23);

                if (isCopy) {
                    vec3.copy(normals[i1], normal);
                    vec3.copy(normals[i2], normal);
                    vec3.copy(normals[i3], normal);
                } else {
                    normals[i1] = normals[i2] = normals[i3] = arrSlice.call(normal);
                }
            }
        },
        // "Mathmatics for 3D programming and computer graphics, third edition"
        // section 7.8.2
        // http://www.crytek.com/download/Triangle_mesh_tangent_space_calculation.pdf
        generateTangents : function() {
            
            var texcoords = this.attributes.texcoord0.value;
            var positions = this.attributes.position.value;
            var tangents = this.attributes.tangent.value;
            var normals = this.attributes.normal.value;

            var tan1 = [];
            var tan2 = [];
            var nVertex = this.getVertexNumber();
            for (var i = 0; i < nVertex; i++) {
                tan1[i] = [0.0, 0.0, 0.0];
                tan2[i] = [0.0, 0.0, 0.0];
            }

            var sdir = [0.0, 0.0, 0.0];
            var tdir = [0.0, 0.0, 0.0];
            for (var i = 0; i < this.faces.length; i++) {
                var face = this.faces[i],
                    i1 = face[0],
                    i2 = face[1],
                    i3 = face[2],

                    st1 = texcoords[i1],
                    st2 = texcoords[i2],
                    st3 = texcoords[i3],

                    p1 = positions[i1],
                    p2 = positions[i2],
                    p3 = positions[i3];

                var x1 = p2[0] - p1[0],
                    x2 = p3[0] - p1[0],
                    y1 = p2[1] - p1[1],
                    y2 = p3[1] - p1[1],
                    z1 = p2[2] - p1[2],
                    z2 = p3[2] - p1[2];

                var s1 = st2[0] - st1[0],
                    s2 = st3[0] - st1[0],
                    t1 = st2[1] - st1[1],
                    t2 = st3[1] - st1[1];

                var r = 1.0 / (s1 * t2 - t1 * s2);
                sdir[0] = (t2 * x1 - t1 * x2) * r;
                sdir[1] = (t2 * y1 - t1 * y2) * r; 
                sdir[2] = (t2 * z1 - t1 * z2) * r;

                tdir[0] = (s1 * x2 - s2 * x1) * r;
                tdir[1] = (s1 * y2 - s2 * y1) * r;
                tdir[2] = (s1 * z2 - s2 * z1) * r;

                vec3.add(tan1[i1], tan1[i1], sdir);
                vec3.add(tan1[i2], tan1[i2], sdir);
                vec3.add(tan1[i3], tan1[i3], sdir);
                vec3.add(tan2[i1], tan2[i1], tdir);
                vec3.add(tan2[i2], tan2[i2], tdir);
                vec3.add(tan2[i3], tan2[i3], tdir);
            }
            var tmp = [0, 0, 0, 0];
            var nCrossT = [0, 0, 0];
            for (var i = 0; i < nVertex; i++) {
                var n = normals[i];
                var t = tan1[i];

                // Gram-Schmidt orthogonalize
                vec3.scale(tmp, n, vec3.dot(n, t));
                vec3.sub(tmp, t, tmp);
                vec3.normalize(tmp, tmp);
                // Calculate handedness.
                vec3.cross(nCrossT, n, t);
                tmp[3] = vec3.dot(nCrossT, tan2[i]) < 0.0 ? -1.0 : 1.0;
                tangents[i] = tmp.slice();
            }
        },

        isUniqueVertex : function() {
            if (this.isUseFace()) {
                return this.getVertexNumber() === this.faces.length * 3;
            } else {
                return true;
            }
        },

        generateUniqueVertex : function() {

            var vertexUseCount = [];
            // Intialize with empty value, read undefined value from array
            // is slow
            // http://jsperf.com/undefined-array-read
            for (var i = 0; i < this.getVertexNumber(); i++) {
                vertexUseCount[i] = 0;
            }

            var cursor = this.getVertexNumber();
            var attributes = this.getEnabledAttributes();
            var faces = this.faces;

            var attributeNameList = Object.keys(attributes);

            for (var i = 0; i < faces.length; i++) {
                var face = faces[i];
                for (var j = 0; j < 3; j++) {
                    var ii = face[j];
                    if (vertexUseCount[ii] > 0) {
                        for (var a = 0; a < attributeNameList.length; a++) {
                            var name = attributeNameList[a];
                            var array = attributes[name].value;
                            var size = attributes[name].size;
                            if (size === 1) {
                                array.push(array[ii]);
                            } else {
                                array.push(arrSlice.call(array[ii]));
                            }
                        }
                        face[j] = cursor;
                        cursor++;
                    }
                    vertexUseCount[ii]++;
                }
            }

            this.dirty();
        },

        // http://codeflow.org/entries/2012/aug/02/easy-wireframe-display-with-barycentric-coordinates/
        // http://en.wikipedia.org/wiki/Barycentric_coordinate_system_(mathematics)
        generateBarycentric : (function() {
            var a = [1, 0, 0],
                b = [0, 0, 1],
                c = [0, 1, 0];
            return function() {

                if (! this.isUniqueVertex()) {
                    this.generateUniqueVertex();
                }

                var array = this.attributes.barycentric.value;
                // Already existed;
                if (array.length == this.faces.length * 3) {
                    return;
                }
                var i1, i2, i3, face;
                for (var i = 0; i < this.faces.length; i++) {
                    face = this.faces[i];
                    i1 = face[0];
                    i2 = face[1];
                    i3 = face[2];
                    array[i1] = a;
                    array[i2] = b;
                    array[i3] = c;
                }
            }
        })(),

        convertToStatic : function(geometry) {
            this._updateAttributesAndIndicesArrays(this.getEnabledAttributes(), true);

            if (this._arrayChunks.length > 1) {
                console.warn('Large geometry will discard chunks when convert to StaticGeometry');
            }
            else if (this._arrayChunks.length === 0) {
                return geometry;
            }
            var chunk = this._arrayChunks[0];

            var attributes = this.getEnabledAttributes();
            for (var name in attributes) {
                var attrib = attributes[name];
                var geoAttrib = geometry.attributes[name];
                if (!geoAttrib) {
                    geoAttrib = geometry.attributes[name] = {
                        type : attrib.type,
                        size : attrib.size,
                        value : null
                    }
                    if (attrib.semantic) {
                        geoAttrib.semantic = attrib.semantic;
                    }
                }
                geoAttrib.value = chunk.attributeArrays[name];
            }
            geometry.faces = chunk.indicesArray;

            if (this.boundingBox) {
                geometry.boundingBox = new BoundingBox();
                geometry.boundingBox.min.copy(this.boundingBox.min);
                geometry.boundingBox.max.copy(this.boundingBox.max);
            }
            // PENDING : copy buffer ?
            return geometry
        },

        applyTransform : function(matrix) {
            
            if (this.boundingBox) {
                this.boundingBox.applyTransform(matrix);
            }

            var positions = this.attributes.position.value;
            var normals = this.attributes.normal.value;
            var tangents = this.attributes.tangent.value;

            matrix = matrix._array;
            for (var i = 0; i < positions.length; i++) {
                vec3.transformMat4(positions[i], positions[i], matrix);
            }
            // Normal Matrix
            var inverseTransposeMatrix = mat4.create();
            mat4.invert(inverseTransposeMatrix, matrix);
            mat4.transpose(inverseTransposeMatrix, inverseTransposeMatrix);

            for (var i = 0; i < normals.length; i++) {
                vec3.transformMat4(normals[i], normals[i], inverseTransposeMatrix);
            }

            for (var i = 0; i < tangents.length; i++) {
                vec3.transformMat4(tangents[i], tangents[i], inverseTransposeMatrix);
            }
        },

        dispose : function(_gl) {
            this._cache.use(_gl.__GLID__);
            var chunks = this._cache.get('chunks');
            if (chunks) {
                for (var c = 0; c < chunks.length; c++) {
                    var chunk = chunks[c];
                    for (var k = 0; k < chunk.attributeBuffers.length; k++) {
                        var attribs = chunk.attributeBuffers[k];
                        _gl.deleteBuffer(attribs.buffer);
                    }
                }
            }
            this._cache.deleteContext(_gl.__GLID__);
        }
    });
    
    return DynamicGeometry;
});
/**
 * Base class for all textures like compressed texture, texture2d, texturecube
 * TODO mapping
 */
define('qtek/Texture',['require','./core/Base','./core/util','./core/glenum','./core/Cache'],function(require) {

    var Base = require("./core/Base");
    var util = require("./core/util");
    var glenum = require("./core/glenum");
    var Cache = require("./core/Cache");

    /**
     * @constructor qtek.Texture
     */
    var Texture = Base.derive(
    /** @lends qtek.Texture# */
    {
        /**
         * Texture width, only needed when the texture is used as a render target
         * @type {number}
         */
        width : 512,
        /**
         * Texture height, only needed when the texture is used as a render target
         * @type {number}
         */
        height : 512,
        /**
         * Texel data type
         * @type {number}
         */
        type : glenum.UNSIGNED_BYTE,
        /**
         * Format of texel data
         * @type {number}
         */
        format : glenum.RGBA,
        /**
         * @type {number}
         */
        wrapS : glenum.CLAMP_TO_EDGE,
        /**
         * @type {number}
         */
        wrapT : glenum.CLAMP_TO_EDGE,
        /**
         * @type {number}
         */
        minFilter : glenum.LINEAR_MIPMAP_LINEAR,
        /**
         * @type {number}
         */
        magFilter : glenum.LINEAR,
        /**
         * @type {boolean}
         */
        useMipmap : true,

        /**
         * Anisotropic filtering, enabled if value is larger than 1
         * @see http://blog.tojicode.com/2012/03/anisotropic-filtering-in-webgl.html
         * @type {number}
         */
        anisotropic : 1,
        // pixelStorei parameters
        // http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml
        /**
         * @type {boolean}
         */
        flipY : true,
        /**
         * @type {number}
         */
        unpackAlignment : 4,
        /**
         * @type {boolean}
         */
        premultiplyAlpha : false,

        /**
         * Dynamic option for texture like video
         * @type {boolean}
         */
        dynamic : false,

        NPOT : false
    }, function() {
        this._cache = new Cache();
    }, {

        getWebGLTexture : function(_gl) {

            this._cache.use(_gl.__GLID__);

            if (this._cache.miss("webgl_texture")) {
                // In a new gl context, create new texture and set dirty true
                this._cache.put("webgl_texture", _gl.createTexture());
            }
            if (this.dynamic) {
                this.update(_gl);
            }
            else if (this._cache.isDirty()) {
                this.update(_gl);
                this._cache.fresh();
            }

            return this._cache.get("webgl_texture");
        },

        bind : function() {},
        unbind : function() {},
        
        // Overwrite the dirty method
        /**
         * Mark texture is dirty and update in the next frame
         */
        dirty : function() {
            this._cache.dirtyAll();
        },

        update : function(_gl) {},

        // Update the common parameters of texture
        beforeUpdate : function(_gl) {
            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, this.flipY);
            _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);
            _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, this.unpackAlignment);

            this.fallBack();
        },

        fallBack : function() {

            // Use of none-power of two texture
            // http://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences
            
            var isPowerOfTwo = this.isPowerOfTwo();

            if (this.format === glenum.DEPTH_COMPONENT) {
                this.useMipmap = false;
            }

            if (! isPowerOfTwo || ! this.useMipmap) {
                // none-power of two flag
                this.NPOT = true;
                // Save the original value for restore
                this._minFilterOriginal = this.minFilter;
                this._magFilterOriginal = this.magFilter;
                this._wrapSOriginal = this.wrapS;
                this._wrapTOriginal = this.wrapT;

                if (this.minFilter == glenum.NEAREST_MIPMAP_NEAREST ||
                    this.minFilter == glenum.NEAREST_MIPMAP_LINEAR) {
                    this.minFilter = glenum.NEAREST;
                } else if (
                    this.minFilter == glenum.LINEAR_MIPMAP_LINEAR ||
                    this.minFilter == glenum.LINEAR_MIPMAP_NEAREST
                ) {
                    this.minFilter = glenum.LINEAR
                }

                this.wrapS = glenum.CLAMP_TO_EDGE;
                this.wrapT = glenum.CLAMP_TO_EDGE;
            } else {
                if (this._minFilterOriginal) {
                    this.minFilter = this._minFilterOriginal;
                }
                if (this._magFilterOriginal) {
                    this.magFilter = this._magFilterOriginal;
                }
                if (this._wrapSOriginal) {
                    this.wrapS = this._wrapSOriginal;
                }
                if (this._wrapTOriginal) {
                    this.wrapT = this._wrapTOriginal;
                }
            }

        },

        nextHighestPowerOfTwo : function(x) {
            --x;
            for (var i = 1; i < 32; i <<= 1) {
                x = x | x >> i;
            }
            return x + 1;
        },
        /**
         * @param  {WebGLRenderingContext} _gl
         */
        dispose : function(_gl) {
            this._cache.use(_gl.__GLID__);
            if (this._cache.get("webgl_texture")){
                _gl.deleteTexture(this._cache.get("webgl_texture"));
            }
            this._cache.deleteContext(_gl.__GLID__);
        },

        isRenderable : function() {},
        
        isPowerOfTwo : function() {}
    });
    
    /* DataType */
    Texture.BYTE = glenum.BYTE;
    Texture.UNSIGNED_BYTE = glenum.UNSIGNED_BYTE;
    Texture.SHORT = glenum.SHORT;
    Texture.UNSIGNED_SHORT = glenum.UNSIGNED_SHORT;
    Texture.INT = glenum.INT;
    Texture.UNSIGNED_INT = glenum.UNSIGNED_INT;
    Texture.FLOAT = glenum.FLOAT;
    Texture.HALF_FLOAT = 36193;
    
    /* PixelFormat */
    Texture.DEPTH_COMPONENT = glenum.DEPTH_COMPONENT;
    Texture.ALPHA = glenum.ALPHA;
    Texture.RGB = glenum.RGB;
    Texture.RGBA = glenum.RGBA;
    Texture.LUMINANCE = glenum.LUMINANCE;
    Texture.LUMINANCE_ALPHA = glenum.LUMINANCE_ALPHA;

    /* Compressed Texture */
    Texture.COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0;
    Texture.COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1;
    Texture.COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2;
    Texture.COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3;

    /* TextureMagFilter */
    Texture.NEAREST = glenum.NEAREST;
    Texture.LINEAR = glenum.LINEAR;
    
    /* TextureMinFilter */
    /*      NEAREST */
    /*      LINEAR */
    Texture.NEAREST_MIPMAP_NEAREST = glenum.NEAREST_MIPMAP_NEAREST;
    Texture.LINEAR_MIPMAP_NEAREST = glenum.LINEAR_MIPMAP_NEAREST;
    Texture.NEAREST_MIPMAP_LINEAR = glenum.NEAREST_MIPMAP_LINEAR;
    Texture.LINEAR_MIPMAP_LINEAR = glenum.LINEAR_MIPMAP_LINEAR;
    
    /* TextureParameterName */
    Texture.TEXTURE_MAG_FILTER = glenum.TEXTURE_MAG_FILTER;
    Texture.TEXTURE_MIN_FILTER = glenum.TEXTURE_MIN_FILTER;

    /* TextureWrapMode */
    Texture.REPEAT = glenum.REPEAT;
    Texture.CLAMP_TO_EDGE = glenum.CLAMP_TO_EDGE;
    Texture.MIRRORED_REPEAT = glenum.MIRRORED_REPEAT;


    return Texture;
});
define('qtek/core/glinfo',[],function() {
    // http://www.khronos.org/registry/webgl/extensions/
    var EXTENSION_LIST = [
        "OES_texture_float",
        "OES_texture_half_float",
        "OES_texture_float_linear",
        "OES_texture_half_float_linear",
        "OES_standard_derivatives",
        "OES_vertex_array_object",
        "OES_element_index_uint",
        "WEBGL_compressed_texture_s3tc",
        'WEBGL_depth_texture',
        "EXT_texture_filter_anisotropic",
        "WEBGL_draw_buffers"
    ];

    var extensions = {};

    var glinfo = {

        initialize : function(_gl) {

            if (extensions[_gl.__GLID__]) {
                return;
            }
            extensions[_gl.__GLID__] = {};
            // Get webgl extension
            for (var i = 0; i < EXTENSION_LIST.length; i++) {
                var extName = EXTENSION_LIST[i];

                this._createExtension(_gl, extName);
            }
        },

        getExtension : function(_gl, name) {
            var guid = _gl.__GLID__;
            if (extensions[guid]) {
                if (typeof(extensions[guid][name]) == 'undefined') {
                    this._createExtension(_gl, name);
                }
                return extensions[guid][name];
            }
        },

        _createExtension : function(_gl, name) {
            var ext = _gl.getExtension(name);
            if (!ext) {
                ext = _gl.getExtension('MOZ_' + name);
            }
            if (!ext) {
                ext = _gl.getExtension('WEBKIT_' + name);
            }

            extensions[_gl.__GLID__][name] = ext;
        }
    }

    return glinfo;
});
define('qtek/texture/Texture2D',['require','../Texture','../core/glinfo','../core/glenum'],function(require) {

    var Texture = require('../Texture');
    var glinfo = require('../core/glinfo');
    var glenum = require('../core/glenum');

    var Texture2D = Texture.derive(function() {
        return {
            image : null,
            pixels : null,
            mipmaps : []
        }
    }, {
        update : function(_gl) {

            _gl.bindTexture(_gl.TEXTURE_2D, this._cache.get("webgl_texture"));
            
            this.beforeUpdate( _gl);

            var glFormat = this.format;
            var glType = this.type;

            _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, this.wrapS);
            _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, this.wrapT);

            _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, this.magFilter);
            _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, this.minFilter);
            
            var anisotropicExt = glinfo.getExtension(_gl, "EXT_texture_filter_anisotropic");
            if (anisotropicExt && this.anisotropic > 1) {
                _gl.texParameterf(_gl.TEXTURE_2D, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, this.anisotropic);
            }

            // Fallback to float type if browser don't have half float extension
            if (glType === 36193) {
                var halfFloatExt = glinfo.getExtension(_gl, 'OES_texture_half_float');
                if (!halfFloatExt) {
                    glType = glenum.FLOAT;
                }
            }

            if (this.image) {
                _gl.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType, this.image);
            }
            // Can be used as a blank texture when writing render to texture(RTT)
            else {
                if (
                    glFormat <= Texture.COMPRESSED_RGBA_S3TC_DXT5_EXT 
                    && glFormat >= Texture.COMPRESSED_RGB_S3TC_DXT1_EXT
                ) {
                    _gl.compressedTexImage2D(_gl.TEXTURE_2D, 0, glFormat, this.width, this.height, 0, this.pixels);
                } else {
                    _gl.texImage2D(_gl.TEXTURE_2D, 0, glFormat, this.width, this.height, 0, glFormat, glType, this.pixels);
                }
            }
            if (this.useMipmap) {
                if (this.mipmaps.length) {
                    if (this.image) {
                        for (var i = 0; i < this.mipmaps.length; i++) {
                            if (this.mipmaps[i]) {
                                _gl.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat, glType, this.mipmaps[i]);
                            }
                        }
                    } else if (this.pixels) {
                        var width = this.width;
                        var height = this.height;
                        for (var i = 0; i < this.mipmaps.length; i++) {
                            if (this.mipmaps[i]) {
                                if (
                                    glFormat <= Texture.COMPRESSED_RGBA_S3TC_DXT5_EXT
                                    && glFormat >= Texture.COMPRESSED_RGB_S3TC_DXT1_EXT
                                ) {
                                    _gl.compressedTexImage2D(_gl.TEXTURE_2D, 0, glFormat, width, height, 0, this.mipmaps[i]);
                                } else {
                                    _gl.texImage2D(_gl.TEXTURE_2D, i, glFormat, width, height, 0, glFormat, glType, this.mipmaps[i]);
                                }
                            }
                            width /= 2;
                            height /= 2;
                        }
                    }
                } else if (!this.NPOT && !this.mipmaps.length) {
                    _gl.generateMipmap(_gl.TEXTURE_2D);
                }
            }
            
            _gl.bindTexture(_gl.TEXTURE_2D, null);

        },
        generateMipmap : function(_gl) {
            _gl.bindTexture(_gl.TEXTURE_2D, this._cache.get("webgl_texture"));
            _gl.generateMipmap(_gl.TEXTURE_2D);    
        },
        isPowerOfTwo : function() {
            if (this.image) {
                var width = this.image.width;
                var height = this.image.height;   
            } else {
                var width = this.width;
                var height = this.height;
            }
            return (width & (width-1)) === 0
                    && (height & (height-1)) === 0;
        },

        isRenderable : function() {
            if (this.image) {
                return this.image.nodeName === "CANVAS" ||
                        this.image.complete;
            } else {
                return this.width && this.height;
            }
        },
        bind : function(_gl) {
            _gl.bindTexture(_gl.TEXTURE_2D, this.getWebGLTexture(_gl));
        },
        unbind : function(_gl) {
            _gl.bindTexture(_gl.TEXTURE_2D, null);
        },
        load : function(src) {
            var image = new Image();
            var self = this;
            image.onload = function() {
                self.dirty();
                self.trigger("success", self);
                image.onload = null;
            }
            image.onerror = function() {
                self.trigger('error', self);
                image.onerror = null;
            }

            image.src = src;
            this.image = image;
        }
    });

    return Texture2D;
});
define('qtek/texture/TextureCube',['require','../Texture','../core/glinfo','../core/glenum','../core/util'],function(require) {

    var Texture = require('../Texture');
    var glinfo = require('../core/glinfo');
    var glenum = require('../core/glenum');
    var util = require('../core/util');

    var targetMap = {
        'px' : 'TEXTURE_CUBE_MAP_POSITIVE_X',
        'py' : 'TEXTURE_CUBE_MAP_POSITIVE_Y',
        'pz' : 'TEXTURE_CUBE_MAP_POSITIVE_Z',
        'nx' : 'TEXTURE_CUBE_MAP_NEGATIVE_X',
        'ny' : 'TEXTURE_CUBE_MAP_NEGATIVE_Y',
        'nz' : 'TEXTURE_CUBE_MAP_NEGATIVE_Z',
    }

    var TextureCube = Texture.derive(function() {
        return {
            image : {
                px : null,
                nx : null,
                py : null,
                ny : null,
                pz : null,
                nz : null
            },
            pixels : {
                px : null,
                nx : null,
                py : null,
                ny : null,
                pz : null,
                nz : null
            }
       }
    }, {
        update : function(_gl) {

            _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, this._cache.get("webgl_texture"));

            this.beforeUpdate(_gl);

            var glFormat = this.format;
            var glType = this.type;

            _gl.texParameteri(_gl.TEXTURE_CUBE_MAP, _gl.TEXTURE_WRAP_S, this.wrapS);
            _gl.texParameteri(_gl.TEXTURE_CUBE_MAP, _gl.TEXTURE_WRAP_T, this.wrapT);

            _gl.texParameteri(_gl.TEXTURE_CUBE_MAP, _gl.TEXTURE_MAG_FILTER, this.magFilter);
            _gl.texParameteri(_gl.TEXTURE_CUBE_MAP, _gl.TEXTURE_MIN_FILTER, this.minFilter);
            
            var anisotropicExt = glinfo.getExtension(_gl, "EXT_texture_filter_anisotropic");
            if (anisotropicExt && this.anisotropic > 1) {
                _gl.texParameterf(_gl.TEXTURE_CUBE_MAP, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, this.anisotropic);
            }

            // Fallback to float type if browser don't have half float extension
            if (glType === 36193) {
                var halfFloatExt = glinfo.getExtension(_gl, 'OES_texture_half_float');
                if (!halfFloatExt) {
                    glType = glenum.FLOAT;
                }
            }

            for (var target in this.image) {
                var img = this.image[target];
                if (img) {
                    _gl.texImage2D(_gl[targetMap[target]], 0, glFormat, glFormat, glType, img);
                }
                else {
                    _gl.texImage2D(_gl[targetMap[target]], 0, glFormat, this.width, this.height, 0, glFormat, glType, this.pixels[target]);
                }
            }

            if (!this.NPOT && this.useMipmap) {
                _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
            }

            _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
        },
        generateMipmap : function(_gl) {
            _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, this._cache.get("webgl_texture"));
            _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);    
        },
        bind : function(_gl) {

            _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, this.getWebGLTexture(_gl));
        },
        unbind : function(_gl) {
            _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
        },
        // Overwrite the isPowerOfTwo method
        isPowerOfTwo : function() {
            if (this.image.px) {
                return isPowerOfTwo(this.image.px.width)
                        && isPowerOfTwo(this.image.px.height);
            } else {
                return isPowerOfTwo(this.width)
                        && isPowerOfTwo(this.height);
            }

            function isPowerOfTwo(value) {
                return value & (value-1) === 0
            }
        },
        isRenderable : function() {
            if (this.image.px) {
                return isImageRenderable(this.image.px) &&
                       isImageRenderable(this.image.nx) &&
                       isImageRenderable(this.image.py) &&
                       isImageRenderable(this.image.ny) &&
                       isImageRenderable(this.image.pz) &&
                       isImageRenderable(this.image.nz);
            } else {
                return this.width && this.height;
            }
        },
        load : function(imageList) {
            var loading = 0;
            var self = this;
            util.each(imageList, function(src, target){
                var image = new Image();
                image.onload = function() {
                    loading --;
                    if (loading === 0){
                        self.dirty();
                        self.trigger("success", self);
                    }
                    image.onload = null;
                }
                image.onerror = function() {
                    loading --;
                    image.onerror = null;
                }
                
                loading++;
                image.src = src;
                self.image[target] = image;
            });
        }
    });

    function isImageRenderable(image) {
        return image.nodeName === "CANVAS" ||
                image.complete;
    }

    return TextureCube;
});
define('qtek/FrameBuffer',['require','./core/Base','./texture/Texture2D','./texture/TextureCube','./core/glinfo','./core/glenum','./core/Cache'],function(require) {
    
    
    
    var Base = require("./core/Base");
    var Texture2D = require("./texture/Texture2D");
    var TextureCube = require("./texture/TextureCube");
    var glinfo = require('./core/glinfo');
    var glenum = require("./core/glenum");
    var Cache = require("./core/Cache");

    /**
     * constructor qtek.FrameBuffer
     */
    var FrameBuffer = Base.derive(
    /** @lends qtek.FrameBuffer# */
    {
        /**
         * If use depth buffer
         * @type {boolean}
         */
        depthBuffer : true,

        //Save attached texture and target
        _attachedTextures : null,

        _width : 0,
        _height : 0,
        _depthTextureAttached : false,

        _renderBufferWidth : 0,
        _renderBufferHeight : 0,

        _binded : false,
    }, function() {
        // Use cache
        this._cache = new Cache();

        this._attachedTextures = {};
    },
    
    /**@lends qtek.FrameBuffer.prototype. */
    {

        /**
         * Resize framebuffer.
         * It is not recommanded use this methods to change the framebuffer size because the size will still be changed when attaching a new texture
         * @param  {number} width
         * @param  {number} height
         */
        resize : function(width, height) {
            this._width = width;
            this._height = height;
        },

        /**
         * Bind the framebuffer to given renderer before rendering
         * @param  {qtek.Renderer} renderer
         */
        bind : function(renderer) {

            var _gl = renderer.gl;

            if (!this._binded) {
                _gl.bindFramebuffer(_gl.FRAMEBUFFER, this.getFrameBuffer(_gl));
                this._binded = true;
            }

            this._cache.put("viewport", renderer.viewport);
            renderer.setViewport(0, 0, this._width, this._height);
            // Create a new render buffer
            if (this._cache.miss("renderbuffer") && this.depthBuffer && ! this._depthTextureAttached) {
                this._cache.put("renderbuffer", _gl.createRenderbuffer());
            }
            if (! this._depthTextureAttached && this.depthBuffer) {

                var width = this._width;
                var height = this._height;
                var renderbuffer = this._cache.get('renderbuffer');

                if (width !== this._renderBufferWidth
                     || height !== this._renderBufferHeight) {
                    _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
                    _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, width, height);
                    this._renderBufferWidth = width;
                    this._renderBufferHeight = height;
                    _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);                 
                }
                if (! this._cache.get("renderbuffer_attached")) {
                    _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
                    this._cache.put("renderbuffer_attached", true);
                }
            }
        },
        /**
         * Unbind the frame buffer after rendering
         * @param  {qtek.Renderer} renderer
         */
        unbind : function(renderer) {
            var _gl = renderer.gl;
            
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
            this._binded = false;

            this._cache.use(_gl.__GLID__);
            var viewport = this._cache.get("viewport");
            // Reset viewport;
            if (viewport) {
                renderer.setViewport(viewport.x, viewport.y, viewport.width, viewport.height);
            }

            // Because the data of texture is changed over time,
            // Here update the mipmaps of texture each time after rendered;
            for (var attachment in this._attachedTextures) {
                var texture = this._attachedTextures[attachment];
                if (! texture.NPOT && texture.useMipmap) {
                    var target = texture instanceof TextureCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
                    _gl.bindTexture(target, texture.getWebGLTexture(_gl));
                    _gl.generateMipmap(target);
                    _gl.bindTexture(target, null);
                }
            }
        },

        getFrameBuffer : function(_gl) {

            this._cache.use(_gl.__GLID__);

            if (this._cache.miss("framebuffer")) {
                this._cache.put("framebuffer", _gl.createFramebuffer());
            }

            return this._cache.get("framebuffer");
        },

        /**
         * Attach a texture(RTT) to the framebuffer
         * @param  {WebGLRenderingContext} _gl
         * @param  {qtek.Texture} texture
         * @param  {number} [attachment]
         * @param  {number} [target]
         * @param  {number} [mipmapLevel]
         */
        attach : function(_gl, texture, attachment, target, mipmapLevel) {

            if (! texture.width) {
                throw new Error("The texture attached to color buffer is not a valid.");
            }

            if (!this._binded) {
                _gl.bindFramebuffer(_gl.FRAMEBUFFER, this.getFrameBuffer(_gl));
                this._binded = true;
            }

            this._width = texture.width;
            this._height = texture.height;

            // If the depth_texture extension is enabled, developers
            // Can attach a depth texture to the depth buffer
            // http://blog.tojicode.com/2012/07/using-webgldepthtexture.html
            attachment = attachment || _gl.COLOR_ATTACHMENT0;
            target = target || _gl.TEXTURE_2D;
            mipmapLevel = mipmapLevel || 0;
            
            if (attachment === _gl.DEPTH_ATTACHMENT) {

                var extension = glinfo.getExtension(_gl, "WEBGL_depth_texture");

                if (!extension) {
                    console.error(" Depth texture is not supported by the browser ");
                    return;
                }
                if (texture.format !== glenum.DEPTH_COMPONENT) {
                    console.error("The texture attached to depth buffer is not a valid.");
                    return;
                }
                this._cache.put("renderbuffer_attached", false);
                this._depthTextureAttached = true;
            }

            this._attachedTextures[attachment] = texture;

            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, target, texture.getWebGLTexture(_gl), mipmapLevel);
        },

        detach : function() {},
        /**
         * Dispose
         * @param  {WebGLRenderingContext} _gl
         */
        dispose : function(_gl) {
            this._cache.use(_gl.__GLID__);

            if (this._cache.get("renderbuffer"))
                _gl.deleteRenderbuffer(this._cache.get("renderbuffer"));
            if (this._cache.get("framebuffer"))
                _gl.deleteFramebuffer(this._cache.get("framebuffer"));

            this._cache.deleteContext(_gl.__GLID__);
        }
    });

    FrameBuffer.COLOR_ATTACHMENT0 = glenum.COLOR_ATTACHMENT0;
    FrameBuffer.DEPTH_ATTACHMENT = glenum.DEPTH_ATTACHMENT;
    FrameBuffer.STENCIL_ATTACHMENT = glenum.STENCIL_ATTACHMENT;
    FrameBuffer.DEPTH_STENCIL_ATTACHMENT = glenum.DEPTH_STENCIL_ATTACHMENT;

    return FrameBuffer;
});
define('qtek/Joint',['require','./Node','./core/Base'],function(require) {

    var Node = require("./Node");
    var Base = require("./core/Base");
    
    /**
     * @constructor qtek.Joint
     */
    var Joint = Base.derive(
    /** @lends qtek.Joint# */
    {
        // https://github.com/KhronosGroup/glTF/issues/193#issuecomment-29216576
        /**
         * Joint name
         * @type {string}
         */
        name : '',
        /**
         * Index of joint in the skeleton
         * @type {number}
         */
        index : -1,
        /**
         * Index of parent joint index, -1 if it is a root joint
         */
        parentIndex : -1,

        /**
         * Scene node attached to
         * @type {qtek.Node}
         */
        node : null,

        /**
         * Root scene node of the skeleton, which parent node is null or don't have a joint
         * @type {qtek.Node}
         */
        rootNode : null
    }, {
    });

    return Joint;
});
define('qtek/Layer',['require','./core/Base'],function(require) {

    var Base = require('./core/Base');

    var Layer = Base.derive(function() {
        return {
            renderer : null,
            scene : null,
            camera : null,

            picking : null
        }
    }, {
        render : function() {
            if (this.picking) {
                this.picking.update(this.scene, this.camera);
            }
            this.renderer.render(this.scene, this.camera);
        },

        setPicking : function(picking) {
            this.picking = picking;
            if (this.renderer) {
                picking.resize(this.renderer.width, this.renderer.height);
            }
        },

        resize : function(width, height) {
            if (this.renderer) {
                this.renderer.resize(width, height);
            }
            if (this.picking) {
                this.picking.resize(width, height);
            }
        },

        setZ : function(z) {
            this.z = z;
            this.renderer.canvas.style.zIndex = z;
        },

        pick : function(x, y) {
            // Mouse picking
            if (this.picking) {
                return this.picking.pick(x, y);
            }
        }
    });


    return Layer;
} );
/**
 * Mainly do the parse and compile of shader string
 * Support shader code chunk import and export
 * Support shader semantics
 * http://www.nvidia.com/object/using_sas.html
 * https://github.com/KhronosGroup/collada2json/issues/45
 *
 */
define('qtek/Shader',['require','./core/Base','./core/util','./core/Cache','glmatrix'],function(require) {
    
    

    var Base = require("./core/Base");
    var util = require("./core/util");
    var Cache = require("./core/Cache");
    var glMatrix = require("glmatrix");
    var mat2 = glMatrix.mat2;
    var mat3 = glMatrix.mat3;
    var mat4 = glMatrix.mat4;

    var uniformRegex = /uniform\s+(bool|float|int|vec2|vec3|vec4|ivec2|ivec3|ivec4|mat2|mat3|mat4|sampler2D|samplerCube)\s+([\w\,]+)?(\[.*?\])?\s*(:\s*([\S\s]+?))?;/g;
    var attributeRegex = /attribute\s+(float|int|vec2|vec3|vec4)\s+(\w*)\s*(:\s*(\w+))?;/g;
    var defineRegex = /#define\s+(\w+)?(\s+[\w-.]+)?\s*\n/g;

    var uniformTypeMap = {
        "bool" : "1i",
        "int" : "1i",
        "sampler2D" : "t",
        "samplerCube" : "t",
        "float" : "1f",
        "vec2" : "2f",
        "vec3" : "3f",
        "vec4" : "4f",
        "ivec2" : "2i",
        "ivec3" : "3i",
        "ivec4" : "4i",
        "mat2" : "m2",
        "mat3" : "m3",
        "mat4" : "m4"
    }
    var uniformValueConstructor = {
        'bool' : function() {return true;},
        'int' : function() {return 0;},
        'float' : function() {return 0;},
        'sampler2D' : function() {return null;},
        'samplerCube' : function() {return null;},

        'vec2' : function() {return [0, 0];},
        'vec3' : function() {return [0, 0, 0];},
        'vec4' : function() {return [0, 0, 0, 0];},

        'ivec2' : function() {return [0, 0];},
        'ivec3' : function() {return [0, 0, 0];},
        'ivec4' : function() {return [0, 0, 0, 0];},

        'mat2' : function() {return mat2.create();},
        'mat3' : function() {return mat3.create();},
        'mat4' : function() {return mat4.create();},

        'array' : function() {return [];}
    }
    var attribSemantics = [
        'POSITION', 
        'NORMAL',
        'BINORMAL',
        'TANGENT',
        'TEXCOORD',
        'TEXCOORD_0',
        'TEXCOORD_1',
        'COLOR',
        // Skinning
        // https://github.com/KhronosGroup/glTF/blob/master/specification/README.md#semantics
        'JOINT',
        'WEIGHT',
        'SKIN_MATRIX'
    ];
    var matrixSemantics = [
        'WORLD',
        'VIEW',
        'PROJECTION',
        'WORLDVIEW',
        'VIEWPROJECTION',
        'WORLDVIEWPROJECTION',
        'WORLDINVERSE',
        'VIEWINVERSE',
        'PROJECTIONINVERSE',
        'WORLDVIEWINVERSE',
        'VIEWPROJECTIONINVERSE',
        'WORLDVIEWPROJECTIONINVERSE',
        'WORLDTRANSPOSE',
        'VIEWTRANSPOSE',
        'PROJECTIONTRANSPOSE',
        'WORLDVIEWTRANSPOSE',
        'VIEWPROJECTIONTRANSPOSE',
        'WORLDVIEWPROJECTIONTRANSPOSE',
        'WORLDINVERSETRANSPOSE',
        'VIEWINVERSETRANSPOSE',
        'PROJECTIONINVERSETRANSPOSE',
        'WORLDVIEWINVERSETRANSPOSE',
        'VIEWPROJECTIONINVERSETRANSPOSE',
        'WORLDVIEWPROJECTIONINVERSETRANSPOSE'
    ];
    
    // Enable attribute operation is global to all programs
    // Here saved the list of all enabled attribute index 
    // http://www.mjbshaw.com/2013/03/webgl-fixing-invalidoperation.html
    var enabledAttributeList = {};

    var SHADER_STATE_TO_ENABLE = 1;
    var SHADER_STATE_KEEP_ENABLE = 2;
    var SHADER_STATE_PENDING = 3;

    /**
     * @constructor qtek.Shader
     */
    var Shader = Base.derive(function() {
        
        /** @lends qtek.Shader# */
        return {
            /**
             * Vertex shader code
             * @type {string}
             */
            vertex : "",
            
            /**
             * Fragment shader code
             * @type {string}
             */
            fragment : "",


            precision : "mediump",
            // Properties follow will be generated by the program
            attribSemantics : {},
            matrixSemantics : {},
            matrixSemanticKeys : [],

            uniformTemplates : {},
            attributeTemplates : {},

            /**
             * Custom defined values in the vertex shader
             * @type {object}
             */
            vertexDefines : {},
            /**
             * Custom defined values in the vertex shader
             * @type {object}
             */
            fragmentDefines : {},

            // Glue code
            // Defines the each type light number in the scene
            // AMBIENT_LIGHT
            // POINT_LIGHT
            // SPOT_LIGHT
            // AREA_LIGHT
            lightNumber : {},

            _uniformList : [],
            // {
            //  enabled : true
            //  shaderType : "vertex",
            // }
            _textureStatus : {},

            _vertexProcessed : "",
            _fragmentProcessed : "",

            _currentLocationsMap : {}
        }
    }, function() {
        
        this._cache = new Cache();

        this._updateShaderString();
    },
    /** @lends qtek.Shader.prototype */
    {
        /**
         * Set vertex shader code
         * @param {string} str
         */
        setVertex : function(str) {
            this.vertex = str;
            this._updateShaderString();
            this.dirty();
        },

        /**
         * Set fragment shader code
         * @param {string} str
         */
        setFragment : function(str) {
            this.fragment = str;
            this._updateShaderString();
            this.dirty();
        },

        /**
         * Bind shader program
         * Return true or error msg if error happened
         * @param {WebGLRenderingContext} _gl
         */
        bind : function(_gl) {
            this._cache.use(_gl.__GLID__, getCacheSchema);

            this._currentLocationsMap = this._cache.get('locations');

            if (this._cache.isDirty()) {
                this._updateShaderString();
                var errMsg = this._buildProgram(_gl, this._vertexProcessed, this._fragmentProcessed);
                this._cache.fresh();
                
                if (errMsg) {
                    return errMsg;
                }
            }

            _gl.useProgram(this._cache.get("program"));
        },

        /**
         * Mark dirty and update program in next frame
         */
        dirty : function() {
            this._cache.dirtyAll();
            for (var i = 0; i < this._cache._caches.length; i++) {
                if (this._cache._caches[i]) {
                    var context = this._cache._caches[i];
                    context["locations"] = {};
                    context["attriblocations"] = {};
                }
            }
        },

        _updateShaderString : function() {

            if (this.vertex !== this._vertexPrev ||
                this.fragment !== this._fragmentPrev) {

                this._parseImport();
                
                this.attribSemantics = {};
                this.matrixSemantics = {};
                this._textureStatus = {};

                this._parseUniforms();
                this._parseAttributes();
                this._parseDefines();

                this._vertexPrev = this.vertex;
                this._fragmentPrev = this.fragment;
            }
            this._addDefine();
        },

        /**
         * Add a #define micro in shader code
         * @param  {string} shaderType Can be vertex, fragment or both
         * @param  {string} symbol
         * @param  {number} [val]
         */
        define : function(shaderType, symbol, val) {
            val = val !== undefined ? val : null;
            if (shaderType == 'vertex' || shaderType == 'both') {
                if (this.vertexDefines[symbol] !== val) {
                    this.vertexDefines[symbol] = val;
                    // Mark as dirty
                    this.dirty();
                }
            }
            if (shaderType == 'fragment' || shaderType == 'both') {
                if (this.fragmentDefines[symbol] !== val) {
                    this.fragmentDefines[symbol] = val;
                    if (shaderType !== 'both') {
                        this.dirty();
                    }
                }
            }
        },

        /**
         * @param  {string} shaderType Can be vertex, fragment or both
         * @param  {string} symbol
         */
        unDefine : function(shaderType, symbol) {
            if (shaderType == 'vertex' || shaderType == 'both') {
                if (this.isDefined('vertex', symbol)) {
                    delete this.vertexDefines[symbol];
                    // Mark as dirty
                    this.dirty();
                }
            }
            if (shaderType == 'fragment' || shaderType == 'both') {
                if (this.isDefined('fragment', symbol)) {
                    delete this.fragmentDefines[symbol];
                    if (shaderType !== 'both') {
                        this.dirty();
                    }
                }
            }
        },

        /**
         * @param  {string} shaderType Can be vertex, fragment or both
         * @param  {string} symbol
         */
        isDefined : function(shaderType, symbol) {
            switch(shaderType) {
                case "vertex":
                    return this.vertexDefines[symbol] !== undefined;
                case "fragment":
                    return this.fragmentDefines[symbol] !== undefined;
            }
        },
        /**
         * @param  {string} shaderType Can be vertex, fragment or both
         * @param  {string} symbol
         */
        getDefine : function(shaderType, symbol) {
            switch(shaderType) {
                case "vertex":
                    return this.vertexDefines[symbol];
                case "fragment":
                    return this.fragmentDefines[symbol];
            }
        },
        /**
         * Enable a texture, actually it will add a #define micro in the shader code
         * For example, if texture symbol is diffuseMap, it will add a line `#define DIFFUSEMAP_ENABLED` in the shader code
         * @param  {string} symbol
         */
        enableTexture : function(symbol) {
            var status = this._textureStatus[symbol];
            if (status) {
                var isEnabled = status.enabled;
                if (!isEnabled) {
                    status.enabled = true;
                    this.dirty();
                }
            }
        },
        /**
         * Enable all textures used in the shader
         */
        enableTexturesAll : function() {
            for (var symbol in this._textureStatus) {
                this._textureStatus[symbol].enabled = true;
            }

            this.dirty();
        },
        /**
         * Disable a texture, it remove a #define micro in the shader
         * @param  {string} symbol
         */
        disableTexture : function(symbol) {
            var status = this._textureStatus[symbol];
            if (status) {
                var isDisabled = ! status.enabled;
                if (!isDisabled) {
                    status.enabled = false;
                    this.dirty();
                }
            }
        },
        /**
         * Disable all textures used in the shader
         */
        disableTexturesAll : function() {
            for (var symbol in this._textureStatus) {
                this._textureStatus[symbol].enabled = false;
            }

            this.dirty();
        },
        /**
         * @param  {string}  symbol
         * @return {boolean}
         */
        isTextureEnabled : function(symbol) {
            return this._textureStatus[symbol].enabled;
        },

        hasUniform : function(symbol) {
            var location = this._currentLocationsMap[symbol];
            return location !== null && location !== undefined;
        },

        setUniform : function(_gl, type, symbol, value) {
            var locationMap = this._currentLocationsMap;
            var location = locationMap[symbol];
            // Uniform is not existed in the shader
            if (location === null || location === undefined) {
                return false;
            }
            switch (type) {
                case 'm4':
                    // The matrix must be created by glmatrix and can pass it directly.
                    _gl.uniformMatrix4fv(location, false, value);
                    break;
                case '2i':
                    _gl.uniform2i(location, value[0], value[1]);
                    break;
                case '2f':
                    _gl.uniform2f(location, value[0], value[1]);
                    break;
                case '3i':
                    _gl.uniform3i(location, value[0], value[1], value[2]);
                    break;
                case '3f':
                    _gl.uniform3f(location, value[0], value[1], value[2]);
                    break;
                case '4i':
                    _gl.uniform4i(location, value[0], value[1], value[2], value[3]);
                    break;
                case '4f':
                    _gl.uniform4f(location, value[0], value[1], value[2], value[3]);
                    break;
                case '1i':
                    _gl.uniform1i(location, value);
                    break;
                case '1f':
                    _gl.uniform1f(location, value);
                    break;
                case "1fv":
                    _gl.uniform1fv(location, value);
                    break;
                case "1iv":
                    _gl.uniform1iv(location, value);
                    break;
                case '2iv':
                    _gl.uniform2iv(location, value);
                    break;
                case '2fv':
                    _gl.uniform2fv(location, value);
                    break;
                case '3iv':
                    _gl.uniform3iv(location, value);
                    break;
                case '3fv':
                    _gl.uniform3fv(location, value);
                    break;
                case "4iv":
                    _gl.uniform4iv(location, value);
                    break;
                case "4fv":
                    _gl.uniform4fv(location, value);
                    break;
                case 'm2':
                case "m2v":
                    _gl.uniformMatrix2fv(location, false, value);
                    break;
                case 'm3':
                case "m3v":
                    _gl.uniformMatrix3fv(location, false, value);
                    break;
                case 'm4v':
                    if (value instanceof Array) {
                        var array = new Float32Array(value.length * 16);
                        var cursor = 0;
                        for (var i = 0; i < value.length; i++) {
                            var item = value[i];
                            for (var j = 0; j < 16; j++) {
                                array[cursor++] = item[j];
                            }
                        }
                        _gl.uniformMatrix4fv(location, false, array);
                    // Raw value
                    } else if (value instanceof Float32Array) {   // ArrayBufferView
                        _gl.uniformMatrix4fv(location, false, value);
                    }
                    break;
            }
            return true
        },

        setUniformBySemantic : function(_gl, semantic, val) {
            var semanticInfo = this.attribSemantics[semantic];
            if (semanticInfo) {
                return this.setUniform(_gl, semanticInfo.type, semanticInfo.symbol, val);
            }
            return false;
        },

        // Enable the attributes passed in and disable the rest
        // Example Usage:
        // enableAttributes(_gl, ["position", "texcoords"])
        enableAttributes : function(_gl, attribList) {
            
            var program = this._cache.get("program");

            var locationMap = this._cache.get("attriblocations");

            var enabledAttributeListInContext = enabledAttributeList[_gl.__GLID__];
            if (! enabledAttributeListInContext) {
                enabledAttributeListInContext
                    = enabledAttributeList[_gl.__GLID__] 
                    = [];
            }
            var locationList = [];
            for (var i = 0; i < attribList.length; i++) {
                var symbol = attribList[i];
                if (!this.attributeTemplates[symbol]) {
                    locationList[i] = -1;
                    continue;
                }
                var location = locationMap[symbol];
                if (location === undefined) {
                    location = _gl.getAttribLocation(program, symbol);
                    // Attrib location is a number from 0 to ...
                    if (location === -1) {
                        locationList[i] = -1;
                        continue;
                    }
                    locationMap[symbol] = location;
                }
                locationList[i] = location;

                if (!enabledAttributeListInContext[location]) {
                    enabledAttributeListInContext[location] = SHADER_STATE_TO_ENABLE;
                } else {
                    enabledAttributeListInContext[location] = SHADER_STATE_KEEP_ENABLE;
                }
            }

            for (var i = 0; i < enabledAttributeListInContext.length; i++) {
                switch(enabledAttributeListInContext[i]){
                    case SHADER_STATE_TO_ENABLE:
                        _gl.enableVertexAttribArray(i);
                        enabledAttributeListInContext[i] = SHADER_STATE_PENDING;
                        break;
                    case SHADER_STATE_KEEP_ENABLE:
                        enabledAttributeListInContext[i] = SHADER_STATE_PENDING;
                        break;
                    // Expired
                    case SHADER_STATE_PENDING:
                        _gl.disableVertexAttribArray(i);
                        enabledAttributeListInContext[i] = 0;
                        break;
                }
            }

            return locationList;
        },

        _parseImport : function() {

            this._vertexProcessedWithoutDefine = Shader.parseImport(this.vertex);
            this._fragmentProcessedWithoutDefine = Shader.parseImport(this.fragment);

        },

        _addDefine : function() {

            // Add defines
            // VERTEX
            var defineStr = [];
            for (var lightType in this.lightNumber) {
                var count = this.lightNumber[lightType];
                if (count > 0) {
                    defineStr.push("#define "+lightType.toUpperCase()+"_NUMBER "+count);
                }
            }
            for (var symbol in this._textureStatus) {
                var status = this._textureStatus[symbol];
                if (status.enabled) {
                    defineStr.push("#define "+symbol.toUpperCase()+"_ENABLED");
                }
            }
            // Custom Defines
            for (var symbol in this.vertexDefines) {
                var value = this.vertexDefines[symbol];
                if (value === null) {
                    defineStr.push("#define "+symbol);
                }else{
                    defineStr.push("#define "+symbol+" "+value.toString());
                }
            }
            this._vertexProcessed = defineStr.join("\n") + "\n" + this._vertexProcessedWithoutDefine;

            // FRAGMENT
            defineStr = [];
            for (var lightType in this.lightNumber) {
                var count = this.lightNumber[lightType];
                if (count > 0) {
                    defineStr.push("#define "+lightType.toUpperCase()+"_NUMBER "+count);
                }
            }
            for (var symbol in this._textureStatus) {
                var status = this._textureStatus[symbol];
                if (status.enabled) {
                    defineStr.push("#define "+symbol.toUpperCase()+"_ENABLED");
                }
            }
            // Custom Defines
            for (var symbol in this.fragmentDefines) {
                var value = this.fragmentDefines[symbol];
                if (value === null) {
                    defineStr.push("#define "+symbol);
                }else{
                    defineStr.push("#define "+symbol+" "+value.toString());
                }
            }
            var tmp = defineStr.join("\n") + "\n" + this._fragmentProcessedWithoutDefine;
            
            // Add precision
            this._fragmentProcessed = ['precision', this.precision, 'float'].join(' ')+';\n' + tmp;
        },

        _parseUniforms : function() {
            var uniforms = {};
            var self = this;
            var shaderType = "vertex";
            this._uniformList = [];

            this._vertexProcessedWithoutDefine = this._vertexProcessedWithoutDefine.replace(uniformRegex, _uniformParser);
            shaderType = "fragment";
            this._fragmentProcessedWithoutDefine = this._fragmentProcessedWithoutDefine.replace(uniformRegex, _uniformParser);

            self.matrixSemanticKeys = Object.keys(this.matrixSemantics);

            function _uniformParser(str, type, symbol, isArray, semanticWrapper, semantic) {
                if (type && symbol) {
                    var uniformType = uniformTypeMap[type];
                    var isConfigurable = true;
                    if (uniformType) {
                        self._uniformList.push(symbol);
                        if (type === "sampler2D" || type === "samplerCube") {
                            // Texture is default disabled
                            self._textureStatus[symbol] = {
                                enabled : false,
                                shaderType : shaderType
                            };
                        }
                        if (isArray) {
                            uniformType += 'v';
                        }
                        if (semantic) {
                            // This case is only for SKIN_MATRIX
                            // TODO
                            if (attribSemantics.indexOf(semantic) >= 0) {
                                self.attribSemantics[semantic] = {
                                    symbol : symbol,
                                    type : uniformType
                                }
                                isConfigurable = false;
                            }
                            else if (matrixSemantics.indexOf(semantic) >= 0) {
                                var isTranspose = false;
                                var semanticNoTranspose = semantic;
                                if (semantic.match(/TRANSPOSE$/)) {
                                    isTranspose = true;
                                    semanticNoTranspose = semantic.slice(0, -9)
                                }
                                self.matrixSemantics[semantic] = {
                                    symbol : symbol,
                                    type : uniformType,
                                    isTranspose : isTranspose,
                                    semanticNoTranspose : semanticNoTranspose
                                }
                                isConfigurable = false;
                            }
                            else {
                                // The uniform is not configurable, which means it will not appear
                                // in the material uniform properties
                                if (semantic === "unconfigurable") {
                                    isConfigurable = false;
                                }else{
                                    var defaultValueFunc = self._parseDefaultValue(type, semantic);
                                    if (! defaultValueFunc)
                                        throw new Error('Unkown semantic "' + semantic + '"');
                                    else
                                        semantic = "";
                                }
                            }
                        }
                        if (isConfigurable) {
                            uniforms[symbol] = {
                                type : uniformType,
                                value : isArray ? uniformValueConstructor['array'] : (defaultValueFunc || uniformValueConstructor[type]),
                                semantic : semantic || null
                            }
                        }
                    }
                    return ["uniform", type, symbol, isArray].join(" ")+";\n";
                }
            }

            this.uniformTemplates = uniforms;
        },

        _parseDefaultValue : function(type, str) {
            var arrayRegex = /\[\s*(.*)\s*\]/
            if (type === "vec2" ||
                type === "vec3" ||
                type === "vec4") {
                var arrayStr = arrayRegex.exec(str)[1];
                if (arrayStr) {
                    var arr = arrayStr.split(/\s*,\s*/);
                    return function() {
                        return new Float32Array(arr);
                    }
                }else{
                    // Invalid value
                    return;
                }
            }
            else if (type === "bool") {
                return function() {
                    return str.toLowerCase() === "true" ? true : false;
                }
            }
            else if (type === "float") {
                return function() {
                    return parseFloat(str);
                }
            }
        },

        // Create a new uniform instance for material
        createUniforms : function() {
            var uniforms = {};
            
            for (var symbol in this.uniformTemplates){
                var uniformTpl = this.uniformTemplates[symbol];
                uniforms[symbol] = {
                    type : uniformTpl.type,
                    value : uniformTpl.value()
                }
            }
            return uniforms;
        },

        _parseAttributes : function() {
            var attributes = {};
            var self = this;
            this._vertexProcessedWithoutDefine = this._vertexProcessedWithoutDefine.replace(attributeRegex, _attributeParser);

            function _attributeParser(str, type, symbol, semanticWrapper, semantic) {
                if (type && symbol) {
                    var size = 1;
                    switch (type) {
                        case "vec4":
                            size = 4;
                            break;
                        case "vec3":
                            size = 3;
                            break;
                        case "vec2":
                            size = 2;
                            break;
                        case "float":
                            size = 1;
                            break;
                    }

                    attributes[symbol] = {
                        // Force float
                        type : "float",
                        size : size,
                        semantic : semantic || null
                    }

                    if (semantic) {
                        if (attribSemantics.indexOf(semantic) < 0) {
                            throw new Error('Unkown semantic "' + semantic + '"');
                        }else{
                            self.attribSemantics[semantic] = {
                                symbol : symbol,
                                type : type
                            }
                        }
                    }
                }

                return ["attribute", type, symbol].join(" ")+";\n";
            }

            this.attributeTemplates = attributes;
        },

        _parseDefines : function() {
            var self = this;
            var shaderType = 'vertex';
            this._vertexProcessedWithoutDefine = this._vertexProcessedWithoutDefine.replace(defineRegex, _defineParser);
            shaderType = 'fragment';
            this._fragmentProcessedWithoutDefine = this._fragmentProcessedWithoutDefine.replace(defineRegex, _defineParser);

            function _defineParser(str, symbol, value) {
                var defines = shaderType === 'vertex' ? self.vertexDefines : self.fragmentDefines;
                if (!defines[symbol]) { // Haven't been defined by user
                    if (value == 'false') {
                        defines[symbol] = false
                    } else if (value == 'true') {
                        defines[symbol] = true;
                    } else {
                        defines[symbol] = value ? parseFloat(value) : null;
                    }
                }
                return '';
            }
        },
        // Return true or error msg if error happened
        _buildProgram : function(_gl, vertexShaderString, fragmentShaderString) {

            if (this._cache.get("program")) {
                _gl.deleteProgram(this._cache.get("program"));
            }
            var program = _gl.createProgram();

            var vertexShader = _gl.createShader(_gl.VERTEX_SHADER);
            _gl.shaderSource(vertexShader, vertexShaderString);
            _gl.compileShader(vertexShader);

            var fragmentShader = _gl.createShader(_gl.FRAGMENT_SHADER);
            _gl.shaderSource(fragmentShader, fragmentShaderString);
            _gl.compileShader(fragmentShader);

            var msg = this._checkShaderErrorMsg(_gl, vertexShader, vertexShaderString);
            if (msg) {
                return msg;
            }
            msg = this._checkShaderErrorMsg(_gl, fragmentShader, fragmentShaderString);
            if (msg) {
                return msg;
            }

            _gl.attachShader(program, vertexShader);
            _gl.attachShader(program, fragmentShader);
            // Force the position bind to index 0;
            if (this.attribSemantics['POSITION']) {
                _gl.bindAttribLocation(program, 0, this.attribSemantics['POSITION'].symbol);
            }
            _gl.linkProgram(program);

            if (!_gl.getProgramParameter(program, _gl.LINK_STATUS)) {
                return "Could not link program\n" + "VALIDATE_STATUS: " + _gl.getProgramParameter(program, _gl.VALIDATE_STATUS) + ", gl error [" + _gl.getError() + "]";
            }

            // Cache uniform locations
            for (var i = 0; i < this._uniformList.length; i++) {
                var uniformSymbol = this._uniformList[i];
                var locationMap = this._cache.get("locations");
                locationMap[uniformSymbol] = _gl.getUniformLocation(program, uniformSymbol);
            }

            _gl.deleteShader(vertexShader);
            _gl.deleteShader(fragmentShader);

            this._cache.put("program", program);
        },

        // Return true or error msg if error happened
        _checkShaderErrorMsg : function(_gl, shader, shaderString) {
            if (!_gl.getShaderParameter(shader, _gl.COMPILE_STATUS)) {
                return [_gl.getShaderInfoLog(shader), addLineNumbers(shaderString)].join("\n");
            }
        },

        /**
         * Clone a new shader
         * @return {qtek.Shader}
         */
        clone : function() {
            var shader = new Shader({
                vertex : this.vertex,
                fragment : this.fragment,
                vertexDefines : util.clone(this.vertexDefines),
                fragmentDefines : util.clone(this.fragmentDefines)
            });
            for (var name in this._textureStatus) {
                shader._textureStatus[name] = util.clone(this._textureStatus[name]);
            }
            return shader;
        },
        /**
         * @param  {WebGLRenderingContext} _gl
         */
        dispose : function(_gl) {
            this._cache.use(_gl.__GLID__);
            if (program) {
                var program = this._cache.get('program');
            }
            _gl.deleteProgram(program);
            this._cache.deleteContext(_gl.__GLID__);
            this._locations = {};
        }
    });
    
    function getCacheSchema() {
        return {
            "locations" : {},
            "attriblocations" : {}
        }
    }

    // some util functions
    function addLineNumbers(string) {
        var chunks = string.split("\n");
        for (var i = 0, il = chunks.length; i < il; i ++) {
            // Chrome reports shader errors on lines
            // starting counting from 1
            chunks[i] = (i + 1) + ": " + chunks[i];
        }
        return chunks.join("\n");
    }

    var importRegex = /(@import)\s*([0-9a-zA-Z_\-\.]*)/g;
    Shader.parseImport = function(shaderStr) {
        shaderStr = shaderStr.replace(importRegex, function(str, importSymbol, importName) {
            if (_source[importName]) {
                // Recursively parse
                return Shader.parseImport(_source[importName]);
            } else {
                console.warn('Shader chunk "' + importName + '" not existed in library');
                return '';
            }
        })
        return shaderStr;
    }

    var exportRegex = /(@export)\s*([0-9a-zA-Z_\-\.]*)\s*\n([\s\S]*?)@end/g;

    /**
     * Import shader source
     * @param  {string} shaderStr
     * @memberOf qtek.Shader
     */
    Shader['import'] = function(shaderStr) {
        shaderStr.replace(exportRegex, function(str, exportSymbol, exportName, code) {
            _source[exportName] = code;
            return code;
        })
    }

    // Library to store all the loaded shader strings
    var _source = {};

    /**
     * Get shader source
     * @param  {string} name
     * @return {string}
     * @memberOf qtek.Shader
     */
    Shader.source = function(name) {
        var shaderStr = _source[name];
        if (! shaderStr) {
            console.warn('Shader "' + name + '" not existed in library');
            return;
        }
        return shaderStr;
    }

    return Shader;
});
define('qtek/light/light.essl',[],function () { return '@export buildin.header.directional_light\nuniform vec3 directionalLightDirection[ DIRECTIONAL_LIGHT_NUMBER ] : unconfigurable;\nuniform vec3 directionalLightColor[ DIRECTIONAL_LIGHT_NUMBER ] : unconfigurable;\n@end\n\n@export buildin.header.ambient_light\nuniform vec3 ambientLightColor[ AMBIENT_LIGHT_NUMBER ] : unconfigurable;\n@end\n\n@export buildin.header.point_light\nuniform vec3 pointLightPosition[ POINT_LIGHT_NUMBER ] : unconfigurable;\nuniform float pointLightRange[ POINT_LIGHT_NUMBER ] : unconfigurable;\nuniform vec3 pointLightColor[ POINT_LIGHT_NUMBER ] : unconfigurable;\n@end\n\n@export buildin.header.spot_light\nuniform vec3 spotLightPosition[SPOT_LIGHT_NUMBER] : unconfigurable;\nuniform vec3 spotLightDirection[SPOT_LIGHT_NUMBER] : unconfigurable;\nuniform float spotLightRange[SPOT_LIGHT_NUMBER] : unconfigurable;\nuniform float spotLightUmbraAngleCosine[SPOT_LIGHT_NUMBER] : unconfigurable;\nuniform float spotLightPenumbraAngleCosine[SPOT_LIGHT_NUMBER] : unconfigurable;\nuniform float spotLightFalloffFactor[SPOT_LIGHT_NUMBER] : unconfigurable;\nuniform vec3 spotLightColor[SPOT_LIGHT_NUMBER] : unconfigurable;\n@end';});

define('qtek/Light',['require','./Node','./Shader','./light/light.essl'],function(require){

    var Node = require("./Node");
    var Shader = require("./Shader");

    /**
     * constructor qtek.Light
     */
    var Light = Node.derive(function(){
        /** @lends qtek.Light# */
        return {
            /**
             * Light RGB color
             * @type {number[]}
             */
            color : [1, 1, 1],

            /**
             * Light intensity
             * @type {number}
             */
            intensity : 1.0,
            
            // Config for shadow map
            /**
             * If light cast shadow
             * @type {boolean}
             */
            castShadow : true,

            /**
             * Shadow map size
             * @type {number}
             */
            shadowResolution : 512
        }
    }, {
        clone: function() {
            var light = Node.prototype.clone.call(this);
            light.color = Array.prototype.slice.call(this.color);
            light.intensity = this.intensity;
            light.castShadow = this.castShadow;
            light.shadowResolution = this.shadowResolution;

            return light;
        }
    });

    Shader['import'](require('./light/light.essl'));

    return Light;
});
define('qtek/Material',['require','./core/Base','./Shader','./core/util','./core/glenum','./Texture','./texture/Texture2D','./texture/TextureCube'],function(require) {

    var Base = require("./core/Base");
    var Shader = require("./Shader");
    var util = require("./core/util");
    var glenum = require("./core/glenum");
    var Texture = require('./Texture');
    var Texture2D = require('./texture/Texture2D');
    var TextureCube = require('./texture/TextureCube');

    /**
     * constructor qtek.Material
     */
    var Material = Base.derive(
    /** @lends qtek.Material# */
    {
        /**
         * @type {string}
         */
        name : '',
        
        /**
         * @type {object}
         */
        uniforms : null,

        /**
         * @type {qtek.Shader}
         */
        shader : null,

        /**
         * @type {boolean}
         */
        depthTest : true,

        /**
         * @type {boolean}
         */
        depthMask : true,

        /**
         * @type {boolean}
         */
        transparent : false,
        /**
         * Blend func is a callback function when the material 
         * have custom blending
         * The gl context will be the only argument passed in tho the
         * blend function
         * Detail of blend function in WebGL:
         * http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf
         *
         * Example :
         * function(_gl) {
         *  _gl.blendEquation(_gl.FUNC_ADD);
         *  _gl.blendFunc(_gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA);
         * }
         */
        blend : null,

        // shadowTransparentMap : null

        _enabledUniforms : null,
    }, function() {
        if (!this.name) {
            this.name = 'MATERIAL_' + this.__GUID__;
        }
        if (this.shader) {
            this.attachShader(this.shader);
        }
    },
    /** @lends qtek.Material.prototype */
    {

        bind : function(_gl, prevMaterial) {

            var slot = 0;

            var sameShader = prevMaterial && prevMaterial.shader === this.shader;
            // Set uniforms
            for (var u = 0; u < this._enabledUniforms.length; u++) {
                var symbol = this._enabledUniforms[u];
                var uniform = this.uniforms[symbol];
                // When binding two materials with the same shader
                // Many uniforms will be be set twice even if they have the same value
                // So add a evaluation to see if the uniform is really needed to be set
                // 
                // TODO Small possibility enabledUniforms are not the same
                if (sameShader) {
                    if (prevMaterial.uniforms[symbol].value === uniform.value) {
                        continue;
                    }
                }

                if (uniform.value === undefined) {
                    console.warn('Uniform value "' + symbol + '" is undefined');
                    continue;
                }
                else if (uniform.value === null) {
                    // if (uniform.type == 't') {
                    //     // PENDING
                    //     _gl.bindTexture(_gl.TEXTURE_2D, null);
                    //     _gl.bindTexture(_gl.TEXTURE_CUBE, null);
                    // }
                    continue;
                }
                else if (uniform.value instanceof Array
                    && ! uniform.value.length) {
                    continue;
                }
                else if (uniform.value instanceof Texture) {
                    var res = this.shader.setUniform(_gl, '1i', symbol, slot);
                    if (!res) { // Texture is not enabled
                        continue;
                    }
                    var texture = uniform.value;
                    _gl.activeTexture(_gl.TEXTURE0 + slot);
                    // Maybe texture is not loaded yet;
                    if (texture.isRenderable()) {
                        texture.bind(_gl);
                    } else {
                        // Bind texture to null
                        texture.unbind(_gl);
                    }

                    slot++;
                }
                else if (uniform.value instanceof Array) {
                    if (uniform.value.length === 0) {
                        continue;
                    }
                    // Texture Array
                    var exampleValue = uniform.value[0];

                    if (exampleValue instanceof Texture) {
                        if (!this.shader.hasUniform(symbol)) {
                            continue;
                        }

                        var arr = [];
                        for (var i = 0; i < uniform.value.length; i++) {
                            var texture = uniform.value[i];
                            _gl.activeTexture(_gl.TEXTURE0 + slot);
                            // Maybe texture is not loaded yet;
                            if (texture.isRenderable()) {
                                texture.bind(_gl);
                            } else {
                                texture.unbind(_gl);
                            }

                            arr.push(slot++);
                        }

                        this.shader.setUniform(_gl, '1iv', symbol, arr);
                    } else {
                        this.shader.setUniform(_gl, uniform.type, symbol, uniform.value);
                    }
                }
                else{
                    this.shader.setUniform(_gl, uniform.type, symbol, uniform.value);
                }
            }
        },

        /**
         * @param {string} symbol
         * @param {number|array|qtek.Texture|ArrayBufferView} value
         */
        setUniform : function(symbol, value) {
            var uniform = this.uniforms[symbol];
            if (uniform) {
                uniform.value = value;
            }
        },

        /**
         * @param {object} obj
         */
        setUniforms : function(obj) {
            for (var key in obj) {
                var val = obj[key];
                this.setUniform(key, val);
            }
        },

        /**
         * Enable a uniform
         * It only have effect on the uniform exists in shader. 
         * @param  {string} symbol
         */
        enableUniform : function(symbol) {
            if (this.uniforms[symbol] && !this.isUniformEnabled(symbol)) {
                this._enabledUniforms.push(symbol);
            }
        },

        /**
         * Disable a uniform
         * It will not affect the uniform state in the shader. Because the shader uniforms is parsed from shader code with naive regex. When using micro to disable some uniforms in the shader. It will still try to set these uniforms in each rendering pass. We can disable these uniforms manually if we need this bit performance improvement. Mostly we can simply ignore it.
         * @param  {string} symbol
         */
        disableUniform : function(symbol) {
            var idx = this._enabledUniforms.indexOf(symbol);
            if (idx >= 0) {
                this._enabledUniforms.splice(idx, 1);
            }
        },

        /**
         * @param  {string}  symbol
         * @return {boolean}
         */
        isUniformEnabled : function(symbol) {
            return this._enabledUniforms.indexOf(symbol) >= 0;
        },

        /**
         * Alias of setUniform and setUniforms
         * @param {object|string} symbol
         * @param {number|array|qtek.Texture|ArrayBufferView} [value]
         */
        set : function(symbol, value) {
            if (typeof(symbol) === 'object') {
                for (var key in symbol) {
                    var val = symbol[key];
                    this.set(key, val);
                }
            } else {
                var uniform = this.uniforms[symbol];
                if (uniform) {
                    uniform.value = value;
                }
            }
        },
        /**
         * Get uniform value
         * @param  {string} symbol
         * @return {number|array|qtek.Texture|ArrayBufferView}
         */
        get : function(symbol) {
            var uniform = this.uniforms[symbol];
            if (uniform) {
                return uniform.value;
            } else {
                // console.warn('Uniform '+symbol+' not exist');
            }
        },
        /**
         * Attach a shader instance
         * @param  {qtek.Shader} shader
         * @param  {boolean} keepUniform If try to keep uniform value
         */
        attachShader : function(shader, keepUniform) {
            var originalUniforms = this.uniforms;
            this.uniforms = shader.createUniforms();
            this.shader = shader;
            
            this._enabledUniforms = Object.keys(this.uniforms);

            if (keepUniform) {
                for (var symbol in originalUniforms) {
                    if (this.uniforms[symbol]) {
                        this.uniforms[symbol].value = originalUniforms[symbol].value;
                    }
                }
            }
        },

        /**
         * Detach a shader instance
         */
        detachShader : function() {
            this.shader = null;
            this.uniforms = {};
        },

        dispose : function() {
            //TODO
        }
    });

    return Material;
});
/**
 * StaticGeometry can not be changed once they've been setup
 */
define('qtek/StaticGeometry',['require','./Geometry','./core/util','./math/BoundingBox','glmatrix','./core/glenum'],function(require) {

    

    var Geometry = require("./Geometry");
    var util = require("./core/util");
    var BoundingBox = require("./math/BoundingBox");
    var glMatrix = require("glmatrix");
    var glenum = require("./core/glenum");
    var mat4 = glMatrix.mat4;
    var vec3 = glMatrix.vec3;

    /**
     * @constructor qtek.StaticGeometry
     * @extends qtek.Geometry
     */
    var StaticGeometry = Geometry.derive(function() {
        /** @lends qtek.StaticGeometry# */
        return {
            attributes : {
                 position : new Geometry.Attribute('position', 'float', 3, 'POSITION', false),
                 texcoord0 : new Geometry.Attribute('texcoord0', 'float', 2, 'TEXCOORD_0', false),
                 texcoord1 : new Geometry.Attribute('texcoord1', 'float', 2, 'TEXCOORD_1', false),
                 normal : new Geometry.Attribute('normal', 'float', 3, 'NORMAL', false),
                 tangent : new Geometry.Attribute('tangent', 'float', 4, 'TANGENT', false),
                 color : new Geometry.Attribute('color', 'float', 4, 'COLOR', false),
                 // Skinning attributes
                 // Each vertex can be bind to 4 bones, because the 
                 // sum of weights is 1, so the weights is stored in vec3 and the last
                 // can be calculated by 1-w.x-w.y-w.z
                 weight : new Geometry.Attribute('weight', 'float', 3, 'WEIGHT', false),
                 joint : new Geometry.Attribute('joint', 'float', 4, 'JOINT', false),
                 // For wireframe display
                 // http://codeflow.org/entries/2012/aug/02/easy-wireframe-display-with-barycentric-coordinates/
                 barycentric : new Geometry.Attribute('barycentric', 'float', 3, null, false),
            },

            hint : glenum.STATIC_DRAW,

            /**
             * @type {Uint16Array}
             */
            faces: null,

            _isDirty : true,

            _normalType : 'vertex',

            _enabledAttributes : null
        }
    }, 

    /** @lends qtek.StaticGeometry.prototype */
    {
        dirty : function() {
            this._cache.dirtyAll("chunks");
            this._isDirty = true;
            this._enabledAttributes = null;
        },
        
        getVertexNumber : function() {
            if (!this.attributes.position.value) {
                return 0;
            }
            return this.attributes.position.value.length / 3;
        },

        getFaceNumber : function() {
            return this.faces.length / 3;
        },
        
        isUseFace : function() {
            return this.useFace && (this.faces != null);
        },

        isStatic : function() {
            return true;
        },

        isDirty : function() {
            return this._isDirty;
        },
        
        createAttribute: function(name, type, size, semantic) {
            var attrib = new Geometry.Attribute(name, type, size, semantic, false);
            this.attributes[name] = attrib;
            this._attributeList.push(name);
            return attrib;
        },

        removeAttribute: function(name) {
            var idx = this._attributeList.indexOf(name);
            if (idx >= 0) {
                this._attributeList.splice(idx, 1);
                delete this.attributes[name];
                return true;
            }
            return false;
        },

        /**
         * Get enabled attributes name list
         * Attribute which has the same vertex number with position is treated as a enabled attribute
         * @return {string[]}
         */
        getEnabledAttributes : function() {
            // Cache
            if (this._enabledAttributes) {
                return this._enabledAttributes;
            }

            var result = [];
            var nVertex = this.getVertexNumber();

            for (var i = 0; i < this._attributeList.length; i++) {
                var name = this._attributeList[i];
                var attrib = this.attributes[name];
                if (attrib.value) {
                    if (attrib.value.length === nVertex * attrib.size) {
                        result.push(name);
                    }
                }
            }

            this._enabledAttributes = result;

            return result;
        },

        getBufferChunks : function(_gl) {
            this._cache.use(_gl.__GLID__);
            if (this._cache.isDirty("chunks")) {
                this._updateBuffer(_gl);
                this._cache.fresh("chunks");
                this._isDirty = false;
            }
            return this._cache.get("chunks");
        },
        
        _updateBuffer : function(_gl) {
            var chunks = this._cache.get("chunks");
            var firstUpdate = false;
            if (! chunks) {
                chunks = [];
                // Intialize
                chunks[0] = {
                    attributeBuffers : [],
                    indicesBuffer : null
                }
                this._cache.put("chunks", chunks);
                firstUpdate = true;
            }
            var chunk = chunks[0];
            var attributeBuffers = chunk.attributeBuffers;
            var indicesBuffer = chunk.indicesBuffer;

            var attributeList = this.getEnabledAttributes();
            var prevSearchIdx = 0;
            var count = 0;
            for (var k = 0; k < attributeList.length; k++) {
                var name = attributeList[k];
                var attribute = this.attributes[name];

                var bufferInfo;

                if (!firstUpdate) {
                    // Search for created buffer
                    for (var i = prevSearchIdx; i < attributeBuffers.length; i++) {
                        if (attributeBuffers[i].name === name) {
                            bufferInfo = attributeBuffers[i];
                            prevSearchIdx = i + 1;
                            break;
                        }
                    }
                    if (!bufferInfo) {
                        for (var i = prevSearchIdx - 1; i >= 0; i--) {
                            if (attributeBuffers[i].name === name) {
                                bufferInfo = attributeBuffers[i];
                                prevSearchIdx = i;
                                break;
                            }
                        }
                    }
                }
                var buffer;
                if (bufferInfo) {
                    buffer = bufferInfo.buffer;
                } else {
                    buffer = _gl.createBuffer();
                }
                //TODO: Use BufferSubData?
                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                _gl.bufferData(_gl.ARRAY_BUFFER, attribute.value, this.hint);

                attributeBuffers[count++] = new Geometry.AttributeBuffer(name, attribute.type, buffer, attribute.size, attribute.semantic);
            }
            attributeBuffers.length = count;

            if (! indicesBuffer && this.isUseFace()) {
                indicesBuffer = new Geometry.IndicesBuffer(_gl.createBuffer(), this.faces.length);
                chunk.indicesBuffer = indicesBuffer;
                _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, indicesBuffer.buffer);
                _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, this.faces, this.hint);
            }
        },

        generateVertexNormals : function() {
            console.warn('Static Geometry doesn\'t support normal generate');
        },

        generateFaceNormals : function() {
            console.warn('Static Geometry doesn\'t support normal generate');
        },

        generateTangents : function() {
            var nVertex = this.getVertexNumber();
            if (!this.attributes.tangent.value) {
                this.attributes.tangent.value = new Float32Array(nVertex * 4);
            }
            var texcoords = this.attributes.texcoord0.value;
            var positions = this.attributes.position.value;
            var tangents = this.attributes.tangent.value;
            var normals = this.attributes.normal.value;

            var tan1 = [];
            var tan2 = [];
            for (var i = 0; i < nVertex; i++) {
                tan1[i] = [0.0, 0.0, 0.0];
                tan2[i] = [0.0, 0.0, 0.0];
            }

            var sdir = [0.0, 0.0, 0.0];
            var tdir = [0.0, 0.0, 0.0];
            for (var i = 0; i < this.faces.length;) {
                var i1 = this.faces[i++],
                    i2 = this.faces[i++],
                    i3 = this.faces[i++],

                    st1s = texcoords[i1 * 2],
                    st2s = texcoords[i2 * 2],
                    st3s = texcoords[i3 * 2],
                    st1t = texcoords[i1 * 2 + 1],
                    st2t = texcoords[i2 * 2 + 1],
                    st3t = texcoords[i3 * 2 + 1],

                    p1x = positions[i1 * 3],
                    p2x = positions[i2 * 3],
                    p3x = positions[i3 * 3],
                    p1y = positions[i1 * 3 + 1],
                    p2y = positions[i2 * 3 + 1],
                    p3y = positions[i3 * 3 + 1],
                    p1z = positions[i1 * 3 + 2],
                    p2z = positions[i2 * 3 + 2],
                    p3z = positions[i3 * 3 + 2];

                var x1 = p2x - p1x,
                    x2 = p3x - p1x,
                    y1 = p2y - p1y,
                    y2 = p3y - p1y,
                    z1 = p2z - p1z,
                    z2 = p3z - p1z;

                var s1 = st2s - st1s,
                    s2 = st3s - st1s,
                    t1 = st2t - st1t,
                    t2 = st3t - st1t;

                var r = 1.0 / (s1 * t2 - t1 * s2);
                sdir[0] = (t2 * x1 - t1 * x2) * r;
                sdir[1] = (t2 * y1 - t1 * y2) * r; 
                sdir[2] = (t2 * z1 - t1 * z2) * r;

                tdir[0] = (s1 * x2 - s2 * x1) * r;
                tdir[1] = (s1 * y2 - s2 * y1) * r;
                tdir[2] = (s1 * z2 - s2 * z1) * r;

                vec3.add(tan1[i1], tan1[i1], sdir);
                vec3.add(tan1[i2], tan1[i2], sdir);
                vec3.add(tan1[i3], tan1[i3], sdir);
                vec3.add(tan2[i1], tan2[i1], tdir);
                vec3.add(tan2[i2], tan2[i2], tdir);
                vec3.add(tan2[i3], tan2[i3], tdir);
            }
            var tmp = vec3.create();
            var nCrossT = vec3.create();
            var n = vec3.create();
            for (var i = 0; i < nVertex; i++) {
                n[0] = normals[i * 3];
                n[1] = normals[i * 3 + 1];
                n[2] = normals[i * 3 + 2];
                var t = tan1[i];

                // Gram-Schmidt orthogonalize
                vec3.scale(tmp, n, vec3.dot(n, t));
                vec3.sub(tmp, t, tmp);
                vec3.normalize(tmp, tmp);
                // Calculate handedness.
                vec3.cross(nCrossT, n, t);
                tangents[i * 4] = tmp[0];
                tangents[i * 4 + 1] = tmp[1];
                tangents[i * 4 + 2] = tmp[2];
                tangents[i * 4 + 3] = vec3.dot(nCrossT, tan2[i]) < 0.0 ? -1.0 : 1.0;;
            }
        },

        isUniqueVertex : function() {
            if (this.isUseFace()) {
                return this.getVertexNumber() === this.faces.length;
            } else {
                return true;
            }
        },

        generateUniqueVertex : function() {
            var vertexUseCount = [];

            for (var i = 0, len = this.getVertexNumber(); i < len; i++) {
                vertexUseCount[i] = 0;
            }

            var cursor = this.getVertexNumber();
            var attributes = this.attributes;
            var faces = this.faces;

            var attributeNameList = this.getEnabledAttributes();

            for (var a = 0; a < attributeNameList.length; a++) {
                var name = attributeNameList[a];
                var expandedArray = new Float32Array(this.faces.length * attributes[name].size);
                var len = attributes[name].value.length;
                for (var i = 0; i < len; i++) {
                    expandedArray[i] = attributes[name].value[i];
                }
                attributes[name].value = expandedArray;
            }

            for (var i = 0; i < faces.length; i++) {
                var ii = faces[i];
                if (vertexUseCount[ii] > 0) {
                    for (var a = 0; a < attributeNameList.length; a++) {
                        var name = attributeNameList[a];
                        var array = attributes[name].value;
                        var size = attributes[name].size;

                        for (var k = 0; k < size; k++) {
                            array[cursor * size + k] = array[ii * size + k];
                        }
                    }
                    faces[i] = cursor;
                    cursor++;
                }
                vertexUseCount[ii]++;
            }
        },

        generateBarycentric : function() {

            if (! this.isUniqueVertex()) {
                this.generateUniqueVertex();
            }

            var array = this.attributes.barycentric.value;
            // Already existed;
            if (array && array.length === this.faces.length * 3) {
                return;
            }
            array = this.attributes.barycentric.value = new Float32Array(this.faces.length * 3);
            var i1, i2, i3, face;
            for (var i = 0; i < this.faces.length;) {
                for (var j = 0; j < 3; j++) {
                    var ii = this.faces[i++];
                    array[ii + j] = 1;
                }
            }
        },

        convertToDynamic : function(geometry) {
            var offset = 0;
            var chunk = this._arrayChunks[c];

            for (var i = 0; i < this.faces.length; i+=3) {
                geometry.faces.push(this.face.subarray(i, i + 3));
            }

            var attributes = this.getEnabledAttributes();
            for (var name in attributes) {
                var attrib = attributes[name];
                var geoAttrib = geometry.attributes[name];
                if (!geoAttrib) {
                    geoAttrib = geometry.attributes[name] = {
                        type : attrib.type,
                        size : attrib.size,
                        value : []
                    }
                    if (attrib.semantic) {
                        geoAttrib.semantic = attrib.semantic;
                    }
                }
                for (var i = 0; i < attrib.value.length; i+= attrib.size) {
                    if (attrib.size === 1) {
                        geoAttrib.value.push(attrib.array[i]);
                    } else {
                        geoAttrib.value.push(attrib.subarray(i, i + attrib.size));
                    }
                }
            }

            if (this.boundingBox) {
                geometry.boundingBox = new BoundingBox();
                geometry.boundingBox.min.copy(this.boundingBox.min);
                geometry.boundingBox.max.copy(this.boundingBox.max);
            }
            // PENDING : copy buffer ?
            
            return geometry;
        },

        applyTransform : function(matrix) {

            if (this.boundingBox) {
                this.boundingBox.applyTransform(matrix);
            }

            var positions = this.attributes.position.value;
            var normals = this.attributes.normal.value;
            var tangents = this.attributes.tangent.value;

            matrix = matrix._array;
            // Normal Matrix
            var inverseTransposeMatrix = mat4.create();
            mat4.invert(inverseTransposeMatrix, matrix);
            mat4.transpose(inverseTransposeMatrix, inverseTransposeMatrix);

            vec3.forEach(positions, 3, 0, null, vec3.transformMat4, matrix);
            if (normals) {
                vec3.forEach(normals, 3, 0, null, vec3.transformMat4, inverseTransposeMatrix);
            }
            if (tangents) {
                vec3.forEach(tangents, 4, 0, null, vec3.transformMat4, inverseTransposeMatrix);   
            }
        },

        dispose : function(_gl) {
            this._cache.use(_gl.__GLID__);
            var chunks = this._cache.get('chunks');
            if (chunks) {
                for (var c = 0; c < chunks.length; c++) {
                    var chunk = chunks[c];

                    for (var k = 0; k < chunk.attributeBuffers.length; k++) {
                        var attribs = chunk.attributeBuffers[k];
                        _gl.deleteBuffer(attribs.buffer);
                    }
                }
            }
            this._cache.deleteContext(_gl.__GLID__);
        }
    });

    return StaticGeometry;
});
define('qtek/Renderable',['require','./Node','./core/glenum','./core/glinfo','./math/Vector3','./StaticGeometry'],function(require) {

    

    var Node = require("./Node");
    var glenum = require("./core/glenum");
    var glinfo = require('./core/glinfo');
    var Vector3 = require("./math/Vector3");
    var StaticGeometry = require('./StaticGeometry');

    // Cache
    var prevDrawID = 0;
    var prevDrawIndicesBuffer = null;
    var prevDrawIsUseFace = true;

    var currentDrawID;

    var RenderInfo = function() {
        this.faceNumber = 0;
        this.vertexNumber = 0;
        this.drawCallNumber = 0;
    }

    function VertexArrayObject(
        availableAttributes,
        availableAttributeSymbols,
        indicesBuffer
    ) {
        this.availableAttributes = availableAttributes;
        this.availableAttributeSymbols = availableAttributeSymbols;
        this.indicesBuffer = indicesBuffer;

        this.vao = null;
    }
    /**
     * @constructor qtek.Renderable
     * @extends qtek.Node
     */
    var Renderable = Node.derive(
    /** @lends qtek.Renderable# */
    {
        /**
         * @type {qtek.Material}
         */
        material : null,

        /**
         * @type {qtek.Geometry}
         */
        geometry : null,
        
        /**
         * @type {number}
         */
        mode : glenum.TRIANGLES,

        _drawCache : null,

        _renderInfo : null
    }, function() {
        this._drawCache = {};
        this._renderInfo = new RenderInfo();
    },
    /** @lends qtek.Renderable.prototype */
    {

        // Only if mode is LINES
        /**
         * Used when mode is LINES, LINE_STRIP or LINE_LOOP
         * @type {number}
         */
        lineWidth : 1,
        
        // Culling
        /**
         * @type {boolean}
         */
        culling : true,
        /**
         * @type {number}
         */
        cullFace : glenum.BACK,
        /**
         * @type {number}
         */
        frontFace : glenum.CCW,

        /**
         * Software frustum culling
         * @type {boolean}
         */
        frustumCulling : true,
        /**
         * @type {boolean}
         */
        receiveShadow : true,
        /**
         * @type {boolean}
         */
        castShadow : true,

        /**
         * @return {boolean}
         */
        isRenderable : function() {
            return this.geometry && this.material && this.material.shader && this.visible;
        },

        /**
         * @param  {WebGLRenderingContext} _gl
         * @param  {qtek.Material} [globalMaterial]
         * @return {object}
         */
        render : function(_gl, globalMaterial) {
            var material = globalMaterial || this.material;
            var shader = material.shader;
            var geometry = this.geometry;

            var glDrawMode = this.mode;

            // TODO
            // var vaoExt = glinfo.getExtension(_gl, 'OES_vertex_array_object');
            var vaoExt = null;
            var isStatic = geometry.hint == glenum.STATIC_DRAW;
            
            var nVertex = geometry.getVertexNumber();
            var isUseFace = geometry.isUseFace();
            var renderInfo = this._renderInfo;
            renderInfo.vertexNumber = nVertex;
            renderInfo.faceNumber = 0;
            renderInfo.drawCallNumber = 0;
            // Draw each chunk
            var drawHashChanged = false;
            // Hash with shader id in case previous material has less attributes than next material
            currentDrawID = _gl.__GLID__ + '-' + geometry.__GUID__ + '-' + shader.__GUID__;

            // The cache will be invalid in the following cases
            // 1. Geometry is splitted to multiple chunks
            // 2. VAO is enabled and is binded to null after render
            // 3. Geometry needs update
            if (nVertex > geometry.chunkSize && isUseFace || (vaoExt && isStatic)) {
                drawHashChanged = true;
            }
            else if (geometry.isDirty()) {
                drawHashChanged = true;
            }
            else {
                if (currentDrawID !== prevDrawID) {
                    drawHashChanged = true;
                }
            }
            drawHashChanged = true;
            prevDrawID = currentDrawID;

            if (!drawHashChanged) {
                // Direct draw
                if (prevDrawIsUseFace) {
                    _gl.drawElements(glDrawMode, prevDrawIndicesBuffer.count, _gl.UNSIGNED_SHORT, 0);
                    renderInfo.faceNumber = prevDrawIndicesBuffer.count / 3;
                }
                else {
                    _gl.drawArrays(glDrawMode, 0, nVertex);
                }
                renderInfo.drawCallNumber = 1;
            } else {
                // Use the cache of static geometry
                // TODO : machanism to change to the DynamicGeometry automatically
                // when the geometry is not static any more
                var vaoList = this._drawCache[currentDrawID];
                if (!vaoList) {
                    var chunks = geometry.getBufferChunks(_gl);
                    if (!chunks) {  // Empty mesh
                        return;
                    }
                    vaoList = [];
                    for (var c = 0; c < chunks.length; c++) {
                        var chunk = chunks[c];
                        var attributeBuffers = chunk.attributeBuffers;
                        var indicesBuffer = chunk.indicesBuffer;

                        var availableAttributes = [];
                        var availableAttributeSymbols = [];
                        for (var a = 0; a < attributeBuffers.length; a++) {
                            var attributeBufferInfo = attributeBuffers[a];
                            var name = attributeBufferInfo.name;
                            var semantic = attributeBufferInfo.semantic;

                            if (semantic) {
                                var semanticInfo = shader.attribSemantics[semantic];
                                var symbol = semanticInfo && semanticInfo.symbol;
                            } else {
                                var symbol = name;
                            }
                            if (symbol && shader.attributeTemplates[symbol]) {
                                availableAttributes.push(attributeBufferInfo);
                                availableAttributeSymbols.push(symbol);
                            }
                        }

                        var vao = new VertexArrayObject(
                            availableAttributes,
                            availableAttributeSymbols,
                            indicesBuffer
                        );
                        vaoList.push(vao);
                    }
                    if (isStatic) {
                        this._drawCache[currentDrawID] = vaoList;
                    }
                }

                for (var i = 0; i < vaoList.length; i++) {
                    var vao = vaoList[i];
                    var needsBindAttributes = true;

                    // Create vertex object array cost a lot
                    // So we don't abaddoned it on the dynamic object
                    if (vaoExt && isStatic) {
                        // Use vertex array object
                        // http://blog.tojicode.com/2012/10/oesvertexarrayobject-extension.html
                        if (vao.vao == null) {
                            vao.vao = vaoExt.createVertexArrayOES();
                        } else {
                            needsBindAttributes = false;
                        }
                        vaoExt.bindVertexArrayOES(vao.vao);
                    }

                    var availableAttributes = vao.availableAttributes;
                    var availableAttributeSymbols = vao.availableAttributeSymbols;
                    var indicesBuffer = vao.indicesBuffer;
                    
                    if (needsBindAttributes) {
                        var locationList = shader.enableAttributes(_gl, vao.availableAttributeSymbols);
                        // Setting attributes;
                        for (var a = 0; a < availableAttributes.length; a++) {
                            var location = locationList[a];
                            if (location === -1) {
                                continue;
                            }
                            var attributeBufferInfo = availableAttributes[a];
                            var buffer = attributeBufferInfo.buffer;
                            var symbol = availableAttributeSymbols[a];
                            var size = attributeBufferInfo.size;
                            var glType;
                            switch (attributeBufferInfo.type) {
                                case "float":
                                    glType = _gl.FLOAT;
                                    break;
                                case "byte":
                                    glType = _gl.BYTE;
                                    break;
                                case "ubyte":
                                    glType = _gl.UNSIGNED_BYTE;
                                    break;
                                case "short":
                                    glType = _gl.SHORT;
                                    break;
                                case "ushort":
                                    glType = _gl.UNSIGNED_SHORT;
                                    break;
                                default:
                                    glType = _gl.FLOAT;
                                    break;
                            }

                            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                            _gl.vertexAttribPointer(location, size, glType, false, 0, 0);
                            if (vaoExt && isStatic) {
                                _gl.enableVertexAttribArray(location);
                            }
                        }
                    }
                    if (
                        glDrawMode == glenum.LINES ||
                        glDrawMode == glenum.LINE_STRIP ||
                        glDrawMode == glenum.LINE_LOOP
                    ) {
                        _gl.lineWidth(this.lineWidth);
                    }
                    
                    prevDrawIndicesBuffer = indicesBuffer;
                    prevDrawIsUseFace = geometry.isUseFace();
                    //Do drawing
                    if (prevDrawIsUseFace) {
                        if (needsBindAttributes) {
                            _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, indicesBuffer.buffer);
                        }
                        _gl.drawElements(glDrawMode, indicesBuffer.count, _gl.UNSIGNED_SHORT, 0);
                        renderInfo.faceNumber += indicesBuffer.count / 3;
                    } else {
                        _gl.drawArrays(glDrawMode, 0, nVertex);
                    }

                    if (vaoExt && isStatic) {
                        vaoExt.bindVertexArrayOES(null);
                    }

                    renderInfo.drawCallNumber++;
                }
            }

            return renderInfo;
        },

        clone : (function() {
            var properties = [
                'castShadow', 'receiveShadow',
                'mode', 'culling', 'cullFace', 'frontFace',
                'frustumCulling'
            ];
            return function() {
                var renderable = Node.prototype.clone.call(this);

                renderable.geometry = this.geometry;
                renderable.material = this.material;
                
                for (var i = 0; i < properties.length; i++) {
                    var name = properties[i];
                    // Try not to overwrite the prototype property
                    if (renderable[name] !== this[name]) {
                        renderable[name] = this[name];
                    }
                }

                return renderable;
            }
        })()
    });

    Renderable.beforeFrame = function() {
        prevDrawID = 0;
    }

    // Enums
    Renderable.POINTS = glenum.POINTS;
    Renderable.LINES = glenum.LINES;
    Renderable.LINE_LOOP = glenum.LINE_LOOP;
    Renderable.LINE_STRIP = glenum.LINE_STRIP;
    Renderable.TRIANGLES = glenum.TRIANGLES;
    Renderable.TRIANGLE_STRIP = glenum.TRIANGLE_STRIP;
    Renderable.TRIANGLE_FAN = glenum.TRIANGLE_FAN;

    Renderable.BACK = glenum.BACK;
    Renderable.FRONT = glenum.FRONT;
    Renderable.FRONT_AND_BACK = glenum.FRONT_AND_BACK;
    Renderable.CW = glenum.CW;
    Renderable.CCW = glenum.CCW;

    Renderable.RenderInfo = RenderInfo;

    return Renderable;
});
define('qtek/Mesh',['require','./Renderable','./core/glenum','./core/glinfo'],function(require) {

    

    var Renderable = require("./Renderable");
    var glenum = require("./core/glenum");
    var glinfo = require('./core/glinfo');

    /**
     * @constructor qtek.Mesh
     * @extends qtek.Renderable
     */
    var Mesh = Renderable.derive(
    /** @lends qtek.Mesh# */
    {

        mode : glenum.TRIANGLES,

        /**
         * Used when it is a skinned mesh
         * @type {qtek.Skeleton}
         */
        skeleton : null,
        /**
         * Joints indices Meshes can share the one skeleton instance and each mesh can use one part of joints. Joints indices indicate the index of joint in the skeleton instance
         * @type {number[]}
         */
        joints : null

    }, function() {
        if (!this.joints) {
            this.joints = [];
        }
    }, {

        render : function(_gl, globalMaterial) {       
            var material = globalMaterial || this.material;
            // Set pose matrices of skinned mesh
            if (this.skeleton) {
                var skinMatricesArray = this.skeleton.getSubSkinMatrices(this.__GUID__, this.joints);
                material.shader.setUniformBySemantic(_gl, "SKIN_MATRIX", skinMatricesArray);
            }

            return Renderable.prototype.render.call(this, _gl, globalMaterial);
        }
    });

    // Enums
    Mesh.POINTS = glenum.POINTS;
    Mesh.LINES = glenum.LINES;
    Mesh.LINE_LOOP = glenum.LINE_LOOP;
    Mesh.LINE_STRIP = glenum.LINE_STRIP;
    Mesh.TRIANGLES = glenum.TRIANGLES;
    Mesh.TRIANGLE_STRIP = glenum.TRIANGLE_STRIP;
    Mesh.TRIANGLE_FAN = glenum.TRIANGLE_FAN;

    Mesh.BACK = glenum.BACK;
    Mesh.FRONT = glenum.FRONT;
    Mesh.FRONT_AND_BACK = glenum.FRONT_AND_BACK;
    Mesh.CW = glenum.CW;
    Mesh.CCW = glenum.CCW;

    return Mesh;
});
define('qtek/shader/source/basic.essl',[],function () { return '@export buildin.basic.vertex\n\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\n\nuniform vec2 uvRepeat : [1.0, 1.0];\n\nattribute vec2 texcoord : TEXCOORD_0;\nattribute vec3 position : POSITION;\n\nattribute vec3 barycentric;\n\n#ifdef SKINNING\nattribute vec3 weight : WEIGHT;\nattribute vec4 joint : JOINT;\n\nuniform mat4 skinMatrix[JOINT_NUMBER] : SKIN_MATRIX;\n#endif\n\nvarying vec2 v_Texcoord;\nvarying vec3 v_Barycentric;\n\nvoid main()\n{\n    vec3 skinnedPosition = position;\n\n    #ifdef SKINNING\n        \n        @import buildin.chunk.skin_matrix\n        \n        skinnedPosition = (skinMatrixWS * vec4(position, 1.0)).xyz;\n    #endif\n\n    v_Texcoord = texcoord * uvRepeat;\n    v_Barycentric = barycentric;\n\n    gl_Position = worldViewProjection * vec4(skinnedPosition, 1.0);\n}\n\n@end\n\n\n\n\n@export buildin.basic.fragment\n\nvarying vec2 v_Texcoord;\nuniform sampler2D diffuseMap;\nuniform vec3 color : [1.0, 1.0, 1.0];\nuniform vec3 emission : [0.0, 0.0, 0.0];\nuniform float alpha : 1.0;\n\n// Uniforms for wireframe\nuniform float lineWidth : 0.0;\nuniform vec3 lineColor : [0.0, 0.0, 0.0];\nvarying vec3 v_Barycentric;\n\n#extension GL_OES_standard_derivatives : enable\n@import buildin.util.edge_factor\n\nvoid main()\n{\n\n    #ifdef RENDER_TEXCOORD\n        gl_FragColor = vec4(v_Texcoord, 1.0, 1.0);\n        return;\n    #endif\n\n    gl_FragColor = vec4(color, alpha);\n    \n    #ifdef DIFFUSEMAP_ENABLED\n        vec4 tex = texture2D( diffuseMap, v_Texcoord );\n\n        #ifdef SRGB_DECODE\n            tex.rgb = pow(tex.rgb, vec3(2.2));\n        #endif\n        \n        #if defined(DIFFUSEMAP_ALPHA_ALPHA)\n            gl_FragColor.a = tex.a;\n        #endif\n\n        gl_FragColor.rgb *= tex.rgb;\n    #endif\n\n    gl_FragColor.rgb += emission;\n    if( lineWidth > 0.01)\n    {\n        gl_FragColor.rgb = gl_FragColor.rgb * mix(lineColor, vec3(1.0), edgeFactor(lineWidth));\n    }\n}\n\n@end';});

define('qtek/shader/source/lambert.essl',[],function () { return '/**\n * http://en.wikipedia.org/wiki/Lambertian_reflectance\n */\n\n@export buildin.lambert.vertex\n\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\nuniform mat4 worldInverseTranspose : WORLDINVERSETRANSPOSE;\nuniform mat4 world : WORLD;\n\nuniform vec2 uvRepeat : [1.0, 1.0];\n\nattribute vec3 position : POSITION;\nattribute vec2 texcoord : TEXCOORD_0;\nattribute vec3 normal : NORMAL;\n\nattribute vec3 barycentric;\n\n#ifdef SKINNING\nattribute vec3 weight : WEIGHT;\nattribute vec4 joint : JOINT;\n\nuniform mat4 skinMatrix[JOINT_NUMBER] : SKIN_MATRIX;\n#endif\n\nvarying vec2 v_Texcoord;\nvarying vec3 v_Normal;\nvarying vec3 v_WorldPosition;\nvarying vec3 v_Barycentric;\n\nvoid main()\n{\n\n    vec3 skinnedPosition = position;\n    vec3 skinnedNormal = normal;\n\n    #ifdef SKINNING\n        \n        @import buildin.chunk.skin_matrix\n\n        skinnedPosition = (skinMatrixWS * vec4(position, 1.0)).xyz;\n        // Normal matrix ???\n        skinnedNormal = (skinMatrixWS * vec4(normal, 0.0)).xyz;\n    #endif\n\n    gl_Position = worldViewProjection * vec4( skinnedPosition, 1.0 );\n\n    v_Texcoord = texcoord * uvRepeat;\n    v_Normal = normalize( ( worldInverseTranspose * vec4(skinnedNormal, 0.0) ).xyz );\n    v_WorldPosition = ( world * vec4( skinnedPosition, 1.0) ).xyz;\n\n    v_Barycentric = barycentric;\n}\n\n@end\n\n\n\n\n@export buildin.lambert.fragment\n\nvarying vec2 v_Texcoord;\nvarying vec3 v_Normal;\nvarying vec3 v_WorldPosition;\n\nuniform sampler2D diffuseMap;\nuniform sampler2D alphaMap;\n\nuniform vec3 color : [1.0, 1.0, 1.0];\nuniform vec3 emission : [0.0, 0.0, 0.0];\nuniform float alpha : 1.0;\n\n// Uniforms for wireframe\nuniform float lineWidth : 0.0;\nuniform vec3 lineColor : [0.0, 0.0, 0.0];\nvarying vec3 v_Barycentric;\n\n#ifdef AMBIENT_LIGHT_NUMBER\n@import buildin.header.ambient_light\n#endif\n#ifdef POINT_LIGHT_NUMBER\n@import buildin.header.point_light\n#endif\n#ifdef DIRECTIONAL_LIGHT_NUMBER\n@import buildin.header.directional_light\n#endif\n#ifdef SPOT_LIGHT_NUMBER\n@import buildin.header.spot_light\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n// Import util functions and uniforms needed\n@import buildin.util.calculate_attenuation\n\n@import buildin.util.edge_factor\n\n@import buildin.plugin.compute_shadow_map\n\nvoid main()\n{\n    #ifdef RENDER_NORMAL\n        gl_FragColor = vec4(v_Normal, 1.0);\n        return;\n    #endif\n    #ifdef RENDER_TEXCOORD\n        gl_FragColor = vec4(v_Texcoord, 1.0, 1.0);\n        return;\n    #endif\n\n    gl_FragColor = vec4(color, alpha);\n\n    #ifdef DIFFUSEMAP_ENABLED\n        vec4 tex = texture2D( diffuseMap, v_Texcoord );\n        #ifdef SRGB_DECODE\n            tex.rgb = pow(tex.rgb, vec3(2.2));\n        #endif\n        gl_FragColor.rgb *= tex.rgb;\n        #ifdef DIFFUSEMAP_ALPHA_ALPHA\n            gl_FragColor.a *= tex.a;\n        #endif\n    #endif\n\n    vec3 diffuseColor = vec3(0.0, 0.0, 0.0);\n    \n    #ifdef AMBIENT_LIGHT_NUMBER\n        for(int i = 0; i < AMBIENT_LIGHT_NUMBER; i++)\n        {\n            diffuseColor += ambientLightColor[i];\n        }\n    #endif\n    // Compute point light color\n    #ifdef POINT_LIGHT_NUMBER\n        #if defined(POINT_LIGHT_SHADOWMAP_NUMBER)\n            float shadowContribs[POINT_LIGHT_NUMBER];\n            if( shadowEnabled )\n            {\n                computeShadowOfPointLights( v_WorldPosition, shadowContribs );\n            }\n        #endif\n        for(int i = 0; i < POINT_LIGHT_NUMBER; i++)\n        {\n\n            vec3 lightPosition = pointLightPosition[i];\n            vec3 lightColor = pointLightColor[i];\n            float range = pointLightRange[i];\n\n            vec3 lightDirection = lightPosition - v_WorldPosition;\n\n            // Calculate point light attenuation\n            float dist = length(lightDirection);\n            float attenuation = lightAttenuation(dist, range);\n\n            // Normalize vectors\n            lightDirection /= dist;\n\n            float ndl = dot( v_Normal, lightDirection );\n\n            float shadowContrib = 1.0;\n            #if defined(POINT_LIGHT_SHADOWMAP_NUMBER)\n                if( shadowEnabled )\n                {\n                    shadowContrib = shadowContribs[i];\n                }\n            #endif\n\n            diffuseColor += lightColor * clamp(ndl, 0.0, 1.0) * attenuation * shadowContrib;\n        }\n    #endif\n    #ifdef DIRECTIONAL_LIGHT_NUMBER\n        #if defined(DIRECTIONAL_LIGHT_SHADOWMAP_NUMBER)\n            float shadowContribs[DIRECTIONAL_LIGHT_NUMBER];\n            if(shadowEnabled)\n            {\n                computeShadowOfDirectionalLights( v_WorldPosition, shadowContribs );\n            }\n        #endif\n        for(int i = 0; i < DIRECTIONAL_LIGHT_NUMBER; i++)\n        {\n            vec3 lightDirection = -directionalLightDirection[i];\n            vec3 lightColor = directionalLightColor[i];\n            \n            float ndl = dot( v_Normal, normalize( lightDirection ) );\n\n            float shadowContrib = 1.0;\n            #if defined(DIRECTIONAL_LIGHT_SHADOWMAP_NUMBER)\n                if( shadowEnabled )\n                {\n                    shadowContrib = shadowContribs[i];\n                }\n            #endif\n\n            diffuseColor += lightColor * clamp(ndl, 0.0, 1.0) * shadowContrib;\n        }\n    #endif\n    \n    #ifdef SPOT_LIGHT_NUMBER\n        #if defined(SPOT_LIGHT_SHADOWMAP_NUMBER)\n            float shadowContribs[SPOT_LIGHT_NUMBER];\n            if( shadowEnabled )\n            {\n                computeShadowOfSpotLights( v_WorldPosition, shadowContribs );\n            }\n        #endif\n        for(int i = 0; i < SPOT_LIGHT_NUMBER; i++)\n        {\n            vec3 lightPosition = -spotLightPosition[i];\n            vec3 spotLightDirection = -normalize( spotLightDirection[i] );\n            vec3 lightColor = spotLightColor[i];\n            float range = spotLightRange[i];\n            float a = spotLightUmbraAngleCosine[i];\n            float b = spotLightPenumbraAngleCosine[i];\n            float falloffFactor = spotLightFalloffFactor[i];\n\n            vec3 lightDirection = lightPosition - v_WorldPosition;\n            // Calculate attenuation\n            float dist = length(lightDirection);\n            float attenuation = lightAttenuation(dist, range); \n\n            // Normalize light direction\n            lightDirection /= dist;\n            // Calculate spot light fall off\n            float c = dot(spotLightDirection, lightDirection);\n\n            float falloff;\n            falloff = clamp((c - a) /( b - a), 0.0, 1.0);\n            falloff = pow(falloff, falloffFactor);\n\n            float ndl = dot(v_Normal, lightDirection);\n            ndl = clamp(ndl, 0.0, 1.0);\n\n            float shadowContrib = 1.0;\n            #if defined(SPOT_LIGHT_SHADOWMAP_NUMBER)\n                if( shadowEnabled )\n                {\n                    shadowContrib = shadowContribs[i];\n                }\n            #endif\n\n            diffuseColor += lightColor * ndl * attenuation * (1.0-falloff) * shadowContrib;\n\n        }\n    #endif\n\n    gl_FragColor.rgb *= diffuseColor;\n    gl_FragColor.rgb += emission;\n    if(lineWidth > 0.01)\n    {\n        gl_FragColor.rgb = gl_FragColor.rgb * mix(lineColor, vec3(1.0), edgeFactor(lineWidth));\n    }\n}\n\n@end';});

define('qtek/shader/source/phong.essl',[],function () { return '\n// http://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\n\n@export buildin.phong.vertex\n\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\nuniform mat4 worldInverseTranspose : WORLDINVERSETRANSPOSE;\nuniform mat4 world : WORLD;\n\nuniform vec2 uvRepeat : [1.0, 1.0];\n\nattribute vec3 position : POSITION;\nattribute vec2 texcoord : TEXCOORD_0;\nattribute vec3 normal : NORMAL;\nattribute vec4 tangent : TANGENT;\n\n#ifdef VERTEX_COLOR\nattribute vec4 color : COLOR;\n#endif\n\nattribute vec3 barycentric;\n\n#ifdef SKINNING\nattribute vec3 weight : WEIGHT;\nattribute vec4 joint : JOINT;\n\nuniform mat4 skinMatrix[JOINT_NUMBER] : SKIN_MATRIX;\n#endif\n\nvarying vec2 v_Texcoord;\nvarying vec3 v_Normal;\nvarying vec3 v_WorldPosition;\nvarying vec3 v_Barycentric;\n\n#ifdef NORMALMAP_ENABLED\nvarying vec3 v_Tangent;\nvarying vec3 v_Bitangent;\n#endif\n\n#ifdef VERTEX_COLOR\nvarying vec4 v_Color;\n#endif\n\nvoid main()\n{\n    \n    vec3 skinnedPosition = position;\n    vec3 skinnedNormal = normal;\n    vec3 skinnedTangent = tangent.xyz;\n    #ifdef SKINNING\n        \n        @import buildin.chunk.skin_matrix\n\n        skinnedPosition = (skinMatrixWS * vec4(position, 1.0)).xyz;\n        // Normal matrix ???\n        skinnedNormal = (skinMatrixWS * vec4(normal, 0.0)).xyz;\n        skinnedTangent = (skinMatrixWS * vec4(tangent.xyz, 0.0)).xyz;\n    #endif\n\n    gl_Position = worldViewProjection * vec4(skinnedPosition, 1.0);\n\n    v_Texcoord = texcoord * uvRepeat;\n    v_WorldPosition = (world * vec4(skinnedPosition, 1.0)).xyz;\n    v_Barycentric = barycentric;\n\n    v_Normal = normalize((worldInverseTranspose * vec4(skinnedNormal, 0.0)).xyz);\n    \n    #ifdef NORMALMAP_ENABLED\n        v_Tangent = normalize((worldInverseTranspose * vec4(skinnedTangent, 0.0)).xyz);\n        v_Bitangent = normalize(cross(v_Normal, v_Tangent) * tangent.w);\n    #endif\n\n    #ifdef VERTEX_COLOR\n        v_Color = color;\n    #endif\n}\n\n@end\n\n\n@export buildin.phong.fragment\n\nuniform mat4 viewInverse : VIEWINVERSE;\n\nvarying vec2 v_Texcoord;\nvarying vec3 v_Normal;\nvarying vec3 v_WorldPosition;\n\n#ifdef NORMALMAP_ENABLED\nvarying vec3 v_Tangent;\nvarying vec3 v_Bitangent;\n#endif\n\nuniform sampler2D diffuseMap;\nuniform sampler2D normalMap;\nuniform samplerCube environmentMap;\n\nuniform vec3 color : [1.0, 1.0, 1.0];\nuniform float alpha : 1.0;\n\nuniform float shininess : 30;\n\nuniform vec3 specularColor : [1.0, 1.0, 1.0];\nuniform vec3 emission : [0.0, 0.0, 0.0];\n\nuniform float reflectivity : 0.5;\n\n// Uniforms for wireframe\nuniform float lineWidth : 0.0;\nuniform vec3 lineColor : [0.0, 0.0, 0.0];\nvarying vec3 v_Barycentric;\n\n#ifdef AMBIENT_LIGHT_NUMBER\n@import buildin.header.ambient_light\n#endif\n#ifdef POINT_LIGHT_NUMBER\n@import buildin.header.point_light\n#endif\n#ifdef DIRECTIONAL_LIGHT_NUMBER\n@import buildin.header.directional_light\n#endif\n#ifdef SPOT_LIGHT_NUMBER\n@import buildin.header.spot_light\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n// Import util functions and uniforms needed\n@import buildin.util.calculate_attenuation\n\n@import buildin.util.edge_factor\n\n@import buildin.plugin.compute_shadow_map\n\nvoid main()\n{\n    #ifdef RENDER_TEXCOORD\n        gl_FragColor = vec4(v_Texcoord, 1.0, 1.0);\n        return;\n    #endif\n\n    vec4 finalColor = vec4(color, alpha);\n\n    vec3 eyePos = viewInverse[3].xyz;\n    vec3 viewDirection = normalize(eyePos - v_WorldPosition);\n\n    #ifdef DIFFUSEMAP_ENABLED\n        vec4 tex = texture2D(diffuseMap, v_Texcoord);\n        #ifdef SRGB_DECODE\n            tex.rgb = pow(tex.rgb, vec3(2.2));\n        #endif\n        finalColor.rgb *= tex.rgb;\n        #ifdef DIFFUSEMAP_ALPHA_ALPHA\n            finalColor.a *= tex.a;\n        #endif\n    #endif\n\n    vec3 normal = v_Normal;\n    #ifdef NORMALMAP_ENABLED\n        normal = texture2D(normalMap, v_Texcoord).xyz * 2.0 - 1.0;\n        mat3 tbn = mat3(v_Tangent, v_Bitangent, v_Normal);\n        normal = normalize(tbn * normal);\n    #endif\n\n    #ifdef RENDER_NORMAL\n        gl_FragColor = vec4(normal, 1.0);\n        return;\n    #endif\n\n    // Diffuse part of all lights\n    vec3 diffuseTerm = vec3(0.0, 0.0, 0.0);\n    // Specular part of all lights\n    vec3 specularTerm = vec3(0.0, 0.0, 0.0);\n    \n    #ifdef AMBIENT_LIGHT_NUMBER\n        for(int i = 0; i < AMBIENT_LIGHT_NUMBER; i++)\n        {\n            diffuseTerm += ambientLightColor[i];\n        }\n    #endif\n    #ifdef POINT_LIGHT_NUMBER\n        #if defined(POINT_LIGHT_SHADOWMAP_NUMBER)\n            float shadowContribs[POINT_LIGHT_NUMBER];\n            if(shadowEnabled)\n            {\n                computeShadowOfPointLights(v_WorldPosition, shadowContribs);\n            }\n        #endif\n        for(int i = 0; i < POINT_LIGHT_NUMBER; i++)\n        {\n            vec3 lightPosition = pointLightPosition[i];\n            vec3 lightColor = pointLightColor[i];\n            float range = pointLightRange[i];\n\n            vec3 lightDirection = lightPosition - v_WorldPosition;\n\n            // Calculate point light attenuation\n            float dist = length(lightDirection);\n            float attenuation = lightAttenuation(dist, range); \n\n            // Normalize vectors\n            lightDirection /= dist;\n            vec3 halfVector = normalize(lightDirection + viewDirection);\n\n            float ndh = dot(normal, halfVector);\n            ndh = clamp(ndh, 0.0, 1.0);\n\n            float ndl = dot(normal,  lightDirection);\n            ndl = clamp(ndl, 0.0, 1.0);\n\n            float shadowContrib = 1.0;\n            #if defined(POINT_LIGHT_SHADOWMAP_NUMBER)\n                if(shadowEnabled)\n                {\n                    shadowContrib = shadowContribs[i];\n                }\n            #endif\n\n            vec3 li = lightColor * ndl * attenuation * shadowContrib;\n\n            diffuseTerm += li;\n            if (shininess > 0.0)\n            {\n                specularTerm += li * pow(ndh, shininess);\n            }\n\n        }\n    #endif\n\n    #ifdef DIRECTIONAL_LIGHT_NUMBER\n        #if defined(DIRECTIONAL_LIGHT_SHADOWMAP_NUMBER)\n            float shadowContribs[DIRECTIONAL_LIGHT_NUMBER];\n            if(shadowEnabled)\n            {\n                computeShadowOfDirectionalLights(v_WorldPosition, shadowContribs);\n            }\n        #endif\n        for(int i = 0; i < DIRECTIONAL_LIGHT_NUMBER; i++)\n        {\n\n            vec3 lightDirection = -normalize(directionalLightDirection[i]);\n            vec3 lightColor = directionalLightColor[i];\n\n            vec3 halfVector = normalize(lightDirection + viewDirection);\n\n            float ndh = dot(normal, halfVector);\n            ndh = clamp(ndh, 0.0, 1.0);\n\n            float ndl = dot(normal, lightDirection);\n            ndl = clamp(ndl, 0.0, 1.0);\n\n            float shadowContrib = 1.0;\n            #if defined(DIRECTIONAL_LIGHT_SHADOWMAP_NUMBER)\n                if(shadowEnabled)\n                {\n                    shadowContrib = shadowContribs[i];\n                }\n            #endif\n\n            vec3 li = lightColor * ndl * shadowContrib;\n\n            diffuseTerm += li;\n            if (shininess > 0.0)\n            {\n                specularTerm += li * pow(ndh, shininess);\n            }\n        }\n    #endif\n\n    #ifdef SPOT_LIGHT_NUMBER\n        #if defined(SPOT_LIGHT_SHADOWMAP_NUMBER)\n            float shadowContribs[SPOT_LIGHT_NUMBER];\n            if(shadowEnabled)\n            {\n                computeShadowOfSpotLights(v_WorldPosition, shadowContribs);\n            }\n        #endif\n        for(int i = 0; i < SPOT_LIGHT_NUMBER; i++)\n        {\n            vec3 lightPosition = spotLightPosition[i];\n            vec3 spotLightDirection = -normalize(spotLightDirection[i]);\n            vec3 lightColor = spotLightColor[i];\n            float range = spotLightRange[i];\n            float a = spotLightUmbraAngleCosine[i];\n            float b = spotLightPenumbraAngleCosine[i];\n            float falloffFactor = spotLightFalloffFactor[i];\n\n            vec3 lightDirection = lightPosition - v_WorldPosition;\n            // Calculate attenuation\n            float dist = length(lightDirection);\n            float attenuation = lightAttenuation(dist, range); \n\n            // Normalize light direction\n            lightDirection /= dist;\n            // Calculate spot light fall off\n            float c = dot(spotLightDirection, lightDirection);\n\n            float falloff;\n            // Fomular from real-time-rendering\n            falloff = clamp((c - a) /( b - a), 0.0, 1.0);\n            falloff = pow(falloff, falloffFactor);\n\n            vec3 halfVector = normalize(lightDirection + viewDirection);\n\n            float ndh = dot(normal, halfVector);\n            ndh = clamp(ndh, 0.0, 1.0);\n\n            float ndl = dot(normal, lightDirection);\n            ndl = clamp(ndl, 0.0, 1.0);\n\n            float shadowContrib = 1.0;\n            #if defined(SPOT_LIGHT_SHADOWMAP_NUMBER)\n                if (shadowEnabled)\n                {\n                    shadowContrib = shadowContribs[i];\n                }\n            #endif\n\n            vec3 li = lightColor * ndl * attenuation * (1.0-falloff) * shadowContrib;\n\n            diffuseTerm += li;\n            if (shininess > 0.0)\n            {\n                specularTerm += li * pow(ndh, shininess);\n            }\n        }\n    #endif\n\n    finalColor.rgb *= diffuseTerm;\n    finalColor.rgb += specularTerm * specularColor;\n    finalColor.rgb += emission;\n\n    #ifdef ENVIRONMENTMAP_ENABLED\n        vec3 envTex = textureCube(environmentMap, reflect(-viewDirection, normal)).xyz;\n        finalColor.rgb = finalColor.rgb + envTex * reflectivity;\n    #endif\n\n    if(lineWidth > 0.01)\n    {\n        finalColor.rgb = finalColor.rgb * mix(lineColor, vec3(1.0), edgeFactor(lineWidth));\n    }\n\n    #ifdef GAMMA_ENCODE\n        finalColor.rgb = pow(finalColor.rgb, vec3(1 / 2.2));\n    #endif\n\n    gl_FragColor = finalColor;\n}\n\n@end';});

define('qtek/shader/source/physical.essl',[],function () { return '\n// http://blog.selfshadow.com/publications/s2013-shading-course/\n\n@export buildin.physical.vertex\n\n@import buildin.phong.vertex\n\n@end\n\n\n@export buildin.physical.fragment\n\n#define PI 3.14159265358979\n\nuniform mat4 viewInverse : VIEWINVERSE;\n\nvarying vec2 v_Texcoord;\nvarying vec3 v_Normal;\nvarying vec3 v_WorldPosition;\n\n#ifdef NORMALMAP_ENABLED\nvarying vec3 v_Tangent;\nvarying vec3 v_Bitangent;\n#endif\n\nuniform sampler2D diffuseMap;\nuniform sampler2D normalMap;\nuniform samplerCube environmentMap;\n\nuniform vec3 color : [1.0, 1.0, 1.0];\nuniform float alpha : 1.0;\n\nuniform float glossiness : 0.5;\n\nuniform vec3 specularColor : [0.1, 0.1, 0.1];\nuniform vec3 emission : [0.0, 0.0, 0.0];\n\n// Uniforms for wireframe\nuniform float lineWidth : 0.0;\nuniform vec3 lineColor : [0.0, 0.0, 0.0];\nvarying vec3 v_Barycentric;\n\n#ifdef AMBIENT_LIGHT_NUMBER\n@import buildin.header.ambient_light\n#endif\n#ifdef POINT_LIGHT_NUMBER\n@import buildin.header.point_light\n#endif\n#ifdef DIRECTIONAL_LIGHT_NUMBER\n@import buildin.header.directional_light\n#endif\n#ifdef SPOT_LIGHT_NUMBER\n@import buildin.header.spot_light\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\n// Import util functions and uniforms needed\n@import buildin.util.calculate_attenuation\n\n@import buildin.util.edge_factor\n\n@import buildin.plugin.compute_shadow_map\n\n\nfloat G_Smith(float glossiness, float ndv, float ndl)\n{\n    // float k = (roughness+1.0) * (roughness+1.0) * 0.125;\n    float roughness = 1.0 - glossiness;\n    float k = roughness * roughness / 2.0;\n    float G1V = ndv / (ndv * (1.0 - k) + k);\n    float G1L = ndl / (ndl * (1.0 - k) + k);\n    return G1L * G1V;\n}\n\nvec3 F_Schlick(float ldn) {\n    return specularColor + (1.0 - specularColor) * pow(1.0 - ldn, 5.0);\n}\n\nfloat D_Phong(float g, float ndh) {\n    // from black ops 2\n    float a = pow(8192.0, g);\n    return (a + 2.0) / 8.0 * pow(ndh, a);\n}\n\nfloat D_GGX(float g, float ndh) {\n    float r = 1.0 - g;\n    float a = r * r;\n    float tmp = ndh * ndh * (a - 1.0) + 1.0;\n    return a / (PI * tmp * tmp);\n}\n\nvoid main()\n{\n    #ifdef RENDER_TEXCOORD\n        gl_FragColor = vec4(v_Texcoord, 1.0, 1.0);\n        return;\n    #endif\n\n    vec4 finalColor = vec4(color, alpha);\n\n    vec3 eyePos = viewInverse[3].xyz;\n    vec3 V = normalize(eyePos - v_WorldPosition);\n    float g = glossiness;\n\n    #ifdef DIFFUSEMAP_ENABLED\n        vec4 tex = texture2D(diffuseMap, v_Texcoord);\n        #ifdef SRGB_DECODE\n            tex.rgb = pow(tex.rgb, vec3(2.2));\n        #endif\n        finalColor.rgb *= tex.rgb;\n        #ifdef DIFFUSEMAP_ALPHA_ALPHA\n            finalColor.a *= tex.a;\n        #endif\n        #ifdef DIFFUSEMAP_ALPHA_GLOSS\n            g *= tex.a;\n        #endif\n    #endif\n\n    vec3 N = v_Normal;\n    #ifdef NORMALMAP_ENABLED\n        N = texture2D(normalMap, v_Texcoord).xyz * 2.0 - 1.0;\n        mat3 tbn = mat3(v_Tangent, v_Bitangent, v_Normal);\n        N = normalize(tbn * N);\n    #endif\n\n    #ifdef RENDER_NORMAL\n        gl_FragColor = vec4(N, 1.0);\n        return;\n    #endif\n\n    #ifdef RENDER_GLOSSINESS\n        gl_FragColor = vec4(vec3(g), 1.0);\n        return;\n    #endif\n\n    float ndv = dot(N, V);\n\n    // Diffuse part of all lights\n    vec3 diffuseTerm = vec3(0.0, 0.0, 0.0);\n    // Specular part of all lights\n    vec3 specularTerm = vec3(0.0, 0.0, 0.0);\n    \n    #ifdef AMBIENT_LIGHT_NUMBER\n        for(int i = 0; i < AMBIENT_LIGHT_NUMBER; i++)\n        {\n            // Hemisphere ambient lighting from cryengine\n            diffuseTerm += ambientLightColor[i] * (clamp(N.y * 0.7, 0.0, 1.0) + 0.3);\n            // diffuseTerm += ambientLightColor[i];\n        }\n    #endif\n    #ifdef POINT_LIGHT_NUMBER\n        #if defined(POINT_LIGHT_SHADOWMAP_NUMBER)\n            float shadowContribs[POINT_LIGHT_NUMBER];\n            if(shadowEnabled)\n            {\n                computeShadowOfPointLights(v_WorldPosition, shadowContribs);\n            }\n        #endif\n        for(int i = 0; i < POINT_LIGHT_NUMBER; i++)\n        {\n\n            vec3 lightPosition = pointLightPosition[i];\n            vec3 lc = pointLightColor[i];\n            float range = pointLightRange[i];\n\n            vec3 L = lightPosition - v_WorldPosition;\n\n            // Calculate point light attenuation\n            float dist = length(L);\n            float attenuation = lightAttenuation(dist, range); \n            L /= dist;\n            vec3 H = normalize(L + V);\n            float ndl = clamp(dot(N, L), 0.0, 1.0);\n            float ndh = clamp(dot(N, H), 0.0, 1.0);\n            float ldn = clamp(dot(L, N), 0.0, 1.0);\n\n            float shadowContrib = 1.0;\n            #if defined(POINT_LIGHT_SHADOWMAP_NUMBER)\n                if(shadowEnabled)\n                {\n                    shadowContrib = shadowContribs[i];\n                }\n            #endif\n\n            vec3 li = lc * ndl * attenuation * shadowContrib;\n            diffuseTerm += li;\n            specularTerm += li * F_Schlick(ldn) * D_Phong(g, ndh);\n        }\n    #endif\n\n    #ifdef DIRECTIONAL_LIGHT_NUMBER\n        #if defined(DIRECTIONAL_LIGHT_SHADOWMAP_NUMBER)\n            float shadowContribs[DIRECTIONAL_LIGHT_NUMBER];\n            if(shadowEnabled)\n            {\n                computeShadowOfDirectionalLights(v_WorldPosition, shadowContribs);\n            }\n        #endif\n        for(int i = 0; i < DIRECTIONAL_LIGHT_NUMBER; i++)\n        {\n\n            vec3 L = -normalize(directionalLightDirection[i]);\n            vec3 lc = directionalLightColor[i];\n\n            vec3 H = normalize(L + V);\n            float ndl = clamp(dot(N, L), 0.0, 1.0);\n            float ndh = clamp(dot(N, H), 0.0, 1.0);\n            float ldn = clamp(dot(L, N), 0.0, 1.0);\n\n            float shadowContrib = 1.0;\n            #if defined(DIRECTIONAL_LIGHT_SHADOWMAP_NUMBER)\n                if(shadowEnabled)\n                {\n                    shadowContrib = shadowContribs[i];\n                }\n            #endif\n\n            vec3 li = lc * ndl * shadowContrib;\n\n            diffuseTerm += li;\n            specularTerm += li * F_Schlick(ldn) * D_Phong(g, ndh);\n        }\n    #endif\n\n    #ifdef SPOT_LIGHT_NUMBER\n        #if defined(SPOT_LIGHT_SHADOWMAP_NUMBER)\n            float shadowContribs[SPOT_LIGHT_NUMBER];\n            if(shadowEnabled)\n            {\n                computeShadowOfSpotLights(v_WorldPosition, shadowContribs);\n            }\n        #endif\n        for(int i = 0; i < SPOT_LIGHT_NUMBER; i++)\n        {\n            vec3 lightPosition = spotLightPosition[i];\n            vec3 spotLightDirection = -normalize(spotLightDirection[i]);\n            vec3 lc = spotLightColor[i];\n            float range = spotLightRange[i];\n            float a = spotLightUmbraAngleCosine[i];\n            float b = spotLightPenumbraAngleCosine[i];\n            float falloffFactor = spotLightFalloffFactor[i];\n\n            vec3 L = lightPosition - v_WorldPosition;\n            // Calculate attenuation\n            float dist = length(L);\n            float attenuation = lightAttenuation(dist, range); \n\n            // Normalize light direction\n            L /= dist;\n            // Calculate spot light fall off\n            float c = dot(spotLightDirection, L);\n\n            float falloff;\n            // Fomular from real-time-rendering\n            falloff = clamp((c - a) /( b - a), 0.0, 1.0);\n            falloff = pow(falloff, falloffFactor);\n\n            vec3 H = normalize(L + V);\n            float ndl = clamp(dot(N, L), 0.0, 1.0);\n            float ndh = clamp(dot(N, H), 0.0, 1.0);\n            float ldn = clamp(dot(L, N), 0.0, 1.0);\n\n            float shadowContrib = 1.0;\n            #if defined(SPOT_LIGHT_SHADOWMAP_NUMBER)\n                if (shadowEnabled)\n                {\n                    shadowContrib = shadowContribs[i];\n                }\n            #endif\n\n            vec3 li = lc * attenuation * (1.0-falloff) * shadowContrib * ndl;\n\n            diffuseTerm += li;\n            specularTerm += li * F_Schlick(ldn) * D_Phong(g, ndh);\n        }\n    #endif\n\n    finalColor.rgb *= diffuseTerm;\n    finalColor.rgb += specularTerm;\n    finalColor.rgb += emission;\n\n    #ifdef ENVIRONMENTMAP_ENABLED\n        vec3 envTex = textureCube(environmentMap, reflect(-V, N)).xyz;\n        finalColor.rgb = finalColor.rgb + envTex * g;\n    #endif\n\n    if(lineWidth > 0.)\n    {\n        finalColor.rgb = finalColor.rgb * mix(lineColor, vec3(1.0), edgeFactor(lineWidth));\n    }\n\n    #ifdef GAMMA_ENCODE\n        finalColor.rgb = pow(finalColor.rgb, vec3(1 / 2.2));\n    #endif\n    gl_FragColor = finalColor;\n}\n\n@end';});

define('qtek/shader/source/wireframe.essl',[],function () { return '@export buildin.wireframe.vertex\n\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\nuniform mat4 world : WORLD;\n\nattribute vec3 position : POSITION;\nattribute vec3 barycentric;\n\n#ifdef SKINNING\nattribute vec3 weight : WEIGHT;\nattribute vec4 joint : JOINT;\n\nuniform mat4 skinMatrix[JOINT_NUMBER] : SKIN_MATRIX;\n#endif\n\nvarying vec3 v_Barycentric;\n\nvoid main()\n{\n\n    vec3 skinnedPosition = position;\n    #ifdef SKINNING\n\n        @import buildin.chunk.skin_matrix\n\n        skinnedPosition = (skinMatrixWS * vec4(position, 1.0)).xyz;\n    #endif\n\n    gl_Position = worldViewProjection * vec4(skinnedPosition, 1.0 );\n\n    v_Barycentric = barycentric;\n}\n\n@end\n\n\n@export buildin.wireframe.fragment\n\nuniform vec3 color : [0.0, 0.0, 0.0];\n\nuniform float alpha : 1.0;\nuniform float lineWidth : 1.0;\n\nvarying vec3 v_Barycentric;\n\n#extension GL_OES_standard_derivatives : enable\n\n@import buildin.util.edge_factor\n\nvoid main()\n{\n\n    gl_FragColor.rgb = color;\n    gl_FragColor.a = ( 1.0-edgeFactor(lineWidth) ) * alpha;\n}\n\n@end';});

define('qtek/shader/source/skybox.essl',[],function () { return '@export buildin.skybox.vertex\n\nuniform mat4 world : WORLD;\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\n\nattribute vec3 position : POSITION;\n\nvarying vec3 v_WorldPosition;\n\nvoid main()\n{\n    v_WorldPosition = (world * vec4(position, 1.0)).xyz;\n    gl_Position = worldViewProjection * vec4(position, 1.0);\n}\n\n@end\n\n@export buildin.skybox.fragment\n\nuniform mat4 viewInverse : VIEWINVERSE;\nuniform samplerCube environmentMap;\n\nvarying vec3 v_WorldPosition;\n\nvoid main()\n{\n    vec3 eyePos = viewInverse[3].xyz;\n    vec3 viewDirection = normalize(v_WorldPosition - eyePos);\n\n    vec3 tex = textureCube(environmentMap, viewDirection).xyz;\n\n    #ifdef SRGB_DECODE\n        tex.rgb = pow(tex.rgb, vec3(2.2));\n    #endif\n    \n    gl_FragColor = vec4(tex, 1.0);\n}\n@end';});

define('qtek/shader/source/util.essl',[],function () { return '// Use light attenuation formula in\n// http://blog.slindev.com/2011/01/10/natural-light-attenuation/\n@export buildin.util.calculate_attenuation\n\nuniform float attenuationFactor : 5.0;\n\nfloat lightAttenuation(float dist, float range)\n{\n    float attenuation = 1.0;\n    if( range > 0.0)\n    {\n        attenuation = dist*dist/(range*range);\n        float att_s = attenuationFactor;\n        attenuation = 1.0/(attenuation*att_s+1.0);\n        att_s = 1.0/(att_s+1.0);\n        attenuation = attenuation - att_s;\n        attenuation /= 1.0 - att_s;\n    }\n    return attenuation;\n}\n\n@end\n\n//http://codeflow.org/entries/2012/aug/02/easy-wireframe-display-with-barycentric-coordinates/\n@export buildin.util.edge_factor\n\nfloat edgeFactor(float width)\n{\n    vec3 d = fwidth(v_Barycentric);\n    vec3 a3 = smoothstep(vec3(0.0), d * width, v_Barycentric);\n    return min(min(a3.x, a3.y), a3.z);\n}\n\n@end\n\n// Pack depth\n// Float value can only be [0.0 - 1.0) ?\n@export buildin.util.encode_float\nvec4 encodeFloat( const in float depth )\n{\n\n    const vec4 bitShifts = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n\n    const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n    vec4 res = fract( depth * bitShifts );\n    res -= res.xxyz * bit_mask;\n\n    return res;\n}\n@end\n\n@export buildin.util.decode_float\nfloat decodeFloat(const in vec4 colour)\n{\n    const vec4 bitShifts = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n    return dot(colour, bitShifts);\n}\n@end\n\n// http://graphicrants.blogspot.com/2009/04/rgbm-color-encoding.html\n@export buildin.util.rgbm_decode\nvec3 RGBMDecode(vec4 rgbm, float range) {\n  return range * rgbm.rgb * rgbm.a;\n}\n@end\n\n@export buildin.util.rgbm_encode\nvec4 RGBMEncode(vec3 color, float range) {\n    vec4 rgbm;\n    color *= 1.0 / range;\n    rgbm.a = clamp(max(max(color.r, color.g), max(color.b, 1e-6 ) ), 0.0, 1.0);\n    rgbm.a = ceil(rgbm.a * 255.0) / 255.0;\n    rgbm.rgb = color / rgbm.a;\n    return rgbm;\n}\n@end\n\n\n@export buildin.chunk.skin_matrix\n\n// Weighted Sum Skinning Matrix\nmat4 skinMatrixWS;\nif (joint.x >= 0.0)\n{\n    skinMatrixWS = skinMatrix[int(joint.x)] * weight.x;\n}\nif (joint.y >= 0.0)\n{\n    skinMatrixWS += skinMatrix[int(joint.y)] * weight.y;\n}\nif (joint.z >= 0.0)\n{\n    skinMatrixWS += skinMatrix[int(joint.z)] * weight.z;\n}\nif (joint.w >= 0.0)\n{\n    skinMatrixWS += skinMatrix[int(joint.w)] * (1.0-weight.x-weight.y-weight.z);\n}\n@end\n';});

define('qtek/shader/source/prez.essl',[],function () { return '// Shader for prez pass\n@export buildin.prez.vertex\n\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\n\nattribute vec3 position : POSITION;\n\n#ifdef SKINNING\nattribute vec3 weight : WEIGHT;\nattribute vec4 joint : JOINT;\n\nuniform mat4 skinMatrix[JOINT_NUMBER] : SKIN_MATRIX;\n#endif\n\nvoid main()\n{\n\n    vec3 skinnedPosition = position;\n\n    #ifdef SKINNING\n        \n        @import buildin.chunk.skin_matrix\n        \n        skinnedPosition = (skinMatrixWS * vec4(position, 1.0)).xyz;\n    #endif\n    \n    gl_Position = worldViewProjection * vec4(skinnedPosition, 1.0);\n}\n\n@end\n\n\n@export buildin.prez.fragment\n\nvoid main()\n{\n    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n\n@end';});

define('qtek/shader/source/shadowmap.essl',[],function () { return '\n@export buildin.sm.depth.vertex\n\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\n\nattribute vec3 position : POSITION;\n\n#ifdef SHADOW_TRANSPARENT \nattribute vec2 texcoord : TEXCOORD_0;\n#endif\n\n#ifdef SKINNING\nattribute vec3 weight : WEIGHT;\nattribute vec4 joint : JOINT;\n\nuniform mat4 skinMatrix[JOINT_NUMBER] : SKIN_MATRIX;\n#endif\n\nvarying vec4 v_ViewPosition;\n\n#ifdef SHADOW_TRANSPARENT\nvarying vec2 v_Texcoord;\n#endif\n\nvoid main(){\n    \n    vec3 skinnedPosition = position;\n    \n    #ifdef SKINNING\n\n        @import buildin.chunk.skin_matrix\n\n        skinnedPosition = (skinMatrixWS * vec4(position, 1.0)).xyz;\n    #endif\n\n    v_ViewPosition = worldViewProjection * vec4(skinnedPosition, 1.0);\n    gl_Position = v_ViewPosition;\n\n    #ifdef SHADOW_TRANSPARENT\n        v_Texcoord = texcoord;\n    #endif\n}\n@end\n\n@export buildin.sm.depth.fragment\n\nvarying vec4 v_ViewPosition;\n\n#ifdef SHADOW_TRANSPARENT\nvarying vec2 v_Texcoord;\n#endif\n\nuniform float bias : 0.001;\nuniform float slopeScale : 1.0;\n\n#ifdef SHADOW_TRANSPARENT\nuniform sampler2D transparentMap;\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\n@import buildin.util.encode_float\n\nvoid main(){\n    // Whats the difference between gl_FragCoord.z and this v_ViewPosition\n    // gl_FragCoord consider the polygon offset ?\n    float depth = v_ViewPosition.z / v_ViewPosition.w;\n    // float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n    #ifdef USE_VSM\n        depth = depth * 0.5 + 0.5;\n        float moment1 = depth;\n        float moment2 = depth * depth;\n\n        // Adjusting moments using partial derivative\n        float dx = dFdx(depth);\n        float dy = dFdy(depth);\n        moment2 += 0.25*(dx*dx+dy*dy);\n\n        gl_FragColor = vec4(moment1, moment2, 0.0, 1.0);\n    #else\n        // Add slope scaled bias using partial derivative\n        float dx = dFdx(depth);\n        float dy = dFdy(depth);\n        depth += sqrt(dx*dx + dy*dy) * slopeScale + bias;\n\n        #ifdef SHADOW_TRANSPARENT\n            if (texture2D(transparentMap, v_Texcoord).a <= 0.1) {\n                // Hi-Z\n                gl_FragColor = encodeFloat(0.9999);\n                return;\n            }\n        #endif\n\n        gl_FragColor = encodeFloat(depth * 0.5 + 0.5);\n    #endif\n}\n@end\n\n@export buildin.sm.debug_depth\n\nuniform sampler2D depthMap;\nvarying vec2 v_Texcoord;\n\n@import buildin.util.decode_float\n\nvoid main() {\n    vec4 tex = texture2D(depthMap, v_Texcoord);\n    #ifdef USE_VSM\n        gl_FragColor = vec4(tex.rgb, 1.0);\n    #else\n        float depth = decodeFloat(tex);\n        gl_FragColor = vec4(depth, depth, depth, 1.0);\n    #endif\n}\n\n@end\n\n\n@export buildin.sm.distance.vertex\n\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\nuniform mat4 world : WORLD;\n\nattribute vec3 position : POSITION;\n\n#ifdef SKINNING\nattribute vec3 boneWeight;\nattribute vec4 boneIndex;\n\nuniform mat4 skinMatrix[JOINT_NUMBER] : SKIN_MATRIX;\n#endif\n\nvarying vec3 v_WorldPosition;\n\nvoid main(){\n\n    vec3 skinnedPosition = position;\n    #ifdef SKINNING\n        @import buildin.chunk.skin_matrix\n\n        skinnedPosition = (skinMatrixWS * vec4(position, 1.0)).xyz;\n    #endif\n\n    gl_Position = worldViewProjection * vec4(skinnedPosition , 1.0);\n    v_WorldPosition = (world * vec4(skinnedPosition, 1.0)).xyz;\n}\n\n@end\n\n@export buildin.sm.distance.fragment\n\nuniform vec3 lightPosition;\nuniform float range : 100;\n\nvarying vec3 v_WorldPosition;\n\n@import buildin.util.encode_float\n\nvoid main(){\n    float dist = distance(lightPosition, v_WorldPosition);\n    #ifdef USE_VSM\n        gl_FragColor = vec4(dist, dist * dist, 0.0, 0.0);\n    #else\n        dist = dist / range;\n        gl_FragColor = encodeFloat(dist);\n    #endif\n}\n@end\n\n@export buildin.plugin.compute_shadow_map\n\n#if defined(SPOT_LIGHT_SHADOWMAP_NUMBER) || defined(DIRECTIONAL_LIGHT_SHADOWMAP_NUMBER) || defined(POINT_LIGHT_SHADOWMAP_NUMBER)\n\n#ifdef SPOT_LIGHT_SHADOWMAP_NUMBER\nuniform sampler2D spotLightShadowMaps[SPOT_LIGHT_SHADOWMAP_NUMBER];\nuniform mat4 spotLightMatrices[SPOT_LIGHT_SHADOWMAP_NUMBER];\n#endif\n\n#ifdef DIRECTIONAL_LIGHT_SHADOWMAP_NUMBER\n#if defined(SHADOW_CASCADE)\nuniform sampler2D directionalLightShadowMaps[SHADOW_CASCADE];\nuniform mat4 directionalLightMatrices[SHADOW_CASCADE];\nuniform float shadowCascadeClipsNear[SHADOW_CASCADE];\nuniform float shadowCascadeClipsFar[SHADOW_CASCADE];\n#else\nuniform sampler2D directionalLightShadowMaps[DIRECTIONAL_LIGHT_SHADOWMAP_NUMBER];\nuniform mat4 directionalLightMatrices[DIRECTIONAL_LIGHT_SHADOWMAP_NUMBER];\n#endif\n#endif\n\n#ifdef POINT_LIGHT_SHADOWMAP_NUMBER\nuniform samplerCube pointLightShadowMaps[POINT_LIGHT_SHADOWMAP_NUMBER];\nuniform float pointLightRanges[POINT_LIGHT_SHADOWMAP_NUMBER];\n#endif\n\nuniform bool shadowEnabled : true;\n\n@import buildin.util.decode_float\n\n#if defined(DIRECTIONAL_LIGHT_NUMBER) || defined(SPOT_LIGHT_SHADOWMAP_NUMBER)\n\nfloat tapShadowMap(sampler2D map, vec2 uv, float z){\n    vec4 tex = texture2D(map, uv);\n    return decodeFloat(tex) * 2.0 - 1.0< z ? 0.0 : 1.0;\n}\n\nfloat pcf(sampler2D map, vec2 uv, float z){\n\n    float shadowContrib = tapShadowMap(map, uv, z);\n    float offset = 1.0 / 2048.0;\n    shadowContrib += tapShadowMap(map, uv+vec2(offset, 0.0), z);\n    shadowContrib += tapShadowMap(map, uv+vec2(offset, offset), z);\n    shadowContrib += tapShadowMap(map, uv+vec2(-offset, offset), z);\n    shadowContrib += tapShadowMap(map, uv+vec2(0.0, offset), z);\n    shadowContrib += tapShadowMap(map, uv+vec2(-offset, 0.0), z);\n    shadowContrib += tapShadowMap(map, uv+vec2(-offset, -offset), z);\n    shadowContrib += tapShadowMap(map, uv+vec2(offset, -offset), z);\n    shadowContrib += tapShadowMap(map, uv+vec2(0.0, -offset), z);\n\n    return shadowContrib / 9.0;\n}\nfloat chebyshevUpperBound(vec2 moments, float z){\n    float p = 0.0;\n    z = z * 0.5 + 0.5;\n    if (z <= moments.x) {\n        p = 1.0;\n    }\n    float variance = moments.y - moments.x * moments.x;\n    // http://fabiensanglard.net/shadowmappingVSM/\n    variance = max(variance, 0.0000001);\n    // Compute probabilistic upper bound. \n    float mD = moments.x - z;\n    float pMax = variance / (variance + mD * mD);\n    // Now reduce light-bleeding by removing the [0, x] tail and linearly rescaling (x, 1]\n    // TODO : bleedBias parameter ?\n    pMax = clamp((pMax-0.4)/(1.0-0.4), 0.0, 1.0);\n    return max(p, pMax);\n}\nfloat computeShadowContrib(sampler2D map, mat4 lightVPM, vec3 position){\n    \n    vec4 posInLightSpace = lightVPM * vec4(v_WorldPosition, 1.0);\n    posInLightSpace.xyz /= posInLightSpace.w;\n    float z = posInLightSpace.z;\n    // In frustum\n    if(all(greaterThan(posInLightSpace.xyz, vec3(-0.99, -0.99, -1.0))) &&\n        all(lessThan(posInLightSpace.xyz, vec3(0.99, 0.99, 1.0)))){\n        // To texture uv\n        vec2 uv = (posInLightSpace.xy+1.0) / 2.0;\n\n        #ifdef USE_VSM\n            vec2 moments = texture2D(map, uv).xy;\n            return chebyshevUpperBound(moments, z);\n        #else\n            return pcf(map, uv, z);\n        #endif\n    }\n    return 1.0;\n}\n\n#endif\n\n#ifdef POINT_LIGHT_SHADOWMAP_NUMBER\n\nfloat computeShadowOfCube(samplerCube map, vec3 direction, float range){\n    vec4 shadowTex = textureCube(map, direction);\n    float dist = length(direction);\n\n    #ifdef USE_VSM\n        vec2 moments = shadowTex.xy;\n        float variance = moments.y - moments.x * moments.x;\n        float mD = moments.x - dist;\n        float p = variance / (variance + mD * mD);\n        if(moments.x + 0.001 < dist){\n            return clamp(p, 0.0, 1.0);\n        }else{\n            return 1.0;\n        }\n    #else\n        if((decodeFloat(shadowTex) + 0.0002) * range < dist){\n            return 0.0;\n        }else{\n            return 1.0;\n        }\n    #endif\n}\n#endif\n\n#if defined(SPOT_LIGHT_SHADOWMAP_NUMBER)\n\nvoid computeShadowOfSpotLights(vec3 position, inout float shadowContribs[SPOT_LIGHT_NUMBER] ){\n    for(int i = 0; i < SPOT_LIGHT_SHADOWMAP_NUMBER; i++){\n        float shadowContrib = computeShadowContrib(spotLightShadowMaps[i], spotLightMatrices[i], position);\n        shadowContribs[i] = shadowContrib;\n    }\n    // set default fallof of rest lights\n    for(int i = SPOT_LIGHT_SHADOWMAP_NUMBER; i < SPOT_LIGHT_NUMBER; i++){\n        shadowContribs[i] = 1.0;\n    }\n}\n\n#endif\n\n\n#if defined(DIRECTIONAL_LIGHT_SHADOWMAP_NUMBER)\n\n#ifdef SHADOW_CASCADE\n\nvoid computeShadowOfDirectionalLights(vec3 position, inout float shadowContribs[DIRECTIONAL_LIGHT_NUMBER]){\n    // http://www.opengl.org/wiki/Compute_eye_space_from_window_space\n    float depth = (2.0 * gl_FragCoord.z - gl_DepthRange.near - gl_DepthRange.far)\n                    / (gl_DepthRange.far - gl_DepthRange.near);\n\n    for (int i = 0; i < SHADOW_CASCADE; i++) {\n        if (\n            depth >= shadowCascadeClipsNear[i] &&\n            depth <= shadowCascadeClipsFar[i]\n        ) {\n            float shadowContrib = computeShadowContrib(directionalLightShadowMaps[i], directionalLightMatrices[i], position);\n            // TODO Will get a sampler needs to be be uniform error in native gl\n            shadowContribs[0] = shadowContrib;\n        }\n    }\n    // set default fallof of rest lights\n    for(int i = DIRECTIONAL_LIGHT_SHADOWMAP_NUMBER; i < DIRECTIONAL_LIGHT_NUMBER; i++){\n        shadowContribs[i] = 1.0;\n    }\n}\n\n#else\n\nvoid computeShadowOfDirectionalLights(vec3 position, inout float shadowContribs[DIRECTIONAL_LIGHT_NUMBER]){\n    for(int i = 0; i < DIRECTIONAL_LIGHT_SHADOWMAP_NUMBER; i++){\n        float shadowContrib = computeShadowContrib(directionalLightShadowMaps[i], directionalLightMatrices[i], position);\n        shadowContribs[i] = shadowContrib;\n    }\n    // set default fallof of rest lights\n    for(int i = DIRECTIONAL_LIGHT_SHADOWMAP_NUMBER; i < DIRECTIONAL_LIGHT_NUMBER; i++){\n        shadowContribs[i] = 1.0;\n    }\n}\n#endif\n\n#endif\n\n\n#if defined(POINT_LIGHT_SHADOWMAP_NUMBER)\n\nvoid computeShadowOfPointLights(vec3 position, inout float shadowContribs[POINT_LIGHT_NUMBER] ){\n    for(int i = 0; i < POINT_LIGHT_SHADOWMAP_NUMBER; i++){\n        vec3 lightPosition = pointLightPosition[i];\n        vec3 direction = position - lightPosition;\n        shadowContribs[i] = computeShadowOfCube(pointLightShadowMaps[i], direction, pointLightRanges[i]);\n    }\n    for(int i = POINT_LIGHT_SHADOWMAP_NUMBER; i < POINT_LIGHT_NUMBER; i++){\n        shadowContribs[i] = 1.0;\n    }\n}\n\n#endif\n\n#endif\n\n@end';});

define('qtek/shader/source/compositor/vertex.essl',[],function () { return '\n@export buildin.compositor.vertex\n\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\n\nattribute vec3 position : POSITION;\nattribute vec2 texcoord : TEXCOORD_0;\n\nvarying vec2 v_Texcoord;\n\nvoid main()\n{\n    v_Texcoord = texcoord;\n    gl_Position = worldViewProjection * vec4(position, 1.0);\n}\n\n@end';});

define('qtek/shader/source/compositor/coloradjust.essl',[],function () { return '@export buildin.compositor.coloradjust\n\nvarying vec2 v_Texcoord;\nuniform sampler2D texture;\n\nuniform float brightness : 0.0;\nuniform float contrast : 1.0;\nuniform float exposure : 0.0;\nuniform float gamma : 1.0;\nuniform float saturation : 1.0;\n\n// Values from "Graphics Shaders: Theory and Practice" by Bailey and Cunningham\nconst vec3 w = vec3(0.2125, 0.7154, 0.0721);\n\nvoid main()\n{\n    vec4 tex = texture2D( texture, v_Texcoord);\n\n    // brightness\n    vec3 color = clamp(tex.rgb + vec3(brightness), 0.0, 1.0);\n    // contrast\n    color = clamp( (color-vec3(0.5))*contrast+vec3(0.5), 0.0, 1.0);\n    // exposure\n    color = clamp( color * pow(2.0, exposure), 0.0, 1.0);\n    // gamma\n    color = clamp( pow(color, vec3(gamma)), 0.0, 1.0);\n    // saturation\n    float luminance = dot( color, w );\n    color = mix(vec3(luminance), color, saturation);\n    \n    gl_FragColor = vec4(color, tex.a);\n}\n\n@end\n\n// Seperate shader for float texture\n@export buildin.compositor.brightness\nvarying vec2 v_Texcoord;\nuniform sampler2D texture;\n\nuniform float brightness : 0.0;\n\nvoid main()\n{\n    vec4 tex = texture2D( texture, v_Texcoord);\n    vec3 color = tex.rgb + vec3(brightness);\n    gl_FragColor = vec4(color, tex.a);\n}\n@end\n\n@export buildin.compositor.contrast\nvarying vec2 v_Texcoord;\nuniform sampler2D texture;\n\nuniform float contrast : 1.0;\n\nvoid main()\n{\n    vec4 tex = texture2D( texture, v_Texcoord);\n    vec3 color = (tex.rgb-vec3(0.5))*contrast+vec3(0.5);\n    gl_FragColor = vec4(color, tex.a);\n}\n@end\n\n@export buildin.compositor.exposure\nvarying vec2 v_Texcoord;\nuniform sampler2D texture;\n\nuniform float exposure : 0.0;\n\nvoid main()\n{\n    vec4 tex = texture2D(texture, v_Texcoord);\n    vec3 color = tex.rgb * pow(2.0, exposure);\n    gl_FragColor = vec4(color, tex.a);\n}\n@end\n\n@export buildin.compositor.gamma\nvarying vec2 v_Texcoord;\nuniform sampler2D texture;\n\nuniform float gamma : 1.0;\n\nvoid main()\n{\n    vec4 tex = texture2D(texture, v_Texcoord);\n    vec3 color = pow(tex.rgb, vec3(gamma));\n    gl_FragColor = vec4(color, tex.a);\n}\n@end\n\n@export buildin.compositor.saturation\nvarying vec2 v_Texcoord;\nuniform sampler2D texture;\n\nuniform float saturation : 1.0;\n\nconst vec3 w = vec3(0.2125, 0.7154, 0.0721);\n\nvoid main()\n{\n    vec4 tex = texture2D(texture, v_Texcoord);\n    vec3 color = tex.rgb;\n    float luminance = dot(color, w);\n    color = mix(vec3(luminance), color, saturation);\n    gl_FragColor = vec4(color, tex.a);\n}\n@end';});

define('qtek/shader/source/compositor/blur.essl',[],function () { return '@export buildin.compositor.gaussian_blur_h\n\nuniform sampler2D texture; // the texture with the scene you want to blur\nvarying vec2 v_Texcoord;\n \nuniform float blurSize : 2.0; \nuniform float textureWidth : 512.0;\n\nvoid main(void)\n{\n   vec4 sum = vec4(0.0);\n   float blurOffset = blurSize / textureWidth;\n   // blur in y (vertical)\n   // take nine samples, with the distance blurSize between them\n   sum += texture2D(texture, vec2(max(v_Texcoord.x - 4.0*blurOffset, 0.0), v_Texcoord.y)) * 0.05;\n   sum += texture2D(texture, vec2(max(v_Texcoord.x - 3.0*blurOffset, 0.0), v_Texcoord.y)) * 0.09;\n   sum += texture2D(texture, vec2(max(v_Texcoord.x - 2.0*blurOffset, 0.0), v_Texcoord.y)) * 0.12;\n   sum += texture2D(texture, vec2(max(v_Texcoord.x - blurOffset, 0.0), v_Texcoord.y)) * 0.15;\n   sum += texture2D(texture, vec2(v_Texcoord.x, v_Texcoord.y)) * 0.18;\n   sum += texture2D(texture, vec2(min(v_Texcoord.x + blurOffset, 1.0), v_Texcoord.y)) * 0.15;\n   sum += texture2D(texture, vec2(min(v_Texcoord.x + 2.0*blurOffset, 1.0), v_Texcoord.y)) * 0.12;\n   sum += texture2D(texture, vec2(min(v_Texcoord.x + 3.0*blurOffset, 1.0), v_Texcoord.y)) * 0.09;\n   sum += texture2D(texture, vec2(min(v_Texcoord.x + 4.0*blurOffset, 1.0), v_Texcoord.y)) * 0.05;\n \n   gl_FragColor = sum;\n}\n\n@end\n\n@export buildin.compositor.gaussian_blur_v\n\nuniform sampler2D texture;\nvarying vec2 v_Texcoord;\n \nuniform float blurSize : 2.0;\nuniform float textureHeight : 512.0;\n \nvoid main(void)\n{\n   vec4 sum = vec4(0.0);\n   float blurOffset = blurSize / textureHeight;\n   // blur in y (vertical)\n   // take nine samples, with the distance blurSize between them\n   sum += texture2D(texture, vec2(v_Texcoord.x, max(v_Texcoord.y - 4.0*blurOffset, 0.0))) * 0.05;\n   sum += texture2D(texture, vec2(v_Texcoord.x, max(v_Texcoord.y - 3.0*blurOffset, 0.0))) * 0.09;\n   sum += texture2D(texture, vec2(v_Texcoord.x, max(v_Texcoord.y - 2.0*blurOffset, 0.0))) * 0.12;\n   sum += texture2D(texture, vec2(v_Texcoord.x, max(v_Texcoord.y - blurOffset, 0.0))) * 0.15;\n   sum += texture2D(texture, vec2(v_Texcoord.x, v_Texcoord.y)) * 0.18;\n   sum += texture2D(texture, vec2(v_Texcoord.x, min(v_Texcoord.y + blurOffset, 1.0))) * 0.15;\n   sum += texture2D(texture, vec2(v_Texcoord.x, min(v_Texcoord.y + 2.0*blurOffset, 1.0))) * 0.12;\n   sum += texture2D(texture, vec2(v_Texcoord.x, min(v_Texcoord.y + 3.0*blurOffset, 1.0))) * 0.09;\n   sum += texture2D(texture, vec2(v_Texcoord.x, min(v_Texcoord.y + 4.0*blurOffset, 1.0))) * 0.05;\n \n   gl_FragColor = sum;\n}\n\n@end\n\n@export buildin.compositor.box_blur\n\nuniform sampler2D texture;\nvarying vec2 v_Texcoord;\n\nuniform float blurSize : 3.0;\nuniform vec2 textureSize : [512.0, 512.0];\n\nvoid main(void){\n\n   vec4 tex = texture2D(texture, v_Texcoord);\n   vec2 offset = blurSize / textureSize;\n\n   tex += texture2D(texture, v_Texcoord + vec2(offset.x, 0.0) );\n   tex += texture2D(texture, v_Texcoord + vec2(offset.x, offset.y) );\n   tex += texture2D(texture, v_Texcoord + vec2(-offset.x, offset.y) );\n   tex += texture2D(texture, v_Texcoord + vec2(0.0, offset.y) );\n   tex += texture2D(texture, v_Texcoord + vec2(-offset.x, 0.0) );\n   tex += texture2D(texture, v_Texcoord + vec2(-offset.x, -offset.y) );\n   tex += texture2D(texture, v_Texcoord + vec2(offset.x, -offset.y) );\n   tex += texture2D(texture, v_Texcoord + vec2(0.0, -offset.y) );\n\n   tex /= 9.0;\n\n   gl_FragColor = tex;\n}\n\n@end\n\n// http://www.slideshare.net/DICEStudio/five-rendering-ideas-from-battlefield-3-need-for-speed-the-run\n@export buildin.compositor.hexagonal_blur_mrt_1\n\n// MRT in chrome\n// https://www.khronos.org/registry/webgl/sdk/tests/conformance/extensions/webgl-draw-buffers.html\n#extension GL_EXT_draw_buffers : require\n\nuniform sampler2D texture;\nvarying vec2 v_Texcoord;\n\nuniform float blurSize : 2.0;\n\nuniform vec2 textureSize : [512.0, 512.0];\n\nvoid main(void){\n   vec2 offset = blurSize / textureSize;\n\n   vec4 color = vec4(0.0);\n   // Top\n   for(int i = 0; i < 10; i++){\n      color += 1.0/10.0 * texture2D(texture, v_Texcoord + vec2(0.0, offset.y * float(i)) );\n   }\n   gl_FragData[0] = color;\n   vec4 color2 = vec4(0.0);\n   // Down left\n   for(int i = 0; i < 10; i++){\n      color2 += 1.0/10.0 * texture2D(texture, v_Texcoord - vec2(offset.x * float(i), offset.y * float(i)) );\n   }\n   gl_FragData[1] = (color + color2) / 2.0;\n}\n\n@end\n\n@export buildin.compositor.hexagonal_blur_mrt_2\n\nuniform sampler2D texture0;\nuniform sampler2D texture1;\n\nvarying vec2 v_Texcoord;\n\nuniform float blurSize : 2.0;\n\nuniform vec2 textureSize : [512.0, 512.0];\n\nvoid main(void){\n   vec2 offset = blurSize / textureSize;\n\n   vec4 color1 = vec4(0.0);\n   // Down left\n   for(int i = 0; i < 10; i++){\n      color1 += 1.0/10.0 * texture2D(texture0, v_Texcoord - vec2(offset.x * float(i), offset.y * float(i)) );\n   }\n   vec4 color2 = vec4(0.0);\n   // Down right\n   for(int i = 0; i < 10; i++){\n      color2 += 1.0/10.0 * texture2D(texture1, v_Texcoord + vec2(offset.x * float(i), -offset.y * float(i)) );\n   }\n\n   gl_FragColor = (color1 + color2) / 2.0;\n}\n\n@end\n\n\n@export buildin.compositor.hexagonal_blur_1\n\n#define KERNEL_SIZE 10\n\nuniform sampler2D texture;\nvarying vec2 v_Texcoord;\n\nuniform float blurSize : 1.0;\n\nuniform vec2 textureSize : [512.0, 512.0];\n\nvoid main(void){\n   vec2 offset = blurSize / textureSize;\n\n   vec4 color = vec4(0.0);\n   float fKernelSize = float(KERNEL_SIZE);\n   // Top\n   for(int i = 0; i < KERNEL_SIZE; i++){\n      color += 1.0 / fKernelSize * texture2D(texture, v_Texcoord + vec2(0.0, offset.y * float(i)) );\n   }\n   gl_FragColor = color;\n}\n\n@end\n\n@export buildin.compositor.hexagonal_blur_2\n\n#define KERNEL_SIZE 10\n\nuniform sampler2D texture;\nvarying vec2 v_Texcoord;\n\nuniform float blurSize : 1.0;\n\nuniform vec2 textureSize : [512.0, 512.0];\n\nvoid main(void){\n   vec2 offset = blurSize / textureSize;\n   offset.y /= 2.0;\n\n   vec4 color = vec4(0.0);\n   float fKernelSize = float(KERNEL_SIZE);\n   // Down left\n   for(int i = 0; i < KERNEL_SIZE; i++){\n      color += 1.0/fKernelSize * texture2D(texture, v_Texcoord - vec2(offset.x * float(i), offset.y * float(i)) );\n   }\n   gl_FragColor = color;\n}\n@end\n\n@export buildin.compositor.hexagonal_blur_3\n\n#define KERNEL_SIZE 10\n\nuniform sampler2D texture1;\nuniform sampler2D texture2;\n\nvarying vec2 v_Texcoord;\n\nuniform float blurSize : 1.0;\n\nuniform vec2 textureSize : [512.0, 512.0];\n\nvoid main(void){\n   vec2 offset = blurSize / textureSize;\n   offset.y /= 2.0;\n\n   vec4 color1 = vec4(0.0);\n   float fKernelSize = float(KERNEL_SIZE);\n   // Down left\n   for(int i = 0; i < KERNEL_SIZE; i++){\n      color1 += 1.0/fKernelSize * texture2D(texture1, v_Texcoord - vec2(offset.x * float(i), offset.y * float(i)) );\n   }\n   vec4 color2 = vec4(0.0);\n   // Down right\n   for(int i = 0; i < KERNEL_SIZE; i++){\n      color2 += 1.0/fKernelSize * texture2D(texture1, v_Texcoord + vec2(offset.x * float(i), -offset.y * float(i)) );\n   }\n\n   vec4 color3 = vec4(0.0);\n   // Down right\n   for(int i = 0; i < KERNEL_SIZE; i++){\n      color3 += 1.0/fKernelSize * texture2D(texture2, v_Texcoord + vec2(offset.x * float(i), -offset.y * float(i)) );\n   }\n\n   gl_FragColor = (color1 + color2 + color3) / 3.0;\n}\n\n@end';});

define('qtek/shader/source/compositor/lum.essl',[],function () { return '\n@export buildin.compositor.lum\n\nvarying vec2 v_Texcoord;\n\nuniform sampler2D texture;\n\nconst vec3 w = vec3(0.2125, 0.7154, 0.0721);\n\nvoid main()\n{\n    vec4 tex = texture2D( texture, v_Texcoord );\n    float luminance = dot(tex.rgb, w);\n\n    gl_FragColor = vec4(vec3(luminance), 1.0);\n}\n\n@end';});

define('qtek/shader/source/compositor/lut.essl',[],function () { return '\n// https://github.com/BradLarson/GPUImage?source=c\n@export buildin.compositor.lut\n\nvarying vec2 v_Texcoord;\n\nuniform sampler2D texture;\nuniform sampler2D lookup;\n\nvoid main()\n{\n    vec4 tex = texture2D(texture, v_Texcoord);\n\n    float blueColor = tex.b * 63.0;\n    \n    vec2 quad1;\n    quad1.y = floor(floor(blueColor) / 8.0);\n    quad1.x = floor(blueColor) - (quad1.y * 8.0);\n    \n    vec2 quad2;\n    quad2.y = floor(ceil(blueColor) / 8.0);\n    quad2.x = ceil(blueColor) - (quad2.y * 8.0);\n    \n    vec2 texPos1;\n    texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * tex.r);\n    texPos1.y = (quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * tex.g);\n    \n    vec2 texPos2;\n    texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * tex.r);\n    texPos2.y = (quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * tex.g);\n    \n    vec4 newColor1 = texture2D(lookup, texPos1);\n    vec4 newColor2 = texture2D(lookup, texPos2);\n    \n    vec4 newColor = mix(newColor1, newColor2, fract(blueColor));\n    gl_FragColor = vec4(newColor.rgb, tex.w);\n}\n\n@end';});

define('qtek/shader/source/compositor/output.essl',[],function () { return '@export buildin.compositor.output\n\n#define OUTPUT_ALPHA;\n\nvarying vec2 v_Texcoord;\n\nuniform sampler2D texture;\n\nvoid main()\n{\n    vec4 tex = texture2D(texture, v_Texcoord);\n\n    gl_FragColor.rgb = tex.rgb;\n\n    #ifdef OUTPUT_ALPHA\n        gl_FragColor.a = tex.a;\n    #else\n        gl_FragColor.a = 1.0;\n    #endif\n\n}\n\n@end';});

define('qtek/shader/source/compositor/hdr.essl',[],function () { return '// HDR Pipeline\n@export buildin.compositor.hdr.bright\n\nuniform sampler2D texture;\nuniform float threshold : 1;\nuniform float scale : 1.0;\n\nvarying vec2 v_Texcoord;\n\nconst vec3 lumWeight = vec3(0.2125, 0.7154, 0.0721);\n\n@import buildin.util.rgbm_decode\n@import buildin.util.rgbm_encode\n\nvoid main()\n{\n    #ifdef TEXTURE_ENABLED\n        #ifdef RGBM_DECODE\n            vec3 tex = RGBMDecode(texture2D(texture, v_Texcoord));\n        #else\n            vec3 tex = texture2D(texture, v_Texcoord).rgb;\n        #endif\n    #else\n        vec3 tex = vec3(0.0);\n    #endif\n\n    float lum = dot(tex, lumWeight);\n    if (lum > threshold)\n    {\n        gl_FragColor.rgb = tex * scale;\n    }\n    else\n    {\n        gl_FragColor.rgb = vec3(0.0);\n    }\n    gl_FragColor.a = 1.0;\n\n    #ifdef RGBM_ENCODE\n        gl_FragColor.rgba = RGBMEncode(gl_FragColor.rgb);\n    #endif\n}\n@end\n\n@export buildin.compositor.hdr.log_lum\n\nvarying vec2 v_Texcoord;\n\nuniform sampler2D texture;\n\nconst vec3 w = vec3(0.2125, 0.7154, 0.0721);\n\nvoid main()\n{\n    vec4 tex = texture2D(texture, v_Texcoord);\n    float luminance = dot(tex.rgb, w);\n    luminance = log(luminance + 0.001);\n\n    gl_FragColor = vec4(vec3(luminance), 1.0);\n}\n\n@end\n\n@export buildin.compositor.hdr.lum_adaption\nvarying vec2 v_Texcoord;\n\nuniform sampler2D adaptedLum;\nuniform sampler2D currentLum;\n\nuniform float frameTime : 0.02;\n\nvoid main()\n{\n    float fAdaptedLum = texture2D(adaptedLum, vec2(0.5, 0.5)).r;\n    float fCurrentLum = exp(texture2D(currentLum, vec2(0.5, 0.5)).r);\n\n    fAdaptedLum += (fCurrentLum - fAdaptedLum) * (1.0 - pow(0.98, 30.0 * frameTime));\n    gl_FragColor.rgb = vec3(fAdaptedLum);\n    gl_FragColor.a = 1.0;\n}\n@end\n\n// Tone mapping with gamma correction\n// http://filmicgames.com/archives/75\n@export buildin.compositor.hdr.tonemapping\n\nuniform sampler2D texture;\nuniform sampler2D bloom;\nuniform sampler2D lensflare;\nuniform sampler2D lum;\n\nuniform float exposure : 1.0;\n\nvarying vec2 v_Texcoord;\n\nconst float A = 0.22;   // Shoulder Strength\nconst float B = 0.30;   // Linear Strength\nconst float C = 0.10;   // Linear Angle\nconst float D = 0.20;   // Toe Strength\nconst float E = 0.01;   // Toe Numerator\nconst float F = 0.30;   // Toe Denominator\nconst vec3 whiteScale = vec3(11.2);\n\nvec3 uncharted2ToneMap(vec3 x)\n{\n    return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\nvec3 filmicToneMap(vec3 color)\n{\n    vec3 x = max(vec3(0.0), color - 0.004);\n    return (x*(6.2*x+0.5))/(x*(6.2*x+1.7)+0.06);\n}\n\nfloat eyeAdaption(float fLum)\n{\n    return mix(0.2, fLum, 0.5);\n}\n\nvoid main()\n{\n    vec3 tex = vec3(0.0);\n    float a = 1.0;\n    #ifdef TEXTURE_ENABLED\n        vec4 res = texture2D(texture, v_Texcoord);\n        a = res.a;\n        tex = res.rgb;\n    #endif\n\n    #ifdef BLOOM_ENABLED\n        tex += texture2D(bloom, v_Texcoord).rgb * 0.25;\n    #endif\n\n    #ifdef LENSFLARE_ENABLED\n        tex += texture2D(lensflare, v_Texcoord).rgb;\n    #endif\n\n    // Adjust exposure\n    // From KlayGE\n    #ifdef LUM_ENABLED\n        float fLum = texture2D(lum, vec2(0.5, 0.5)).r;\n        float adaptedLumDest = 3.0 / (max(0.1, 1.0 + 10.0*eyeAdaption(fLum)));\n        float exposureBias = adaptedLumDest * exposure;\n    #else\n        float exposureBias = exposure;\n    #endif\n    tex *= exposureBias;\n\n    // Do tone mapping\n    vec3 color = uncharted2ToneMap(tex) / uncharted2ToneMap(whiteScale);\n    color = pow(color, vec3(1.0/2.2));\n    // vec3 color = filmicToneMap(tex);\n\n    #ifdef RGBM_ENCODE\n        gl_FragColor.rgba = RGBMEncode(color);\n    #else\n        gl_FragColor = vec4(color, a);\n    #endif\n}\n\n@end';});

define('qtek/shader/source/compositor/lensflare.essl',[],function () { return '// john-chapman-graphics.blogspot.co.uk/2013/02/pseudo-lens-flare.html\n@export buildin.compositor.lensflare\n\n#define SAMPLE_NUMBER 8\n\nuniform sampler2D texture;\nuniform sampler2D lensColor;\n\nuniform vec2 textureSize : [512, 512];\n\nuniform float dispersal : 0.3;\nuniform float haloWidth : 0.4;\nuniform float distortion : 1.0;\n\nvarying vec2 v_Texcoord;\n\nvec4 textureDistorted(\n    in vec2 texcoord,\n    in vec2 direction,\n    in vec3 distortion\n) {\n    return vec4(\n        texture2D(texture, texcoord + direction * distortion.r).r,\n        texture2D(texture, texcoord + direction * distortion.g).g,\n        texture2D(texture, texcoord + direction * distortion.b).b,\n        1.0\n    );\n}\n\nvoid main()\n{\n    vec2 texcoord = -v_Texcoord + vec2(1.0); // Flip texcoords\n    vec2 textureOffset = 1.0 / textureSize;\n\n    vec2 ghostVec = (vec2(0.5) - texcoord) * dispersal;\n    vec2 haloVec = normalize(ghostVec) * haloWidth;\n\n    vec3 distortion = vec3(-textureOffset.x * distortion, 0.0, textureOffset.x * distortion);\n    //Sample ghost\n    vec4 result = vec4(0.0);\n    for (int i = 0; i < SAMPLE_NUMBER; i++)\n    {\n        vec2 offset = fract(texcoord + ghostVec * float(i));\n\n        float weight = length(vec2(0.5) - offset) / length(vec2(0.5));\n        weight = pow(1.0 - weight, 10.0);\n\n        result += textureDistorted(offset, normalize(ghostVec), distortion) * weight;\n    }\n\n    result *= texture2D(lensColor, vec2(length(vec2(0.5) - texcoord)) / length(vec2(0.5)));\n    //Sample halo\n    float weight = length(vec2(0.5) - fract(texcoord + haloVec)) / length(vec2(0.5));\n    weight = pow(1.0 - weight, 10.0);\n    vec2 offset = fract(texcoord + haloVec);\n    result += textureDistorted(offset, normalize(ghostVec), distortion) * weight;\n\n    gl_FragColor = result;\n}\n@end';});

define('qtek/shader/source/compositor/blend.essl',[],function () { return '@export buildin.compositor.blend\n// Blend at most 4 textures\n#ifdef TEXTURE1_ENABLED\nuniform sampler2D texture1;\nuniform float weight1 : 1.0;\n#endif\n#ifdef TEXTURE2_ENABLED\nuniform sampler2D texture2;\nuniform float weight2 : 1.0;\n#endif\n#ifdef TEXTURE3_ENABLED\nuniform sampler2D texture3;\nuniform float weight3 : 1.0;\n#endif\n#ifdef TEXTURE4_ENABLED\nuniform sampler2D texture4;\nuniform float weight4 : 1.0;\n#endif\n\nvarying vec2 v_Texcoord;\n\nvoid main()\n{\n    vec3 tex = vec3(0.0);\n    #ifdef TEXTURE1_ENABLED\n        tex += texture2D(texture1, v_Texcoord).rgb * weight1;\n    #endif\n    #ifdef TEXTURE2_ENABLED\n        tex += texture2D(texture2, v_Texcoord).rgb * weight2;\n    #endif\n    #ifdef TEXTURE3_ENABLED\n        tex += texture2D(texture3, v_Texcoord).rgb * weight3;\n    #endif\n    #ifdef TEXTURE4_ENABLED\n        tex += texture2D(texture4, v_Texcoord).rgb * weight4;\n    #endif\n\n    gl_FragColor = vec4(tex, 1.0);\n}\n@end';});

define('qtek/shader/source/compositor/fxaa.essl',[],function () { return '// https://github.com/mitsuhiko/webgl-meincraft/blob/master/assets/shaders/fxaa.glsl\n@export buildin.compositor.fxaa\n\nuniform sampler2D texture;\nuniform vec2 viewportSize : [512, 512];\n\nvarying vec2 v_Texcoord;\n\n#define FXAA_REDUCE_MIN   (1.0/128.0)\n#define FXAA_REDUCE_MUL   (1.0/8.0)\n#define FXAA_SPAN_MAX     8.0\n\nvoid main()\n{\n    vec2 resolution = 1.0 / viewportSize;\n    vec3 rgbNW = texture2D( texture, ( gl_FragCoord.xy + vec2( -1.0, -1.0 ) ) * resolution ).xyz;\n    vec3 rgbNE = texture2D( texture, ( gl_FragCoord.xy + vec2( 1.0, -1.0 ) ) * resolution ).xyz;\n    vec3 rgbSW = texture2D( texture, ( gl_FragCoord.xy + vec2( -1.0, 1.0 ) ) * resolution ).xyz;\n    vec3 rgbSE = texture2D( texture, ( gl_FragCoord.xy + vec2( 1.0, 1.0 ) ) * resolution ).xyz;\n    vec4 rgbaM  = texture2D( texture,  gl_FragCoord.xy  * resolution );\n    vec3 rgbM  = rgbaM.xyz;\n    float opacity  = rgbaM.w;\n\n    vec3 luma = vec3( 0.299, 0.587, 0.114 );\n\n    float lumaNW = dot( rgbNW, luma );\n    float lumaNE = dot( rgbNE, luma );\n    float lumaSW = dot( rgbSW, luma );\n    float lumaSE = dot( rgbSE, luma );\n    float lumaM  = dot( rgbM,  luma );\n    float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );\n    float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );\n\n    float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );\n    dir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n          max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                dir * rcpDirMin)) * resolution;\n\n    vec3 rgbA = texture2D( texture, gl_FragCoord.xy  * resolution + dir * ( 1.0 / 3.0 - 0.5 ) ).xyz;\n    rgbA += texture2D( texture, gl_FragCoord.xy  * resolution + dir * ( 2.0 / 3.0 - 0.5 ) ).xyz;\n    rgbA *= 0.5;\n\n    vec3 rgbB = texture2D( texture, gl_FragCoord.xy  * resolution + dir * -0.5 ).xyz;\n    rgbB += texture2D( texture, gl_FragCoord.xy  * resolution + dir * 0.5 ).xyz;\n    rgbB *= 0.25;\n    rgbB += rgbA * 0.5;\n\n    float lumaB = dot( rgbB, luma );\n\n    if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) )\n    {\n\n        gl_FragColor = vec4( rgbA, opacity );\n\n    } else {\n\n        gl_FragColor = vec4( rgbB, opacity );\n\n    }\n}\n\n@end';});

/**
 * @export{object} library
 */
define('qtek/shader/library',['require','../Shader','./source/basic.essl','./source/lambert.essl','./source/phong.essl','./source/physical.essl','./source/wireframe.essl','./source/skybox.essl','./source/util.essl','./source/prez.essl','./source/shadowmap.essl','./source/compositor/vertex.essl','./source/compositor/coloradjust.essl','./source/compositor/blur.essl','./source/compositor/lum.essl','./source/compositor/lut.essl','./source/compositor/output.essl','./source/compositor/hdr.essl','./source/compositor/lensflare.essl','./source/compositor/blend.essl','./source/compositor/fxaa.essl'],function(require) {

    var Shader = require("../Shader");

    _library = {};

    _pool = {};

    // Example
    // ShaderLibrary.get("buildin.phong", "diffuseMap", "normalMap");
    // Or
    // ShaderLibrary.get("buildin.phong", ["diffuseMap", "normalMap"]);
    // Or
    // ShaderLibrary.get("buildin.phong", {
    //      textures : ["diffuseMap"],
    //      vertexDefines : {},
    //      fragmentDefines : {}
    // })
    function get(name, option) {
        var enabledTextures = [];
        var vertexDefines = {};
        var fragmentDefines = {};
        if (typeof(option) === "string") {
            enabledTextures = Array.prototype.slice.call(arguments, 1);
        }
        else if (toString.call(option) == '[object Object]') {
            enabledTextures = option.textures || [];
            vertexDefines = option.vertexDefines || {};
            fragmentDefines = option.fragmentDefines || {};
        } 
        else if(option instanceof Array) {
            enabledTextures = option;
        }
        var vertexDefineKeys = Object.keys(vertexDefines);
        var fragmentDefineKeys = Object.keys(fragmentDefines);
        enabledTextures.sort(); 
        vertexDefineKeys.sort();
        fragmentDefineKeys.sort();

        var keyArr = [name];
        keyArr = keyArr.concat(enabledTextures);
        for (var i = 0; i < vertexDefineKeys.length; i++) {
            keyArr.push(vertexDefines[vertexDefineKeys[i]]);
        }
        for (var i = 0; i < fragmentDefineKeys.length; i++) {
            keyArr.push(fragmentDefines[fragmentDefineKeys[i]]);
        }
        var key = keyArr.join('_');

        if (_pool[key]) {
            return _pool[key];
        } else {
            var source = _library[name];
            if (!source) {
                console.error('Shader "'+name+'"'+' is not in the library');
                return;
            }
            var shader = new Shader({
                "vertex" : source.vertex,
                "fragment" : source.fragment
            });
            for (var i = 0; i < enabledTextures.length; i++) {
                shader.enableTexture(enabledTextures[i]);
            }
            for (var name in vertexDefines) {
                shader.define('vertex', name, vertexDefines[name]);
            }
            for (var name in fragmentDefines) {
                shader.define('fragment', name, fragmentDefines[name]);
            }
            _pool[key] = shader;
            return shader;
        }
    }

    function put(name, vertex, fragment) {
        _library[name] = {
            vertex : vertex,
            fragment : fragment
        }
    }

    // Some build in shaders
    Shader['import'](require('./source/basic.essl'));
    Shader['import'](require('./source/lambert.essl'));
    Shader['import'](require('./source/phong.essl'));
    Shader['import'](require('./source/physical.essl'));
    Shader['import'](require('./source/wireframe.essl'));
    Shader['import'](require('./source/skybox.essl'));
    Shader['import'](require('./source/util.essl'));
    Shader['import'](require('./source/prez.essl'));

    Shader['import'](require('./source/shadowmap.essl'));

    put("buildin.basic", Shader.source("buildin.basic.vertex"), Shader.source("buildin.basic.fragment"));
    put("buildin.lambert", Shader.source("buildin.lambert.vertex"), Shader.source("buildin.lambert.fragment"));
    put("buildin.phong", Shader.source("buildin.phong.vertex"), Shader.source("buildin.phong.fragment"));
    put("buildin.wireframe", Shader.source("buildin.wireframe.vertex"), Shader.source("buildin.wireframe.fragment"));
    put("buildin.skybox", Shader.source("buildin.skybox.vertex"), Shader.source("buildin.skybox.fragment"));
    put("buildin.prez", Shader.source("buildin.prez.vertex"), Shader.source("buildin.prez.fragment"));
    put("buildin.physical", Shader.source("buildin.physical.vertex"), Shader.source("buildin.physical.fragment"));

    // Some build in shaders
    Shader['import'](require('./source/compositor/vertex.essl'));
    Shader['import'](require('./source/compositor/coloradjust.essl'));
    Shader['import'](require('./source/compositor/blur.essl'));
    Shader['import'](require('./source/compositor/lum.essl'));
    Shader['import'](require('./source/compositor/lut.essl'));
    Shader['import'](require('./source/compositor/output.essl'));
    Shader['import'](require('./source/compositor/hdr.essl'));
    Shader['import'](require('./source/compositor/lensflare.essl'));
    Shader['import'](require('./source/compositor/blend.essl'));
    Shader['import'](require('./source/compositor/fxaa.essl'));

    return {
        get : get,
        put : put
    }
});
define('qtek/math/Vector2',['require','glmatrix'],function(require) {

    

    var glMatrix = require("glmatrix");
    var vec2 = glMatrix.vec2;

    /**
     * @constructor
     * @alias qtek.math.Vector2
     * @param {number} x
     * @param {number} y
     */
    var Vector2 = function(x, y) {
        
        x = x || 0;
        y = y || 0;

        /**
         * Storage of Vector2, read and write of x, y will change the values in _array
         * All methods also operate on the _array instead of x, y components
         * @type {Float32Array}
         */
        this._array = vec2.fromValues(x, y);

        /**
         * Dirty flag is used by the Node to determine
         * if the matrix is updated to latest
         * @type {boolean}
         */
        this._dirty = true;
    }

    Vector2.prototype = {

        constructor : Vector2,

        /**
         * @name x
         * @type {number}
         * @memberOf qtek.math.Vector2
         * @instance
         */
        get x() {
            return this._array[0];
        },
        set x(value) {
            this._array[0] = value;
            this._dirty = true;
        },

        /**
         * @name y
         * @type {number}
         * @memberOf qtek.math.Vector2
         * @instance
         */
        get y() {
            return this._array[1];
        },

        set y(value) {
            this._array[1] = value;
            this._dirty = true;
        },

        /**
         * Add b to self
         * @param  {qtek.math.Vector2} b
         * @return {qtek.math.Vector2}
         */
        add : function(b) {
            vec2.add(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Set x and y components
         * @param  {number}  x
         * @param  {number}  y
         * @return {qtek.math.Vector2}
         */
        set : function(x, y) {
            this._array[0] = x;
            this._array[1] = y;
            this._dirty = true;
            return this;
        },

        /**
         * Set x and y components from array
         * @param  {Float32Array|number[]} arr
         * @return {qtek.math.Vector2}
         */
        setArray : function(arr) {
            this._array[0] = arr[0];
            this._array[1] = arr[1];

            this._dirty = true;
            return this;
        },

        /**
         * Clone a new Vector2
         * @return {qtek.math.Vector2}
         */
        clone : function() {
            return new Vector2(this.x, this.y);
        },

        /**
         * Copy x, y from b
         * @param  {qtek.math.Vector2} b
         * @return {qtek.math.Vector2}
         */
        copy : function(b) {
            vec2.copy(this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Cross product of self and b, written to a Vector3 out
         * @param  {qtek.math.Vector3} out
         * @param  {qtek.math.Vector2} b
         * @return {qtek.math.Vector2}
         */
        cross : function(out, b) {
            vec2.cross(out._array, this._array, b._array);
            out._dirty = true;
            return this;
        },

        /**
         * Alias for distance
         * @param  {qtek.math.Vector2} b
         * @return {number}
         */
        dist : function(b) {
            return vec2.dist(this._array, b._array);
        },

        /**
         * Distance between self and b
         * @param  {qtek.math.Vector2} b
         * @return {number}
         */
        distance : function(b) {
            return vec2.distance(this._array, b._array);
        },

        /**
         * Alias for divide
         * @param  {qtek.math.Vector2} b
         * @return {qtek.math.Vector2}
         */
        div : function(b) {
            vec2.div(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Divide self by b
         * @param  {qtek.math.Vector2} b
         * @return {qtek.math.Vector2}
         */
        divide : function(b) {
            vec2.divide(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Dot product of self and b
         * @param  {qtek.math.Vector2} b
         * @return {number}
         */
        dot : function(b) {
            return vec2.dot(this._array, b._array);
        },

        /**
         * Alias of length
         * @return {number}
         */
        len : function() {
            return vec2.len(this._array);
        },

        /**
         * Calculate the length
         * @return {number}
         */
        length : function() {
            return vec2.length(this._array);
        },
        
        /**
         * Linear interpolation between a and b
         * @param  {qtek.math.Vector2} a
         * @param  {qtek.math.Vector2} b
         * @param  {number}  t
         * @return {qtek.math.Vector2}
         */
        lerp : function(a, b, t) {
            vec2.lerp(this._array, a._array, b._array, t);
            this._dirty = true;
            return this;
        },

        /**
         * Minimum of self and b
         * @param  {qtek.math.Vector2} b
         * @return {qtek.math.Vector2}
         */
        min : function(b) {
            vec2.min(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Maximum of self and b
         * @param  {qtek.math.Vector2} b
         * @return {qtek.math.Vector2}
         */
        max : function(b) {
            vec2.max(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Alias for multiply
         * @param  {qtek.math.Vector2} b
         * @return {qtek.math.Vector2}
         */
        mul : function(b) {
            vec2.mul(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Mutiply self and b
         * @param  {qtek.math.Vector2} b
         * @return {qtek.math.Vector2}
         */
        multiply : function(b) {
            vec2.multiply(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Negate self
         * @return {qtek.math.Vector2}
         */
        negate : function() {
            vec2.negate(this._array, this._array);
            this._dirty = true;
            return this;
        },

        /**
         * Normalize self
         * @return {qtek.math.Vector2}
         */
        normalize : function() {
            vec2.normalize(this._array, this._array);
            this._dirty = true;
            return this;
        },

        /**
         * Generate random x, y components with a given scale
         * @param  {number} scale
         * @return {qtek.math.Vector2}
         */
        random : function(scale) {
            vec2.random(this._array, scale);
            this._dirty = true;
            return this;
        },

        /**
         * Scale self
         * @param  {number}  scale
         * @return {qtek.math.Vector2}
         */
        scale : function(s) {
            vec2.scale(this._array, this._array, s);
            this._dirty = true;
            return this;
        },

        /**
         * Scale b and add to self
         * @param  {qtek.math.Vector2} b
         * @param  {number}  scale
         * @return {qtek.math.Vector2}
         */
        scaleAndAdd : function(b, s) {
            vec2.scaleAndAdd(this._array, this._array, b._array, s);
            this._dirty = true;
            return this;
        },

        /**
         * Alias for squaredDistance
         * @param  {qtek.math.Vector2} b
         * @return {number}
         */
        sqrDist : function(b) {
            return vec2.sqrDist(this._array, b._array);
        },

        /**
         * Squared distance between self and b
         * @param  {qtek.math.Vector2} b
         * @return {number}
         */
        squaredDistance : function(b) {
            return vec2.squaredDistance(this._array, b._array);
        },

        /**
         * Alias for squaredLength
         * @return {number}
         */
        sqrLen : function() {
            return vec2.sqrLen(this._array);
        },

        /**
         * Squared length of self
         * @return {number}
         */
        squaredLength : function() {
            return vec2.squaredLength(this._array);
        },

        /**
         * Alias for subtract
         * @param  {qtek.math.Vector2} b
         * @return {qtek.math.Vector2}
         */
        sub : function(b) {
            vec2.sub(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Subtract b from self
         * @param  {qtek.math.Vector2} b
         * @return {qtek.math.Vector2}
         */
        subtract : function(b) {
            vec2.subtract(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Transform self with a Matrix2 m
         * @param  {qtek.math.Matrix2} m
         * @return {qtek.math.Vector2}
         */
        transformMat2 : function(m) {
            vec2.transformMat2(this._array, this._array, m._array);
            this._dirty = true;
            return this;
        },

        /**
         * Transform self with a Matrix2d m
         * @param  {qtek.math.Matrix2d} m
         * @return {qtek.math.Vector2}
         */
        transformMat2d : function(m) {
            vec2.transformMat2d(this._array, this._array, m._array);
            this._dirty = true;
            return this;
        },

        /**
         * Transform self with a Matrix3 m
         * @param  {qtek.math.Matrix3} m
         * @return {qtek.math.Vector2}
         */
        transformMat3 : function(m) {
            vec2.transformMat3(this._array, this._array, m._array);
            this._dirty = true;
            return this;
        },

        /**
         * Transform self with a Matrix4 m
         * @param  {qtek.math.Matrix4} m
         * @return {qtek.math.Vector2}
         */
        transformMat4 : function(m) {
            vec2.transformMat4(this._array, this._array, m._array);
            this._dirty = true;
            return this;
        },

        toString : function() {
            return "[" + Array.prototype.join.call(this._array, ",") + "]";
        },
    }

    // Supply methods that are not in place
    
    /**
     * @param  {qtek.math.Vector2} out
     * @param  {qtek.math.Vector2} a
     * @param  {qtek.math.Vector2} b
     * @return {qtek.math.Vector2}
     */
    Vector2.add = function(out, a, b) {
        vec2.add(out._array, a._array, b._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Vector2} out
     * @param  {number}  x
     * @param  {number}  y
     * @return {qtek.math.Vector2}  
     */
    Vector2.set = function(out, x, y) {
        vec2.set(out._array, x, y);
        out._dirty = true;
        return out
    }

    /**
     * @param  {qtek.math.Vector2} out
     * @param  {qtek.math.Vector2} b
     * @return {qtek.math.Vector2}
     */
    Vector2.copy = function(out, b) {
        vec2.copy(out._array, b._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Vector3} out
     * @param  {qtek.math.Vector2} a
     * @param  {qtek.math.Vector2} b
     * @return {qtek.math.Vector2}
     */
    Vector2.cross = function(out, a, b) {
        vec2.cross(out._array, a._array, b._array);
        out._dirty = true;
        return out;
    }
    /**
     * @param  {qtek.math.Vector2} a
     * @param  {qtek.math.Vector2} b
     * @return {number}
     */
    Vector2.dist = function(a, b) {
        return vec2.distance(a._array, b._array);
    }
    /**
     * @method
     * @param  {qtek.math.Vector2} a
     * @param  {qtek.math.Vector2} b
     * @return {number}
     */
    Vector2.distance = Vector2.dist;
    /**
     * @param  {qtek.math.Vector2} out
     * @param  {qtek.math.Vector2} a
     * @param  {qtek.math.Vector2} b
     * @return {qtek.math.Vector2}
     */
    Vector2.div = function(out, a, b) {
        vec2.divide(out._array, a._array, b._array);
        out._dirty = true;
        return out;
    }
    /**
     * @method
     * @param  {qtek.math.Vector2} out
     * @param  {qtek.math.Vector2} a
     * @param  {qtek.math.Vector2} b
     * @return {qtek.math.Vector2}
     */
    Vector2.divide = Vector2.div;
    /**
     * @param  {qtek.math.Vector2} a
     * @param  {qtek.math.Vector2} b
     * @return {number}
     */
    Vector2.dot = function(a, b) {
        return vec2.dot(a._array, b._array);
    }

    /**
     * @param  {qtek.math.Vector2} a
     * @return {number}
     */
    Vector2.len = function(b) {
        return vec2.length(b._array);
    }

    // Vector2.length = Vector2.len;
    
    /**
     * @param  {qtek.math.Vector2} out
     * @param  {qtek.math.Vector2} a
     * @param  {qtek.math.Vector2} b
     * @param  {number}  t
     * @return {qtek.math.Vector2}
     */
    Vector2.lerp = function(out, a, b, t) {
        vec2.lerp(out._array, a._array, b._array, t);
        out._dirty = true;
        return out;
    }
    /**
     * @param  {qtek.math.Vector2} out
     * @param  {qtek.math.Vector2} a
     * @param  {qtek.math.Vector2} b
     * @return {qtek.math.Vector2}
     */
    Vector2.min = function(out, a, b) {
        vec2.min(out._array, a._array, b._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Vector2} out
     * @param  {qtek.math.Vector2} a
     * @param  {qtek.math.Vector2} b
     * @return {qtek.math.Vector2}
     */
    Vector2.max = function(out, a, b) {
        vec2.max(out._array, a._array, b._array);
        out._dirty = true;
        return out;
    }
    /**
     * @param  {qtek.math.Vector2} out
     * @param  {qtek.math.Vector2} a
     * @param  {qtek.math.Vector2} b
     * @return {qtek.math.Vector2}
     */
    Vector2.mul = function(out, a, b) {
        vec2.multiply(out._array, a._array, b._array);
        out._dirty = true;
        return out;
    }
    /**
     * @method
     * @param  {qtek.math.Vector2} out
     * @param  {qtek.math.Vector2} a
     * @param  {qtek.math.Vector2} b
     * @return {qtek.math.Vector2}
     */
    Vector2.multiply = Vector2.mul;
    /**
     * @param  {qtek.math.Vector2} out
     * @param  {qtek.math.Vector2} a
     * @return {qtek.math.Vector2}
     */
    Vector2.negate = function(out, a) {
        vec2.negate(out._array, a._array);
        out._dirty = true;
        return out;
    }
    /**
     * @param  {qtek.math.Vector2} out
     * @param  {qtek.math.Vector2} a
     * @return {qtek.math.Vector2}
     */
    Vector2.normalize = function(out, a) {
        vec2.normalize(out._array, a._array);
        out._dirty = true;
        return out;
    }
    /**
     * @param  {qtek.math.Vector2} out
     * @param  {number}  scale
     * @return {qtek.math.Vector2}
     */
    Vector2.random = function(out, scale) {
        vec2.random(out._array, scale);
        out._dirty = true;
        return out;
    }
    /**
     * @param  {qtek.math.Vector2} out
     * @param  {qtek.math.Vector2} a
     * @param  {number}  scale
     * @return {qtek.math.Vector2}
     */
    Vector2.scale = function(out, a, scale) {
        vec2.scale(out._array, a._array, scale);
        out._dirty = true;
        return out;
    }
    /**
     * @param  {qtek.math.Vector2} out
     * @param  {qtek.math.Vector2} a
     * @param  {qtek.math.Vector2} b
     * @param  {number}  scale
     * @return {qtek.math.Vector2}
     */
    Vector2.scaleAndAdd = function(out, a, b, scale) {
        vec2.scale(out._array, a._array, b._array, scale);
        out._dirty = true;
        return out;
    }
    /**
     * @param  {qtek.math.Vector2} a
     * @param  {qtek.math.Vector2} b
     * @return {number}
     */
    Vector2.sqrDist = function(a, b) {
        return vec2.sqrDist(a._array, b._array);
    }
    /**
     * @method
     * @param  {qtek.math.Vector2} a
     * @param  {qtek.math.Vector2} b
     * @return {number}
     */
    Vector2.squaredDistance = Vector2.sqrDist;
    
    /**
     * @param  {qtek.math.Vector2} a
     * @return {number}
     */
    Vector2.sqrLen = function(a) {
        return vec2.sqrLen(a._array);
    }
    /**
     * @method
     * @param  {qtek.math.Vector2} a
     * @return {number}
     */
    Vector2.squaredLength = Vector2.sqrLen;

    /**
     * @param  {qtek.math.Vector2} out
     * @param  {qtek.math.Vector2} a
     * @param  {qtek.math.Vector2} b
     * @return {qtek.math.Vector2}
     */
    Vector2.sub = function(out, a, b) {
        vec2.subtract(out._array, a._array, b._array);
        out._dirty = true;
        return out;
    }
    /**
     * @method
     * @param  {qtek.math.Vector2} out
     * @param  {qtek.math.Vector2} a
     * @param  {qtek.math.Vector2} b
     * @return {qtek.math.Vector2}
     */
    Vector2.subtract = Vector2.sub;
    /**
     * @param  {qtek.math.Vector2} out
     * @param  {qtek.math.Vector2} a
     * @param  {qtek.math.Matrix2} m
     * @return {qtek.math.Vector2}
     */
    Vector2.transformMat2 = function(out, a, m) {
        vec2.transformMat2(out._array, a._array, m._array);
        out._dirty = true;
        return out;
    }
    /**
     * @param  {qtek.math.Vector2}  out
     * @param  {qtek.math.Vector2}  a
     * @param  {qtek.math.Matrix2d} m
     * @return {qtek.math.Vector2}
     */
    Vector2.transformMat2d = function(out, a, m) {
        vec2.transformMat2d(out._array, a._array, m._array);
        out._dirty = true;
        return out;
    }
    /**
     * @param  {qtek.math.Vector2} out
     * @param  {qtek.math.Vector2} a
     * @param  {Matrix3} m
     * @return {qtek.math.Vector2}
     */
    Vector2.transformMat3 = function(out, a, m) {
        vec2.transformMat3(out._array, a._array, m._array);
        out._dirty = true;
        return out;
    }
    /**
     * @param  {qtek.math.Vector2} out
     * @param  {qtek.math.Vector2} a
     * @param  {qtek.math.Matrix4} m
     * @return {qtek.math.Vector2}
     */
    Vector2.transformMat4 = function(out, a, m) {
        vec2.transformMat4(out._array, a._array, m._array);
        out._dirty = true;
        return out;
    }

    return Vector2;

});
define('qtek/Renderer',['require','./core/Base','./core/util','./Light','./Mesh','./Texture','./core/glinfo','./core/glenum','./math/BoundingBox','./math/Matrix4','./Shader','./shader/library','./Material','./math/Vector3','./math/Vector2','glmatrix'],function(require) {

    var Base = require("./core/Base");
    var util = require("./core/util");
    var Light = require("./Light");
    var Mesh = require("./Mesh");
    var Texture = require("./Texture");
    var glinfo = require('./core/glinfo');
    var glenum = require('./core/glenum');
    var BoundingBox = require('./math/BoundingBox');
    var Matrix4 = require('./math/Matrix4');
    var Shader = require('./Shader');
    var shaderLibrary = require('./shader/library');
    var Material = require('./Material');
    var Vector3 = require('./math/Vector3');
    var Vector2 = require('./math/Vector2');

    var glMatrix = require("glmatrix");
    var mat4 = glMatrix.mat4;
    var vec3 = glMatrix.vec3;
    var vec4 = glMatrix.vec4;

    var glid = 0;

    var preZPassShader = shaderLibrary.get('buildin.prez');
    var preZPassMaterial = new Material({
        shader : preZPassShader
    });

    var errorShader = {};

    /**
     * @constructor qtek.Renderer
     */
    var Renderer = Base.derive(function() {
        /** @lends qtek.Renderer# */
        return {

            /**
             * @type {HTMLCanvasElement}
             */
            canvas : null,

            /**
             * Canvas width, set by resize method
             * @type {number}
             * @readonly
             */
            width : 100,

            /**
             * Canvas width, set by resize method
             * @type {number}
             * @readonly
             */
            height : 100,

            /**
             * Device pixel ratio, set by setDevicePixelRatio method
             * Specially for high defination display
             * @see http://www.khronos.org/webgl/wiki/HandlingHighDPI
             * @type {number}
             * @readonly
             */
            devicePixelRatio : window.devicePixelRatio || 1.0,

            /**
             * Clear color
             * @type {number[]}
             */
            color : [0.0, 0.0, 0.0, 0.0],
            
            /**
             * Default:
             *     _gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT | _gl.STENCIL_BUFFER_BIT
             * @type {number}
             */
            clear : 17664,  

            // Settings when getting context
            // http://www.khronos.org/registry/webgl/specs/latest/#2.4

            /**
             * If enable alpha, default true
             * @type {boolean}
             */
            alhpa : true,
            /**
             * If enable depth buffer, default true
             * @type {boolean}
             */
            depth : true,
            /**
             * If enable stencil buffer, default false
             * @type {boolean}
             */
            stencil : false,
            /**
             * If enable antialias, default true
             * @type {boolean}
             */
            antialias : true,
            /**
             * If enable premultiplied alpha, default true
             * @type {boolean}
             */
            premultipliedAlpha : true,
            /**
             * If preserve drawing buffer, default false
             * @type {boolean}
             */
            preserveDrawingBuffer : false,
            /**
             * If throw context error, usually turned on in debug mode
             * @type {boolean}
             */
            throwError: true,
            /**
             * WebGL Context created from given canvas
             * @type {WebGLRenderingContext}
             */
            gl : null,
            /**
             * Renderer viewport, read-only, can be set by setViewport method
             * @type {{x: number, y: number, width: number, height: number}}
             */
            viewport : {},

            _viewportSettings : [],
            _clearSettings : [],

            _sceneRendering : null
        }
    }, function() {

        if (!this.canvas) {
            this.canvas = document.createElement("canvas");
            this.canvas.width = this.width;
            this.canvas.height = this.height;
        }
        try {
            var opts = {
                alhpa : this.alhpa,
                depth : this.depth,
                stencil : this.stencil,
                antialias : this.antialias,
                premultipliedAlpha : this.premultipliedAlpha,
                preserveDrawingBuffer : this.preserveDrawingBuffer
            }
            
            this.gl = this.canvas.getContext('webgl', opts)
                || this.canvas.getContext('experimental-webgl', opts);

            if (!this.gl) {
                throw new Error();
            }
            
            this.gl.__GLID__ = glid++;

            this.width = this.canvas.width; 
            this.height = this.canvas.height;
            this.resize(this.width, this.height);

            glinfo.initialize(this.gl);
        }
        catch(e) {
            if (this.throwError) {
                throw "Error creating WebGL Context";
            } else {
                this.trigger('error', "Error creating WebGL Context");
            }
        }
    },
    /** @lends qtek.Renderer.prototype. **/
    {
        /**
         * Resize the canvas
         * @param {number} width
         * @param {number} height
         */
        resize : function(width, height) {
            var canvas = this.canvas;
            // http://www.khronos.org/webgl/wiki/HandlingHighDPI
            // set the display size of the canvas.
            if (typeof(width) !== 'undefined') {
                canvas.style.width = width + "px";
                canvas.style.height = height + "px";
                // set the size of the drawingBuffer
                canvas.width = width * this.devicePixelRatio;
                canvas.height = height * this.devicePixelRatio;

                this.width = width;
                this.height = height;
            } else {
                this.width = canvas.width / this.devicePixelRatio;
                this.height = canvas.height / this.devicePixelRatio;
            }

            this.setViewport(0, 0, canvas.width, canvas.height);
        },

        /**
         * Set devicePixelRatio
         * @param {number} devicePixelRatio
         */
        setDevicePixelRatio : function(devicePixelRatio) {
            this.devicePixelRatio = devicePixelRatio;
            this.resize(this.width, this.height);
        },

        /**
         * Set rendering viewport
         * @param {number|{x:number,y:number,width:number,height:number}} x
         * @param {number} [y]
         * @param {number} [width]
         * @param {number} [height]
         */
        setViewport : function(x, y, width, height) {

            if (typeof(x) === "object") {
                var obj = x;
                x = obj.x;
                y = obj.y;
                width = obj.width;
                height = obj.height;
            }
            this.gl.viewport(x, y, width, height);

            this.viewport = {
                x : x,
                y : y,
                width : width,
                height : height
            }
        },

        /**
         * Push current viewport into a stack
         */
        saveViewport : function() {
            this._viewportSettings.push(this.viewport);
        },

        /**
         * Pop viewport from stack, restore in the renderer
         */
        restoreViewport : function() {
            if (this._viewportSettings.length > 0) {
                this.setViewport(this._viewportSettings.pop());
            }
        },

        /**
         * Push current clear into a stack
         */
        saveClear : function() {
            this._clearSettings.push(this.clear);
        },

        /**
         * Pop clear from stack, restore in the renderer
         */
        restoreClear : function() {
            if (this._clearSettings.length > 0) {
                this.clear = this._clearSettings.pop();   
            }
        },
        /**
         * Render the scene in camera to the screen or binded offline framebuffer
         * @param  {qtek.Scene}       scene
         * @param  {qtek.Camera}      camera
         * @param  {boolean}     [notUpdateScene] If not call the scene.update methods in the rendering, default true
         * @param  {boolean}     [preZ]           If use preZ optimization, default false
         * @return {IRenderInfo}
         */
        render : function(scene, camera, notUpdateScene, preZ) {
            var _gl = this.gl;

            this._sceneRendering = scene;

            var color = this.color;

            if (this.clear) {
                _gl.clearColor(color[0], color[1], color[2], color[3]);
                _gl.clear(this.clear);
            }

            // If the scene have been updated in the prepass like shadow map
            // There is no need to update it again
            if (!notUpdateScene) {
                scene.update(false);
            }
            if (!camera.scene) {
                camera.update(true);
            }

            var opaqueQueue = scene.opaqueQueue;
            var transparentQueue = scene.transparentQueue;
            var sceneMaterial = scene.material;

            scene.trigger('beforerender', this, scene, camera);
            // Sort render queue
            // Calculate the object depth
            if (transparentQueue.length > 0) {
                var worldViewMat = mat4.create();
                var posViewSpace = vec3.create();
                for (var i = 0; i < transparentQueue.length; i++) {
                    var node = transparentQueue[i];
                    mat4.multiply(worldViewMat, camera.viewMatrix._array, node.worldTransform._array);
                    vec3.transformMat4(posViewSpace, node.position._array, worldViewMat);
                    node.__depth = posViewSpace[2];
                }
            }
            opaqueQueue.sort(Renderer.opaqueSortFunc);
            transparentQueue.sort(Renderer.transparentSortFunc);

            // Render Opaque queue
            scene.trigger("beforerender:opaque", this, opaqueQueue);

            // Reset the scene bounding box;
            camera.sceneBoundingBoxLastFrame.min.set(Infinity, Infinity, Infinity);
            camera.sceneBoundingBoxLastFrame.max.set(-Infinity, -Infinity, -Infinity);

            _gl.disable(_gl.BLEND);
            _gl.enable(_gl.DEPTH_TEST);
            var opaqueRenderInfo = this.renderQueue(opaqueQueue, camera, sceneMaterial, preZ);

            scene.trigger("afterrender:opaque", this, opaqueQueue, opaqueRenderInfo);
            scene.trigger("beforerender:transparent", this, transparentQueue);

            // Render Transparent Queue
            _gl.enable(_gl.BLEND);
            var transparentRenderInfo = this.renderQueue(transparentQueue, camera, sceneMaterial);

            scene.trigger("afterrender:transparent", this, transparentQueue, transparentRenderInfo);
            var renderInfo = {}
            for (name in opaqueRenderInfo) {
                renderInfo[name] = opaqueRenderInfo[name] + transparentRenderInfo[name];
            }

            scene.trigger('afterrender', this, scene, camera, renderInfo);
            return renderInfo;
        },

        /**
         * Render a single renderable list in camera in sequence
         * @param  {qtek.Renderable[]} queue            List of all renderables.
         *                                         Best to be sorted by Renderer.opaqueSortFunc or Renderer.transparentSortFunc
         * @param  {qtek.Camera}       camera         
         * @param  {qtek.Material}     [globalMaterial] globalMaterial will override the material of each renderable
         * @param  {boolean}      [preZ]           If use preZ optimization, default false
         * @return {IRenderInfo}
         */
        renderQueue : function(queue, camera, globalMaterial, preZ) {
            var renderInfo = {
                faceNumber : 0,
                vertexNumber : 0,
                drawCallNumber : 0,
                meshNumber : 0
            };

            // Calculate view and projection matrix
            mat4.copy(matrices.VIEW, camera.viewMatrix._array);
            mat4.copy(matrices.PROJECTION, camera.projectionMatrix._array);
            mat4.multiply(matrices.VIEWPROJECTION, camera.projectionMatrix._array, matrices.VIEW);
            mat4.copy(matrices.VIEWINVERSE, camera.worldTransform._array);
            mat4.invert(matrices.PROJECTIONINVERSE, matrices.PROJECTION);
            mat4.invert(matrices.VIEWPROJECTIONINVERSE, matrices.VIEWPROJECTION);

            var _gl = this.gl;
            var scene = this._sceneRendering;
            
            var prevMaterial;
            var prevShader;
                
            // Status 
            var depthTest, depthMask;
            var culling, cullFace, frontFace;

            var culledRenderQueue;
            if (preZ) {
                culledRenderQueue = [];
                preZPassShader.bind(_gl);
                _gl.colorMask(false, false, false, false);
                _gl.depthMask(true);
                for (var i = 0; i < queue.length; i++) {
                    var renderable = queue[i];
                    var worldM = renderable.worldTransform._array;
                    var geometry = renderable.geometry;
                    mat4.multiply(matrices.WORLDVIEW, matrices.VIEW , worldM);
                    mat4.multiply(matrices.WORLDVIEWPROJECTION, matrices.VIEWPROJECTION , worldM);

                    if (geometry.boundingBox) {
                        if (!this._frustumCulling(renderable, camera)) {
                            continue;
                        }
                    }
                    if (renderable.skeleton) {  // Skip skinned mesh
                        continue;
                    }
                    if (renderable.cullFace !== cullFace) {
                        cullFace = renderable.cullFace;
                        _gl.cullFace(cullFace);
                    }
                    if (renderable.frontFace !== frontFace) {
                        frontFace = renderable.frontFace;
                        _gl.frontFace(frontFace);
                    }
                    if (renderable.culling !== culling) {
                        culling = renderable.culling;
                        culling ? _gl.enable(_gl.CULL_FACE) : _gl.disable(_gl.CULL_FACE)
                    }

                    var semanticInfo = preZPassShader.matrixSemantics.WORLDVIEWPROJECTION;
                    preZPassShader.setUniform(_gl, semanticInfo.type, semanticInfo.symbol, matrices.WORLDVIEWPROJECTION);
                    renderable.render(_gl, preZPassMaterial);
                    culledRenderQueue.push(renderable);
                }
                _gl.depthFunc(_gl.LEQUAL);
                _gl.colorMask(true, true, true, true);
                _gl.depthMask(false);
            } else {
                culledRenderQueue = queue;
            }

            for (var i =0; i < culledRenderQueue.length; i++) {
                var renderable = culledRenderQueue[i];
                var material = globalMaterial || renderable.material;
                var shader = material.shader;
                var geometry = renderable.geometry;

                var worldM = renderable.worldTransform._array;
                // All matrices ralated to world matrix will be updated on demand;
                mat4.copy(matrices.WORLD, worldM);
                mat4.multiply(matrices.WORLDVIEW, matrices.VIEW , worldM);
                mat4.multiply(matrices.WORLDVIEWPROJECTION, matrices.VIEWPROJECTION , worldM);
                if (shader.matrixSemantics.WORLDINVERSE ||
                    shader.matrixSemantics.WORLDINVERSETRANSPOSE) {
                    mat4.invert(matrices.WORLDINVERSE, worldM);
                }
                if (shader.matrixSemantics.WORLDVIEWINVERSE ||
                    shader.matrixSemantics.WORLDVIEWINVERSETRANSPOSE) {
                    mat4.invert(matrices.WORLDVIEWINVERSE, matrices.WORLDVIEW);
                }
                if (shader.matrixSemantics.WORLDVIEWPROJECTIONINVERSE ||
                    shader.matrixSemantics.WORLDVIEWPROJECTIONINVERSETRANSPOSE) {
                    mat4.invert(matrices.WORLDVIEWPROJECTIONINVERSE, matrices.WORLDVIEWPROJECTION);
                }
                if (geometry.boundingBox && ! preZ) {
                    if (!this._frustumCulling(renderable, camera)) {
                        continue;
                    }
                }

                if (prevShader !== shader) {
                    // Set lights number
                    if (scene && scene.isShaderLightNumberChanged(shader)) {
                        scene.setShaderLightNumber(shader);
                    }

                    var errMsg = shader.bind(_gl);
                    if (errMsg) {

                        if (errorShader[shader.__GUID__]) {
                            continue;
                        }
                        errorShader[shader.__GUID__] = true;

                        if (this.throwError) {
                            throw new Error(errMsg);
                        } else {
                            this.trigger('error', errMsg);
                        }
                    }

                    // Set lights uniforms
                    // TODO needs optimized
                    if (scene) {
                        scene.setLightUniforms(shader, _gl);
                    }
                    prevShader = shader;
                }
                if (prevMaterial !== material) {
                    if (!preZ) {
                        if (material.depthTest !== depthTest) {
                            material.depthTest ? 
                                _gl.enable(_gl.DEPTH_TEST) : 
                                _gl.disable(_gl.DEPTH_TEST);
                            depthTest = material.depthTest;
                        }
                        if (material.depthMask !== depthMask) {
                            _gl.depthMask(material.depthMask);
                            depthMask = material.depthMask;
                        }
                    }
                    material.bind(_gl, prevMaterial);
                    prevMaterial = material;

                    // TODO cache blending
                    if (material.transparent) {
                        if (material.blend) {
                            material.blend(_gl);
                        } else {    // Default blend function
                            _gl.blendEquationSeparate(_gl.FUNC_ADD, _gl.FUNC_ADD);
                            _gl.blendFuncSeparate(_gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA);
                        } 
                    }
                }

                var matrixSemanticKeys = shader.matrixSemanticKeys;
                for (var k = 0; k < matrixSemanticKeys.length; k++) {
                    var semantic = matrixSemanticKeys[k];
                    var semanticInfo = shader.matrixSemantics[semantic];
                    var matrix = matrices[semantic];
                    if (semanticInfo.isTranspose) {
                        var matrixNoTranspose = matrices[semanticInfo.semanticNoTranspose];
                        mat4.transpose(matrix, matrixNoTranspose);
                    }
                    shader.setUniform(_gl, semanticInfo.type, semanticInfo.symbol, matrix);
                }

                if (renderable.cullFace !== cullFace) {
                    cullFace = renderable.cullFace;
                    _gl.cullFace(cullFace);
                }
                if (renderable.frontFace !== frontFace) {
                    frontFace = renderable.frontFace;
                    _gl.frontFace(frontFace);
                }
                if (renderable.culling !== culling) {
                    culling = renderable.culling;
                    culling ? _gl.enable(_gl.CULL_FACE) : _gl.disable(_gl.CULL_FACE)
                }

                var objectRenderInfo = renderable.render(_gl, globalMaterial);

                if (objectRenderInfo) {
                    renderInfo.faceNumber += objectRenderInfo.faceNumber;
                    renderInfo.vertexNumber += objectRenderInfo.vertexNumber;
                    renderInfo.drawCallNumber += objectRenderInfo.drawCallNumber;
                    renderInfo.meshNumber ++;
                }
            }

            return renderInfo;
        },

        _frustumCulling : (function() {
            // Frustum culling
            // http://www.cse.chalmers.se/~uffe/vfc_bbox.pdf
            var cullingBoundingBox = new BoundingBox();
            var cullingMatrix = new Matrix4();
            return function(renderable, camera) {
                var geoBBox = renderable.geometry.boundingBox;
                cullingMatrix._array = matrices.WORLDVIEW;
                cullingBoundingBox.copy(geoBBox);
                cullingBoundingBox.applyTransform(cullingMatrix);

                // Passingly update the scene bounding box
                // TODO : exclude very large mesh like ground plane or terrain ?
                camera.sceneBoundingBoxLastFrame.union(cullingBoundingBox);

                if (renderable.frustumCulling)  {
                    if (!cullingBoundingBox.intersectBoundingBox(camera.frustum.boundingBox)) {
                        return false;
                    }

                    cullingMatrix._array = matrices.PROJECTION;
                    if (
                        cullingBoundingBox.max._array[2] > 0 &&
                        cullingBoundingBox.min._array[2] < 0
                    ) {
                        // Clip in the near plane
                        cullingBoundingBox.max._array[2] = -1e-20;
                    }
                    
                    cullingBoundingBox.applyProjection(cullingMatrix);

                    var min = cullingBoundingBox.min._array;
                    var max = cullingBoundingBox.max._array;
                    
                    if (
                        max[0] < -1 || min[0] > 1
                        || max[1] < -1 || min[1] > 1
                        || max[2] < -1 || min[2] > 1
                    ) {
                        return false;
                    }   
                }
                return true;
            }
        })(),

        /**
         * Dispose given scene, including all geometris, textures and shaders in the scene
         * @param {qtek.Scene} scene
         */
        disposeScene : function(scene) {
            this.disposeNode(scene);
            scene.dispose();
        },

        /**
         * Dispose given node, including all geometries, textures and shaders attached on it or its descendant
         * @param {qtek.Node} node
         */
        disposeNode : function(root) {
            var materials = {};
            var _gl = this.gl;

            root.traverse(function(node) {
                if (node.geometry) {
                    node.geometry.dispose(_gl);
                }
                if (node.material) {
                    materials[node.material.__GUID__] = node.material;
                }
                if (node.dispose) {
                    node.dispose(_gl);
                }
            });
            for (var guid in materials) {
                var mat = materials[guid];
                mat.shader.dispose(_gl);
                for (var name in mat.uniforms) {
                    var val = mat.uniforms[name].value;
                    if (!val ) {
                        continue;
                    }
                    if (val instanceof Texture) {
                        val.dispose(_gl);
                    }
                    else if (val instanceof Array) {
                        for (var i = 0; i < val.length; i++) {
                            if (val[i] instanceof Texture) {
                                val[i].dispose(_gl);
                            }
                        }
                    }
                }
            }
            root._children = [];
        },

        /**
         * Dispose given shader
         * @param {qtek.Shader} shader
         */
        disposeShader : function(shader) {
            shader.dispose(this.gl);
        },

        /**
         * Dispose given geometry
         * @param {qtek.Geometry} geometry
         */
        disposeGeometry : function(geometry) {
            geometry.dispose(this.gl);
        },

        /**
         * Dispose given texture
         * @param {qtek.Texture} texture
         */
        disposeTexture : function(texture) {
            texture.dispose(this.gl);
        },

        /**
         * Dispose given frame buffer
         * @param {qtek.FrameBuffer} frameBuffer
         */
        disposeFrameBuffer : function(frameBuffer) {
            frameBuffer.dispose(this.gl);
        },

        /**
         * Convert screen coords to normalized device coordinates(NDC)
         * Screen coords can get from mouse event, it is positioned relative to canvas element
         * NDC can be used in ray casting with Camera.castRay methods
         * 
         * @param  {number}       x
         * @param  {number}       y
         * @param  {qtek.math.Vector2} [out]
         * @return {qtek.math.Vector2}
         */
        screenToNdc : function(x, y, out) {
            if (!out) {
                out = new Vector2();
            }
            // Invert y;
            y = this.height - y;

            out._array[0] = (x - this.viewport.x) / this.viewport.width;
            out._array[0] = out._array[0] * 2 - 1;
            out._array[1] = (y - this.viewport.y) / this.viewport.height;
            out._array[1] = out._array[1] * 2 - 1;

            return out;
        }
    })

    /**
     * Opaque renderables compare function
     * @param  {qtek.Renderable} x
     * @param  {qtek.Renderable} y
     * @return {boolean}
     * @static
     */
    Renderer.opaqueSortFunc = function(x, y) {
        // Priority shader -> material -> geometry
        if (x.material.shader === y.material.shader) {
            if (x.material === y.material) {
                return x.geometry.__GUID__ - y.geometry.__GUID__;
            }
            return x.material.__GUID__ - y.material.__GUID__;
        }
        return x.material.shader.__GUID__ - y.material.shader.__GUID__;
    }

    /**
     * Transparent renderables compare function
     * @param  {qtek.Renderable} a
     * @param  {qtek.Renderable} b
     * @return {boolean}
     * @static
     */
    Renderer.transparentSortFunc = function(x, y) {
        // Priority depth -> shader -> material -> geometry
        if (x.__depth === y.__depth) {
            if (x.material.shader === y.material.shader) {
                if (x.material === y.material) {
                    return x.geometry.__GUID__ - y.geometry.__GUID__;
                }
                return x.material.__GUID__ - y.material.__GUID__;
            }
            return x.material.shader.__GUID__ - y.material.shader.__GUID__;
        }
        // Depth is negative
        // So farther object has smaller depth value
        return x.__depth - y.__depth
    }

    // Temporary variables
    var matrices = {
        'WORLD' : mat4.create(),
        'VIEW' : mat4.create(),
        'PROJECTION' : mat4.create(),
        'WORLDVIEW' : mat4.create(),
        'VIEWPROJECTION' : mat4.create(),
        'WORLDVIEWPROJECTION' : mat4.create(),

        'WORLDINVERSE' : mat4.create(),
        'VIEWINVERSE' : mat4.create(),
        'PROJECTIONINVERSE' : mat4.create(),
        'WORLDVIEWINVERSE' : mat4.create(),
        'VIEWPROJECTIONINVERSE' : mat4.create(),
        'WORLDVIEWPROJECTIONINVERSE' : mat4.create(),

        'WORLDTRANSPOSE' : mat4.create(),
        'VIEWTRANSPOSE' : mat4.create(),
        'PROJECTIONTRANSPOSE' : mat4.create(),
        'WORLDVIEWTRANSPOSE' : mat4.create(),
        'VIEWPROJECTIONTRANSPOSE' : mat4.create(),
        'WORLDVIEWPROJECTIONTRANSPOSE' : mat4.create(),
        'WORLDINVERSETRANSPOSE' : mat4.create(),
        'VIEWINVERSETRANSPOSE' : mat4.create(),
        'PROJECTIONINVERSETRANSPOSE' : mat4.create(),
        'WORLDVIEWINVERSETRANSPOSE' : mat4.create(),
        'VIEWPROJECTIONINVERSETRANSPOSE' : mat4.create(),
        'WORLDVIEWPROJECTIONINVERSETRANSPOSE' : mat4.create()
    };

    Renderer.COLOR_BUFFER_BIT = glenum.COLOR_BUFFER_BIT
    Renderer.DEPTH_BUFFER_BIT = glenum.DEPTH_BUFFER_BIT
    Renderer.STENCIL_BUFFER_BIT = glenum.STENCIL_BUFFER_BIT

    return Renderer;
});
define('qtek/Scene',['require','./Node','./Light','glmatrix','./math/BoundingBox'],function(require) {

    

    var Node = require('./Node');
    var Light = require('./Light');
    var glMatrix = require("glmatrix");
    var BoundingBox = require('./math/BoundingBox');
    var mat4 = glMatrix.mat4;
    var vec3 = glMatrix.vec3;

    /**
     * @constructor qtek.Scene
     * @extends qtek.Node
     */
    var Scene = Node.derive(function() {
        /** @lends qtek.Scene# */
        return {
            /**
             * Global material of scene
             * @type {Material}
             */
            material : null,

            /**
             * @type {boolean}
             */
            autoUpdate : true,

            /**
             * Opaque renderable list, it will be updated automatically
             * @type {Renderable[]}
             * @readonly
             */
            opaqueQueue : [],

            /**
             * Opaque renderable list, it will be updated automatically
             * @type {Renderable[]}
             * @readonly
             */
            transparentQueue : [],

            // Properties to save the light information in the scene
            // Will be set in the render function
            lights : [],
            
            _lightUniforms : {},

            _lightNumber : {
                'POINT_LIGHT' : 0,
                'DIRECTIONAL_LIGHT' : 0,
                'SPOT_LIGHT' : 0,
                'AMBIENT_LIGHT' : 0
            },

            _opaqueObjectCount : 0,
            _transparentObjectCount : 0,

            _nodeRepository : {}
        }
    }, function() {
        this.scene = this;
    }, 
    /** @lends qtek.Scene.prototype. */
    {
        /**
         * Add node to scene
         * @param {Node} node
         */
        addToScene : function(node) {
            if (node.name) {
                this._nodeRepository[node.name] = node;
            }
        },

        /**
         * Remove node from scene
         * @param {Node} node
         */
        removeFromScene : function(node) {
            if (node.name) {
                delete this._nodeRepository[node.name];
            }
        },

        /**
         * Get node by name
         * @param  {string} name
         * @return {Node}
         */
        getNode : function(name) {
            return this._nodeRepository[name];
        },

        update : function(force) {
            if (!(this.autoUpdate || force)) {
                return;
            }
            Node.prototype.update.call(this, force);

            var lights = this.lights;
            var opaqueQueue = this.opaqueQueue;
            var transparentQueue = this.transparentQueue;
            var sceneMaterialTransparent = this.material && this.material.transparent;

            this._opaqueObjectCount = 0;
            this._transparentObjectCount = 0;

            lights.length = 0;

            this._updateRenderQueue(this, sceneMaterialTransparent);

            this.opaqueQueue.length = this._opaqueObjectCount;
            this.transparentQueue.length = this._transparentObjectCount;

            // reset
            for (var type in this._lightNumber) {
                this._lightNumber[type] = 0;
            }
            for (var i = 0; i < lights.length; i++) {
                var light = lights[i];
                this._lightNumber[light.type]++;
            }
            this._updateLightUniforms();
        },

        // Traverse the scene and add the renderable
        // object to the render queue
        _updateRenderQueue : function(parent, sceneMaterialTransparent) {
            if (!parent.visible) {
                return;
            }
            
            for (var i = 0; i < parent._children.length; i++) {
                var child = parent._children[i];
                
                if (child instanceof Light) {
                    this.lights.push(child);
                }
                if (child.isRenderable()) {
                    if (child.material.transparent || sceneMaterialTransparent) {
                        this.transparentQueue[this._transparentObjectCount++] = child;
                    } else {
                        this.opaqueQueue[this._opaqueObjectCount++] = child;
                    }
                }
                if (child._children.length > 0) {
                    this._updateRenderQueue(child);
                }
            }
        },

        _updateLightUniforms : function() {
            var lights = this.lights;
            // Put the light cast shadow before the light not cast shadow
            lights.sort(lightSortFunc);

            var lightUniforms = this._lightUniforms;
            for (var symbol in lightUniforms) {
                lightUniforms[symbol].value.length = 0;
            }
            for (var i = 0; i < lights.length; i++) {
                
                var light = lights[i];
                
                for (symbol in light.uniformTemplates) {

                    var uniformTpl = light.uniformTemplates[symbol];
                    if (! lightUniforms[symbol]) {
                        lightUniforms[symbol] = {
                            type : "",
                            value : []
                        }
                    }
                    var value = uniformTpl.value(light);
                    var lu = lightUniforms[symbol];
                    lu.type = uniformTpl.type + "v";
                    switch (uniformTpl.type) {
                        case "1i":
                        case "1f":
                            lu.value.push(value);
                            break;
                        case "2f":
                        case "3f":
                        case "4f":
                            for (var j =0; j < value.length; j++) {
                                lu.value.push(value[j]);
                            }
                            break;
                        default:
                            console.error("Unkown light uniform type "+uniformTpl.type);
                    }
                }
            }
        },

        isShaderLightNumberChanged : function(shader) {
            return shader.lightNumber.POINT_LIGHT !== this._lightNumber.POINT_LIGHT
                || shader.lightNumber.DIRECTIONAL_LIGHT !== this._lightNumber.DIRECTIONAL_LIGHT
                || shader.lightNumber.SPOT_LIGHT !== this._lightNumber.SPOT_LIGHT
                || shader.lightNumber.AMBIENT_LIGHT !== this._lightNumber.AMBIENT_LIGHT
        },

        setShaderLightNumber : function(shader) {
            for (var type in this._lightNumber) {
                shader.lightNumber[type] = this._lightNumber[type];
            }
            shader.dirty();
        },

        setLightUniforms: function(shader, _gl) {
            for (var symbol in this._lightUniforms) {
                var lu = this._lightUniforms[symbol];
                shader.setUniform(_gl, lu.type, symbol, lu.value);
            }
        },

        /**
         * Dispose self, clear all the scene objects
         * But resources of gl like texuture, shader will not be disposed.
         * Mostly you should use disposeScene method in Renderer to do dispose.
         */
        dispose : function() {
            this.material = null;
            this.opaqueQueue = [];
            this.transparentQueue = [];

            this.lights = [];
            
            this._lightUniforms = {};

            this._lightNumber = {};
            this._nodeRepository = {};
        }
    });

    function lightSortFunc(a, b) {
        if (b.castShadow && !a.castShadow) {
            return true;
        }
    }

    return Scene;
});
define('qtek/Skeleton',['require','./core/Base','./core/util','./math/Matrix4','glmatrix'],function(require) {

    var Base = require("./core/Base");
    var util = require("./core/util");
    var Matrix4 = require("./math/Matrix4");

    var glMatrix = require("glmatrix");
    var quat = glMatrix.quat;
    var vec3 = glMatrix.vec3;
    var mat4 = glMatrix.mat4;

    /**
     * @constructor qtek.Skeleton
     */
    var Skeleton = Base.derive(function() {
        /** @lends qtek.Skeleton# */
        return {
            /**
             * @type {string}
             */
            name : '',

            /**
             * Index of root joints
             * @type {number[]}
             */
            roots : [],

            /**
             * Index of joints
             * @type {number[]}
             */
            joints : [],

            _clips : [],

            // Matrix to joint space (relative to root joint)
            _invBindPoseMatricesArray : null,

            // Use subarray instead of copy back each time computing matrix
            // http://jsperf.com/subarray-vs-copy-for-array-transform/5
            _jointMatricesSubArrays : [],

            // jointMatrix * currentPoseMatrix
            // worldTransform is relative to the root bone
            // still in model space not world space
            _skinMatricesArray : null,

            _skinMatricesSubArrays : [],

            _subSkinMatricesArray : {}
        }
    }, {
        /**
         * Update joints hierarchy
         */
        updateHierarchy : function() {
            this.roots = [];
            var joints = this.joints;
            for (var i = 0; i < joints.length; i++) {
                var joint = joints[i];
                if (joint.parentIndex >= 0) {
                    var parent = joints[joint.parentIndex].node;
                    parent.add(joint.node);
                }else{
                    this.roots.push(joint);
                }
            }
        },

        /**
         * Add a skinning clip and create a map between clip and skeleton
         * @param {qtek.animation.SkinningClip} clip
         * @param {object} [mapRule] Map between joint name in skeleton and joint name in clip
         */
        addClip : function(clip, mapRule) {

            // Map the joint index in skeleton to joint pose index in clip
            var maps = [];
            for (var i = 0; i < this.joints.length; i++) {
                maps[i] = -1;
            }
            // Create avatar
            for (var i = 0; i < clip.jointClips.length; i++) {
                for (var j = 0; j < this.joints.length; j++) {
                    var joint = this.joints[j];
                    var jointPose = clip.jointClips[i];
                    var jointName = joint.name;
                    if (mapRule) {
                        jointName = mapRule[jointName];
                    }
                    if (jointPose.name === jointName) {
                        maps[j] = i;
                        break;
                    }
                }
            }

            this._clips.push({
                maps : maps,
                clip : clip
            });

            return this._clips.length - 1;
        },

        /**
         * @param {qtek.animation.SkinningClip} clip
         */
        removeClip : function(clip) {
            var idx = -1;
            for (var i = 0; i < this._clips.length; i++) {
                if (this._clips[i].clip === clip) {
                    idx = i;
                    break;
                }
            }
            if (idx > 0) {
                this._clips.splice(idx, 1);
            }
        },
        /**
         * Remove all clips
         */
        removeClipsAll : function() {
            this._clips = [];
        },

        /**
         * Get clip by index
         * @param  {number} index
         */
        getClip : function(index) {
            if (this._clips[index]) {
                return this._clips[index].clip;
            }
        },

        /**
         * @return {number}
         */
        getClipNumber : function() {
            return this._clips.length;
        },

        /**
         * Calculate joint matrices from node transform
         * @method
         */
        updateJointMatrices : (function() {

            var m4 = mat4.create();

            return function() {
                for (var i = 0; i < this.roots.length; i++) {
                    this.roots[i].node.update(true);
                }
                this._invBindPoseMatricesArray = new Float32Array(this.joints.length * 16);
                this._skinMatricesArray = new Float32Array(this.joints.length * 16);

                for (var i = 0; i < this.joints.length; i++) {
                    var joint = this.joints[i];
                    // Joint space is relative to root joint's parent, if have
                    // !!Parent node and joint node must all be updated
                    if (joint.rootNode && joint.rootNode.parent) {
                        mat4.invert(m4, joint.rootNode.parent.worldTransform._array);
                        mat4.multiply(
                            m4,
                            m4,
                            joint.node.worldTransform._array
                        );   
                        mat4.invert(m4, m4);
                    } else {
                        mat4.copy(m4, joint.node.worldTransform._array);
                        mat4.invert(m4, m4);
                    }

                    var offset = i * 16;
                    for (var j = 0; j < 16; j++) {
                        this._invBindPoseMatricesArray[offset + j] = m4[j];
                    }
                }

                this.updateMatricesSubArrays();
            }
        })(),

        updateMatricesSubArrays : function() {
            for (var i = 0; i < this.joints.length; i++) {
                this._jointMatricesSubArrays[i] = this._invBindPoseMatricesArray.subarray(i * 16, (i+1) * 16);
                this._skinMatricesSubArrays[i] = this._skinMatricesArray.subarray(i * 16, (i+1) * 16);
            }
        },

        /**
         * Update skinning matrices
         */
        update : (function() {
            var m4 = mat4.create();
            return function() {
                for (var i = 0; i < this.roots.length; i++) {
                    this.roots[i].node.update(true);
                }

                for (var i = 0; i < this.joints.length; i++) {
                    var joint = this.joints[i];
                    mat4.multiply(
                        this._skinMatricesSubArrays[i],
                        joint.node.worldTransform._array,
                        this._jointMatricesSubArrays[i]
                    );

                    // Joint space is relative to root joint's parent, if have
                    // PENDING
                    if (joint.rootNode && joint.rootNode.parent) {
                        mat4.invert(m4, joint.rootNode.parent.worldTransform._array);
                        mat4.multiply(
                            this._skinMatricesSubArrays[i],
                            m4,
                            this._skinMatricesSubArrays[i]
                        );
                    }
                }
            }
        })(),

        getSubSkinMatrices : function(meshId, joints) {
            var subArray = this._subSkinMatricesArray[meshId]
            if (!subArray) {
                subArray 
                    = this._subSkinMatricesArray[meshId]
                    = new Float32Array(joints.length * 16);
            }
            var cursor = 0;
            for (var i = 0; i < joints.length; i++) {
                var idx = joints[i];
                for (var j = 0; j < 16; j++) {
                    subArray[cursor++] = this._skinMatricesArray[idx * 16 + j];
                }
            }
            return subArray;
        },

        /**
         * Set pose and update skinning matrices
         * @param {number} clipIndex
         */
        setPose : function(clipIndex) {
            var clip = this._clips[clipIndex].clip;
            var maps = this._clips[clipIndex].maps;

            for (var i = 0; i < this.joints.length; i++) {
                var joint = this.joints[i];
                if (maps[i] === -1) {
                    continue;
                }
                var pose = clip.jointClips[maps[i]];

                vec3.copy(joint.node.position._array, pose.position);
                quat.copy(joint.node.rotation._array, pose.rotation);
                vec3.copy(joint.node.scale._array, pose.scale);

                joint.node.position._dirty = true;
                joint.node.rotation._dirty = true;
                joint.node.scale._dirty = true;
            }
            this.update();
        }
    });

    return Skeleton;
});
/**
 *  https://github.com/sole/tween.js/blob/master/src/Tween.js
 * author: lang(shenyi01@baidu.com)
 */
define('qtek/animation/easing',[],function() {
    var Easing = {
        Linear: function(k) {
            return k;
        },

        QuadraticIn: function(k) {
            return k * k;
        },
        QuadraticOut: function(k) {
            return k * (2 - k);
        },
        QuadraticInOut: function(k) {
            if ((k *= 2) < 1) {
                return 0.5 * k * k;
            }
            return - 0.5 * (--k * (k - 2) - 1);
        },

        CubicIn: function(k) {
            return k * k * k;
        },
        CubicOut: function(k) {
            return --k * k * k + 1;
        },
        CubicInOut: function(k) {
            if ((k *= 2) < 1) {
                return 0.5 * k * k * k;
            }
            return 0.5 * ((k -= 2) * k * k + 2);
        },

        QuarticIn: function(k) {
            return k * k * k * k;
        },
        QuarticOut: function(k) {
            return 1 - (--k * k * k * k);
        },
        QuarticInOut: function(k) {
            if ((k *= 2) < 1) {
                return 0.5 * k * k * k * k;
            }
            return - 0.5 * ((k -= 2) * k * k * k - 2);
        },

        QuinticIn: function(k) {
            return k * k * k * k * k;
        },

        QuinticOut: function(k) {
            return --k * k * k * k * k + 1;
        },
        QuinticInOut: function(k) {
            if ((k *= 2) < 1) {
                return 0.5 * k * k * k * k * k;
            }
            return 0.5 * ((k -= 2) * k * k * k * k + 2);
        },

        SinusoidalIn: function(k) {
            return 1 - Math.cos(k * Math.PI / 2);
        },
        SinusoidalOut: function(k) {
            return Math.sin(k * Math.PI / 2);
        },
        SinusoidalInOut: function(k) {
            return 0.5 * (1 - Math.cos(Math.PI * k));
        },

        ExponentialIn: function(k) {
            return k === 0 ? 0 : Math.pow(1024, k - 1);
        },
        ExponentialOut: function(k) {
            return k === 1 ? 1 : 1 - Math.pow(2, - 10 * k);
        },
        ExponentialInOut: function(k) {
            if (k === 0) {
                return 0;
            }
            if (k === 1) {
                return 1;
            }
            if ((k *= 2) < 1) {
                return 0.5 * Math.pow(1024, k - 1);
            }
            return 0.5 * (- Math.pow(2, - 10 * (k - 1)) + 2);
        },

        CircularIn: function(k) {
            return 1 - Math.sqrt(1 - k * k);
        },
        CircularOut: function(k) {
            return Math.sqrt(1 - (--k * k));
        },
        CircularInOut: function(k) {
            if ((k *= 2) < 1) {
                return - 0.5 * (Math.sqrt(1 - k * k) - 1);
            }
            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
        },

        ElasticIn: function(k) {
            var s, a = 0.1, p = 0.4;
            if (k === 0) {
                return 0;
            }
            if (k === 1) {
                return 1;
            }
            if (!a || a < 1) {
                a = 1; s = p / 4;
            }else{
                s = p * Math.asin(1 / a) / (2 * Math.PI);
            }
            return - (a * Math.pow(2, 10 * (k -= 1)) *
                        Math.sin((k - s) * (2 * Math.PI) / p));
        },
        ElasticOut: function(k) {
            var s, a = 0.1, p = 0.4;
            if (k === 0) {
                return 0;
            }
            if (k === 1) {
                return 1;
            }
            if (!a || a < 1) {
                a = 1; s = p / 4;
            }
            else{
                s = p * Math.asin(1 / a) / (2 * Math.PI);
            }
            return (a * Math.pow(2, - 10 * k) *
                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);
        },
        ElasticInOut: function(k) {
            var s, a = 0.1, p = 0.4;
            if (k === 0) {
                return 0;
            }
            if (k === 1) {
                return 1;
            }
            if (!a || a < 1) {
                a = 1; s = p / 4;
            }
            else{
                s = p * Math.asin(1 / a) / (2 * Math.PI);
            }
            if ((k *= 2) < 1) {
                return - 0.5 * (a * Math.pow(2, 10 * (k -= 1))
                    * Math.sin((k - s) * (2 * Math.PI) / p));
            }
            return a * Math.pow(2, -10 * (k -= 1))
                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;

        },

        BackIn: function(k) {
            var s = 1.70158;
            return k * k * ((s + 1) * k - s);
        },
        BackOut: function(k) {
            var s = 1.70158;
            return --k * k * ((s + 1) * k + s) + 1;
        },
        BackInOut: function(k) {
            var s = 1.70158 * 1.525;
            if ((k *= 2) < 1) {
                return 0.5 * (k * k * ((s + 1) * k - s));
            }
            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
        },

        BounceIn: function(k) {
            return 1 - Easing.BounceOut(1 - k);
        },
        BounceOut: function(k) {
            if (k < (1 / 2.75)) {
                return 7.5625 * k * k;
            }
            else if (k < (2 / 2.75)) {
                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
            } else if (k < (2.5 / 2.75)) {
                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
            } else {
                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
            }
        },
        BounceInOut: function(k) {
            if (k < 0.5) {
                return Easing.BounceIn(k * 2) * 0.5;
            }
            return Easing.BounceOut(k * 2 - 1) * 0.5 + 0.5;
        }
    };

    return Easing;
});


define('qtek/animation/Clip',['require','./easing'],function(require) {

    var Easing = require('./easing');

    var Clip = function(options) {

        options = options || {};

        this.target = options.target;

        if( typeof(options.life) !== 'undefined') {
            this.life = options.life;
        }
        if (typeof(options.delay) !== 'undefined') {
            this.delay = options.delay;
        }
        if (typeof(options.gap) !== 'undefined') {
            this.gap = options.gap;
        }

        if (typeof(options.playbackRatio) !== 'undefined') {
            this.playbackRatio = options.playbackRatio;
        } else {
            this.playbackRatio = 1;
        }

        this._currentTime = new Date().getTime();
        
        this._startTime = this._currentTime + this.delay;

        this._elapsedTime = 0;

        this._loop = options.loop === undefined ? false : options.loop;
        this.setLoop(this._loop);

        if (typeof(options.easing) !== 'undefined') {
            this.setEasing(options.easing);
        }

        if (typeof(options.onframe) !== 'undefined') {
            this.onframe = options.onframe;
        }

        if (typeof(options.ondestroy) !== 'undefined') {
            this.ondestroy = options.ondestroy;
        }

        if (typeof(options.onrestart) !== 'undefined') {
            this.onrestart = options.onrestart;
        }

    };

    Clip.prototype = {

        gap : 0,

        life : 0,

        delay : 0,
        
        setLoop : function(loop) {
            this._loop = loop;
            if (loop) {
                if (typeof(loop) == 'number') {
                    this._loopRemained = loop;
                } else {
                    this._loopRemained = 1e8;
                }   
            }
        },

        setEasing : function(easing) {
            if (typeof(easing) === 'string') {
                easing = Easing[easing];
            }
            this.easing = easing;
        },

        step : function(time) {
            if (time < this._startTime) {
                this._currentTime = time;
                return;
            }

            this._elapse(time);

            var percent = this._elapsedTime / this.life;

            if (percent < 0) {
                return;
            }
            if (percent > 1) {
                percent = 1;
            }

            var schedule;
            if (this.easing) {
                schedule = this.easing(percent);
            }else{
                schedule = percent;
            }
            this.fire('frame', schedule);

            if (percent == 1) {
                if (this._loop && this._loopRemained > 0) {
                    this.restart();
                    this._loopRemained--;
                    return 'restart';
                } else {
                    // Mark this clip to be deleted
                    // In the animation.update
                    this._needsRemove = true;

                    return 'destroy';
                }
            } else {
                return null;
            }
        },

        setTime : function(time) {
            return this.step(time + this._startTime);
        },

        restart : function() {
            // If user leave the page for a while, when he gets back
            // All clips may be expired and all start from the beginning value(position)
            // It is clearly wrong, so we use remainder to add a offset
            var time = new Date().getTime();
            this._elapse(time);

            var remainder = this._elapsedTime % this.life;
            this._startTime = time - remainder + this.gap;
            this._elapsedTime = 0;
        },

        _elapse: function(time) {
            this._elapsedTime += (time - this._currentTime) * this.playbackRatio;
            this._currentTime = time;
        },
        
        fire : function(eventType, arg) {
            var eventName = 'on' + eventType;
            if (this[eventName]) {
                this[eventName](this.target, arg);
            }
        }
    };
    Clip.prototype.constructor = Clip;

    return Clip;
});
define('qtek/animation/Animation',['require','./Clip','../core/Base'],function(require) {
    
    

    var Clip = require('./Clip');
    var Base = require('../core/Base');

    var requestAnimationFrame = window.requestAnimationFrame
                                || window.msRequestAnimationFrame
                                || window.mozRequestAnimationFrame
                                || window.webkitRequestAnimationFrame
                                || function(func){setTimeout(func, 16)};

    var arraySlice = Array.prototype.slice;

    var Animation = Base.derive(function() {
        return {
            stage : null,

            _clips : [],

            _running : false,
            
            _time : 0
        }
    }, {
        addClip : function(clip) {
            this._clips.push(clip);
        },
        removeClip : function(clip) {
            var idx = this._clips.indexOf(clip);
            this._clips.splice(idx, 1);
        },
        update : function() {
            
            var time = new Date().getTime();
            var delta = time - this._time;
            var clips = this._clips;
            var len = clips.length;

            var deferredEvents = [];
            var deferredClips = [];
            for (var i = 0; i < len; i++) {
                var clip = clips[i];
                var e = clip.step(time);
                // Throw out the events need to be called after
                // stage.render, like destroy
                if (e) {
                    deferredEvents.push(e);
                    deferredClips.push(clip);
                }
            }
            if (this.stage
                && this.stage.render
                && this._clips.length
            ) {
                this.stage.render();
            }

            // Remove the finished clip
            for (var i = 0; i < len;) {
                if (clips[i]._needsRemove) {
                    clips[i] = clips[len-1];
                    clips.pop();
                    len--;
                } else {
                    i++;
                }
            }

            len = deferredEvents.length;
            for (var i = 0; i < len; i++) {
                deferredClips[i].fire(deferredEvents[i]);
            }

            this._time = time;

            this.trigger('frame', delta);
        },
        start : function() {
            var self = this;

            this._running = true;
            this._time = new Date().getTime();

            function step() {
                if (self._running) {
                    
                    requestAnimationFrame(step);

                    self.update();
                }
            }

            requestAnimationFrame(step);
        },
        stop : function() {
            this._running = false;
        },
        removeClipsAll : function() {
            this._clips = [];
        },
        animate : function(target, options) {
            options = options || {};
            var deferred = new Deferred(
                target,
                options.loop,
                options.getter,
                options.setter,
                options.interpolater
            );
            deferred.animation = this;
            return deferred;
        }
    });

    function _defaultGetter(target, key) {
        return target[key];
    }
    function _defaultSetter(target, key, value) {
        target[key] = value;
    }

    function _interpolateNumber(p0, p1, percent) {
        return (p1 - p0) * percent + p0;
    }

    function _interpolateArray(p0, p1, percent, out, arrDim) {
        var len = p0.length;
        if (arrDim == 1) {
            for (var i = 0; i < len; i++) {
                out[i] = _interpolateNumber(p0[i], p1[i], percent); 
            }
        } else {
            var len2 = p0[0].length;
            for (var i = 0; i < len; i++) {
                for (var j = 0; j < len2; j++) {
                    out[i][j] = _interpolateNumber(
                        p0[i][j], p1[i][j], percent
                    );
                }
            }
        }
    }

    function _isArrayLike(data) {
        if (typeof(data) == 'undefined') {
            return false;
        } else if (typeof(data) == 'string') {
            return false;
        } else {
            return typeof(data.length) == 'number';
        }
    }

    function _catmullRomInterpolateArray(
        p0, p1, p2, p3, t, t2, t3, out, arrDim
    ) {
        var len = p0.length;
        if (arrDim == 1) {
            for (var i = 0; i < len; i++) {
                out[i] = _catmullRomInterpolate(
                    p0[i], p1[i], p2[i], p3[i], t, t2, t3
                );
            }
        } else {
            var len2 = p0[0].length;
            for (var i = 0; i < len; i++) {
                for (var j = 0; j < len2; j++) {
                    out[i][j] = _catmullRomInterpolate(
                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],
                        t, t2, t3
                    );
                }
            }
        }
    }
    
    function _catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
        var v0 = (p2 - p0) * 0.5;
        var v1 = (p3 - p1) * 0.5;
        return (2 * (p1 - p2) + v0 + v1) * t3 
                + (- 3 * (p1 - p2) - 2 * v0 - v1) * t2
                + v0 * t + p1;
    };
    
    function Deferred(target, loop, getter, setter, interpolater) {
        this._tracks = {};
        this._target = target;

        this._loop = loop || false;

        this._getter = getter || _defaultGetter;
        this._setter = setter || _defaultSetter;

        this._interpolater = interpolater || null;

        this._clipCount = 0;

        this._delay = 0;

        this._doneList = [];

        this._onframeList = [];

        this._clipList = [];
    }

    Deferred.prototype = {
        when : function(time /* ms */, props) {
            for (var propName in props) {
                if (! this._tracks[propName]) {
                    this._tracks[propName] = [];
                    // If time is 0 
                    //  Then props is given initialize value
                    // Else
                    //  Initialize value from current prop value
                    if (time !== 0) {
                        this._tracks[propName].push({
                            time : 0,
                            value : this._getter(this._target, propName)
                        });   
                    }
                }
                this._tracks[propName].push({
                    time : parseInt(time),
                    value : props[propName]
                });
            }
            return this;
        },
        during : function(callback) {
            this._onframeList.push(callback);
            return this;
        },
        start : function(easing) {

            var self = this;
            var setter = this._setter;
            var getter = this._getter;
            var interpolater = this._interpolater;
            var onFrameListLen = self._onframeList.length;
            var useSpline = easing === 'spline';

            var ondestroy = function() {
                self._clipCount--;
                if (self._clipCount === 0) {
                    // Clear all tracks
                    self._tracks = {};

                    var len = self._doneList.length;
                    for (var i = 0; i < len; i++) {
                        self._doneList[i].call(self);
                    }
                }
            }

            var createTrackClip = function(keyframes, propName) {
                var trackLen = keyframes.length;
                if (!trackLen) {
                    return;
                }
                // Guess data type
                var firstVal = keyframes[0].value;
                var isValueArray = _isArrayLike(firstVal);

                // For vertices morphing
                var arrDim = (
                        isValueArray 
                        && _isArrayLike(firstVal[0])
                    )
                    ? 2 : 1;
                // Sort keyframe as ascending
                keyframes.sort(function(a, b) {
                    return a.time - b.time;
                });
                if (trackLen) {
                    var trackMaxTime = keyframes[trackLen-1].time;
                }else{
                    return;
                }
                // Percents of each keyframe
                var kfPercents = [];
                // Value of each keyframe
                var kfValues = [];
                for (var i = 0; i < trackLen; i++) {
                    kfPercents.push(keyframes[i].time / trackMaxTime);
                    if (isValueArray) {
                        if (arrDim == 2) {
                            kfValues[i] = [];
                            for (var j = 0; j < firstVal.length; j++) {
                                kfValues[i].push(arraySlice.call(keyframes[i].value[j]));
                            }
                        } else {
                            kfValues.push(arraySlice.call(keyframes[i].value));
                        }
                    } else {
                        kfValues.push(keyframes[i].value);
                    }
                }

                // Cache the key of last frame to speed up when 
                // animation playback is sequency
                var cacheKey = 0;
                var cachePercent = 0;
                var start;
                var i, w;
                var p0, p1, p2, p3;

                var onframe = function(target, percent) {
                    // Find the range keyframes
                    // kf1-----kf2---------current--------kf3
                    // find kf2(i) and kf3(i+1) and do interpolation
                    if (percent < cachePercent) {
                        // Start from next key
                        start = Math.min(cacheKey + 1, trackLen - 1);
                        for (i = start; i >= 0; i--) {
                            if (kfPercents[i] <= percent) {
                                break;
                            }
                        }
                        i = Math.min(i, trackLen-2);
                    } else {
                        for (i = cacheKey; i < trackLen; i++) {
                            if (kfPercents[i] > percent) {
                                break;
                            }
                        }
                        i = Math.min(i-1, trackLen-2);
                    }
                    cacheKey = i;
                    cachePercent = percent;

                    var range = (kfPercents[i+1] - kfPercents[i]);
                    if (range == 0) {
                        return;
                    } else {
                        w = (percent - kfPercents[i]) / range;
                    }
                    if (useSpline) {
                        p1 = kfValues[i];
                        p0 = kfValues[i == 0 ? i : i - 1];
                        p2 = kfValues[i > trackLen - 2 ? trackLen - 1 : i + 1];
                        p3 = kfValues[i > trackLen - 3 ? trackLen - 1 : i + 2];
                        if (interpolater) {
                            setter(
                                target,
                                propName, 
                                interpolater(
                                    getter(target, propName),
                                    p0, p1, p2, p3, w
                                )
                            );
                        } else if (isValueArray) {
                            _catmullRomInterpolateArray(
                                p0, p1, p2, p3, w, w*w, w*w*w,
                                getter(target, propName),
                                arrDim
                            );
                        } else {
                            setter(
                                target,
                                propName,
                                _catmullRomInterpolate(p0, p1, p2, p3, w, w*w, w*w*w)
                            );
                        }
                    } else {
                        if (interpolater) {
                            setter(
                                target,
                                propName, 
                                interpolater(
                                    getter(target, propName),
                                    kfValues[i],
                                    kfValues[i + 1],
                                    w
                                )
                            );
                        }
                        else if (isValueArray) {
                            _interpolateArray(
                                kfValues[i], kfValues[i+1], w,
                                getter(target, propName),
                                arrDim
                            );
                        } else {
                            setter(
                                target,
                                propName,
                                _interpolateNumber(kfValues[i], kfValues[i+1], w)
                            );
                        }
                    }

                    for (i = 0; i < onFrameListLen; i++) {
                        self._onframeList[i](target, percent);
                    }
                };

                var clip = new Clip({
                    target : self._target,
                    life : trackMaxTime,
                    loop : self._loop,
                    delay : self._delay,
                    onframe : onframe,
                    ondestroy : ondestroy
                });

                if (easing && easing !== 'spline') {
                    clip.setEasing(easing);
                }
                self._clipList.push(clip);
                self._clipCount++;
                self.animation.addClip(clip);
            }

            for (var propName in this._tracks) {
                createTrackClip(this._tracks[propName], propName);
            }
            return this;
        },
        stop : function() {
            for (var i = 0; i < this._clipList.length; i++) {
                var clip = this._clipList[i];
                this.animation.removeClip(clip);
            }
            this._clipList = [];
        },
        delay : function(time){
            this._delay = time;
            return this;
        },
        done : function(func) {
            this._doneList.push(func);
            return this;
        },
        getClips: function() {
            return this._clipList;
        }
    };

    return Animation;
});

define('qtek/core/Event',['require','./Base'], function(require) {

    var Base = require('./Base');

    var QEvent = Base.derive({
        cancelBubble : false
    }, {
        stopPropagation : function() {
            this.cancelBubble = true;
        }
    });

    QEvent['throw'] = function(eventType, target, props) {
        
        var e = new QEvent(props);

        e.type = eventType;
        e.target = target;

        // enable bubbling
        while (target && !e.cancelBubble ) {
            e.currentTarget = target;
            target.trigger(eventType, e);

            target = target.parent;
        }
    }

    return QEvent;
} );
define('qtek/camera/Perspective',['require','../Camera'],function(require) {

    var Camera = require('../Camera');

    var Perspective = Camera.derive({
        fov : 50,
        
        aspect : 1,
        
        near : 0.1,

        far : 2000
    }, {
        
        updateProjectionMatrix : function() {
            var rad = this.fov / 180 * Math.PI;
            this.projectionMatrix.perspective(rad, this.aspect, this.near, this.far);
        },

        clone: function() {
            var camera = Camera.prototype.clone.call(this);
            camera.fov = this.fov;
            camera.aspect = this.aspect;
            camera.near = this.near;
            camera.far = this.far;

            return camera;
        }
    });

    return Perspective;
} );
define('qtek/Stage',['require','./core/Base','./Layer','./animation/Animation','./core/Event','./Scene','./Renderer','./camera/Perspective'],function(require) {

    var Base = require('./core/Base');
    var Layer = require('./Layer');
    var Animation = require('./animation/Animation');
    var QEvent = require('./core/Event');

    var Scene3D = require('./Scene');
    var Renderer3D = require('./Renderer');
    var Camera3D = require('./camera/Perspective');
    
    var Stage = Base.derive(function() {
        return {
            container : null,

            width : 100,
            height : 100,

            _layers : [],

            _layersSorted : [],

            _mouseOverEl : null
        }
    }, function() {
        
        if (!this.container) {
            this.container = document.createElement('div');
        }
        if (this.container.style.position !== 'absolute' &&
            this.container.style.position !== 'fixed') {
            this.container.style.position = 'relative';
        }

        if (this.width) {
            this.container.style.width = this.width + 'px';
        } else {
            this.width = Math.max(this.container.clientWidth, 1);
        }
        if (this.height) {
            this.container.style.height = this.height + 'px';
        } else {
            this.height = Math.max(this.container.clientHeight, 1);
        }

        this.container.addEventListener("click", this._eventProxy.bind(this, 'click'));
        this.container.addEventListener("dblclick", this._eventProxy.bind(this, 'dblclick'));
        this.container.addEventListener("mousemove", this._mouseMoveHandler.bind(this));
        this.container.addEventListener("mousedown", this._eventProxy.bind(this, 'mousedown'));
        this.container.addEventListener("mouseup", this._eventProxy.bind(this, 'mouseup'));
        this.container.addEventListener("mouseout", this._mouseOutHandler.bind(this));

        this.animation = new Animation();
        this.animation.start();

        this.animation.on('frame', function(frameTime) {
            this.trigger('frame', frameTime);
        }, this);
    }, {
        createLayer3D : function(options) {
            options = options || {};
            options.renderer = options.renderer || new Renderer3D();
            if (!options.camera) {
                options.camera = new Camera3D();
                options.camera.position.z = 1;
                options.camera.aspect = this.width / this.height;
            }
            options.scene = options.scene || new Scene3D();

            var layer = new Layer(options);
            this.addLayer(layer);

            return layer;
        },

        addLayer : function(layer) {
            if (!layer.renderer) {
                console.warn('Layer don\'t have renderer');
                return;
            } else if (!layer.renderer.canvas) {
                console.warn('Layer renderer don\'t have canvas');
                return;
            }
            var canvas = layer.renderer.canvas;

            layer.renderer.resize(this.width, this.height);

            canvas.style.position = 'absolute';
            canvas.style.left = '0px';
            canvas.style.top = '0px';

            this.container.appendChild(canvas);

            this._layers.push(layer);
            this._layersSorted = this._layers.slice().sort(function(a, b){
                if (a.z === b.z)
                    return a.__GUID__ > b.__GUID__ ? 1 : -1;
                return a.z > b.z ? 1 : -1 ;
            });
        },

        removeLayer : function(layer) {
            this._layers.splice(this._layers.indexOf(layer), 1);

            this.container.removeChild(layer.canvas);
        },

        resize : function(width, height) {
            this.width = width;
            this.height = height;

            for (var i = 0; i < this._layers.length; i++) {
                this._layers[i].resize(width, height);
                if (this._layers[i].camera instanceof Camera3D) {
                    this._layers[i].camera.aspect = width / height;
                }
            }
        },

        render : function() {
            for (var i = 0; i < this._layers.length; i++) {
                this._layers[i].render();
            }
        },

        _eventProxy : function(type, e) {
            var e2 = this._assembleEvent(e);
            var el = this._findTrigger(e2);
            if (el) {
                QEvent['throw'](type, el, e2);
            }
            this.trigger(type, e2);
        },

        _mouseMoveHandler : function(e) {
            var el = this._findTrigger(e);
            if (el) {
                QEvent['throw']('mousemove', el, this._assembleEvent(e));
            }

            if (this._mouseOverEl !== el) {
                if (this._mouseOverEl) {
                    QEvent['throw']('mouseout', this._mouseOverEl, this._assembleEvent(e));
                }
                if (el) {
                    QEvent['throw']('mouseover', el, this._assembleEvent(e));
                }
                this._mouseOverEl = el;
            }
        },

        _mouseOutHandler : function(e) {
            if (this._mouseOverEl) {
                QEvent['throw']('mouseout', this._mouseOverEl, this._assembleEvent(e));
            }
        },

        _findTrigger : function(e) {
            var container = this.container;
            var x = e.x;
            var y = e.y;

            for (var i = this._layersSorted.length - 1; i >= 0 ; i--) {
                var layer = this._layersSorted[i];
                var el = layer.pick(x, y);
                if (el) {
                    return el;
                }
            }
        },

        _assembleEvent : function(e){
            var clientRect = this.container.getBoundingClientRect();
            return {
                pageX : e.pageX,
                pageY : e.pageY,
                x : e.pageX - clientRect.left - document.body.scrollLeft,
                y : e.pageY - clientRect.top - document.body.scrollTop
            }
        }

    });

    return Stage;
});
// 1D Blend clip of blend tree
// http://docs.unity3d.com/Documentation/Manual/1DBlending.html
define('qtek/animation/Blend1DClip',['require','./Clip'],function(require) {

    var Clip = require('./Clip');

    var clipSortFunc = function(a, b) {
        return a.position < b.position;
    }

    var Blend1DClip = function(opts) {

        opts = opts || {};

        Clip.call(this, opts);

        this.output = opts.output || null;
        // 
        // {
        //  position : 
        //  clip : 
        //  offset : 0
        // }
        this.inputs = opts.inputs || [];

        this.position = 0;

        this._cacheKey = 0;
        this._cachePosition = -Infinity;

        this.inputs.sort(clipSortFunc);
    }

    Blend1DClip.prototype = new Clip();
    Blend1DClip.prototype.constructor = Blend1DClip;

    Blend1DClip.prototype.addInput = function(position, inputClip, offset) {
        var obj = {
            position : position,
            clip : inputClip,
            offset : offset || 0
        }
        this.life = Math.max(inputClip.life, this.life);

        if (!this.inputs.length) {
            this.inputs.push(obj);
            return obj;
        }
        var len = this.inputs.length;
        if (this.inputs[0].position > position) {
            this.inputs.unshift(obj);
        } else if (this.inputs[len - 1].position <= position) {
            this.inputs.push(obj);
        } else {
            var key = this._findKey(position);
            this.inputs.splice(key, obj);
        }

        return obj;
    }

    Blend1DClip.prototype.step = function(time) {

        var ret = Clip.prototype.step.call(this, time);

        if (ret !== 'destroy') {
            this.setTime(this._elapsedTime);
        }

        return ret;
    }

    Blend1DClip.prototype.setTime = function(time) {
        var position = this.position;
        var inputs = this.inputs;
        var len = inputs.length;
        var min = inputs[0].position;
        var max = inputs[len-1].position;

        if (position <= min || position >= max) {
            var in0 = position <= min ? inputs[0] : inputs[len-1];
            var clip = in0.clip;
            var offset = in0.offset;
            clip.setTime((time + offset) % clip.life);
            // Input clip is a blend clip
            // PENDING
            if (clip.output instanceof Clip) {
                this.output.copy(clip.output);
            } else {
                this.output.copy(clip);
            }
        } else {
            var key = this._findKey(position);
            var in1 = inputs[key];
            var in2 = inputs[key + 1];
            var clip1 = in1.clip;
            var clip2 = in2.clip;
            clip1.setTime((time + in1.offset) % clip1.life);
            clip2.setTime((time + in2.offset) % clip2.life);

            var w = (this.position - in1.position) / (in2.position - in1.position);

            var c1 = clip1.output instanceof Clip ? clip1.output : clip1;
            var c2 = clip2.output instanceof Clip ? clip2.output : clip2;
            this.output.blend1D(c1, c2, w);
        }
    }
    
    // Find the key where position in range [inputs[key].position, inputs[key+1].position)
    Blend1DClip.prototype._findKey = function(position) {
        var key = -1;
        var inputs = this.inputs;
        var len = inputs.length;
        if (this._cachePosition < position) {
            for (var i = this._cacheKey; i < len-1; i++) {
                if (position >= inputs[i].position && position < inputs[i+1].position) {
                    key = i;
                }
            }
        } else {
            var s = Math.min(len-2, this._cacheKey);
            for (var i = s; i >= 0; i--) {
                if (position >= inputs[i].position && position < inputs[i+1].position) {
                    key = i;
                }
            }
        }
        if (key >= 0) {
            this._cacheKey = key;
            this._cachePosition = position;
        }

        return key;
    }

    return Blend1DClip;
});
// Delaunay Triangulation
// Modified from https://github.com/ironwallaby/delaunay

define('qtek/util/delaunay',['require'],function(require) {
    

    function appendSupertriangleVertices(vertices) {
        var xmin = Number.POSITIVE_INFINITY,
            ymin = Number.POSITIVE_INFINITY,
            xmax = Number.NEGATIVE_INFINITY,
            ymax = Number.NEGATIVE_INFINITY,
            i, dx, dy, dmax, xmid, ymid;

        for(i = vertices.length; i--; ) {
            if(vertices[i][0] < xmin) xmin = vertices[i][0];
            if(vertices[i][0] > xmax) xmax = vertices[i][0];
            if(vertices[i][1] < ymin) ymin = vertices[i][1];
            if(vertices[i][1] > ymax) ymax = vertices[i][1];
        }

        dx = xmax - xmin;
        dy = ymax - ymin;
        dmax = Math.max(dx, dy);
        xmid = xmin + dx * 0.5;
        ymid = ymin + dy * 0.5;

        vertices.push(
            [xmid - 20 * dmax, ymid -      dmax],
            [xmid            , ymid + 20 * dmax],
            [xmid + 20 * dmax, ymid -      dmax]
        );
    }

    function triangle(vertices, i, j, k) {
        var a = vertices[i],
            b = vertices[j],
            c = vertices[k],
            A = b[0] - a[0],
            B = b[1] - a[1],
            C = c[0] - a[0],
            D = c[1] - a[1],
            E = A * (a[0] + b[0]) + B * (a[1] + b[1]),
            F = C * (a[0] + c[0]) + D * (a[1] + c[1]),
            G = 2 * (A * (c[1] - b[1]) - B * (c[0] - b[0])),
            minx, miny, dx, dy, x, y;

        /* If the points of the triangle are collinear, then just find the
         * extremes and use the midpoint as the center of the circumcircle. */
        if (Math.abs(G) < 0.000001) {
            minx = Math.min(a[0], b[0], c[0]);
            miny = Math.min(a[1], b[1], c[1]);
            dx   = (Math.max(a[0], b[0], c[0]) - minx) * 0.5;
            dy   = (Math.max(a[1], b[1], c[1]) - miny) * 0.5;
            x    = minx + dx;
            y    = miny + dy;
        }
        else {
            x  = (D*E - B*F) / G;
            y  = (A*F - C*E) / G;
            dx = x - a[0];
            dy = y - a[1];
        }

        return {i: i, j: j, k: k, x: x, y: y, r: dx * dx + dy * dy};
    }

    function dedup(edges) {
        var j = edges.length,
            a, b, i, m, n;

        outer: while (j) {
            b = edges[--j];
            a = edges[--j];
            i = j;
            while (i) {
                n = edges[--i]
                m = edges[--i]
                if ((a === m && b === n) || (a === n && b === m)) {
                    edges.splice(j, 2);
                    edges.splice(i, 2);
                    j -= 2;
                    continue outer;
                }
            }
        }
    }

    var delaunay = {
        triangulate: function(vertices, key) {
            var n = vertices.length,
                i, j, indices, open, closed, edges, dx, dy, a, b, c;

            /* Bail if there aren't enough vertices to form any triangles. */
            if (n < 3) {
                return [];
            }

            /* Slice out the actual vertices from the passed objects. (Duplicate the
            * array even if we don't, though, since we need to make a supertriangle
            * later on!) */
            vertices = vertices.slice(0);
            
            if (key) {
                for (i = n; i--; ) {
                    vertices[i] = vertices[i][key];
                }
            }

            /* Make an array of indices into the vertex array, sorted by the vertices'
            * x-position. */
            indices = new Array(n);

            for (i = n; i--; ) {
                indices[i] = i;
            }

            indices.sort(function(i, j) { return vertices[j][0] - vertices[i][0]; });

            /* Next, find the vertices of the supertriangle (which contains all other
            * triangles), and append them onto the end of a (copy of) the vertex
            * array. */
            appendSupertriangleVertices(vertices);

            /* Initialize the open list (containing the supertriangle and nothing else)
            * and the closed list (which is empty since we havn't processed any
            * triangles yet). */
            open   = [triangle(vertices, n + 0, n + 1, n + 2)];
            closed = [];
            edges  = [];

            /* Incrementally add each vertex to the mesh. */
            for (i = indices.length; i--; ) {
                c = indices[i];
                edges.length = 0;

                /* For each open triangle, check to see if the current point is
                 * inside it's circumcircle. If it is, remove the triangle and add
                 * it's edges to an edge list. */
                for (j = open.length; j--; ) {
                    /* If this point is to the right of this triangle's circumcircle,
                    * then this triangle should never get checked again. Remove it
                    * from the open list, add it to the closed list, and skip. */
                    dx = vertices[c][0] - open[j].x;
                    if (dx > 0.0 && dx * dx > open[j].r) {
                        closed.push(open[j]);
                        open.splice(j, 1);
                        continue;
                    }

                    /* If we're outside the circumcircle, skip this triangle. */
                    dy = vertices[c][1] - open[j].y;
                    if (dx * dx + dy * dy > open[j].r) {
                        continue;
                    }

                    /* Remove the triangle and add it's edges to the edge list. */
                    edges.push(
                        open[j].i, open[j].j,
                        open[j].j, open[j].k,
                        open[j].k, open[j].i
                    );
                    open.splice(j, 1);
                }

                /* Remove any doubled edges. */
                dedup(edges);

                /* Add a new triangle for each edge. */
                for(j = edges.length; j; ) {
                    b = edges[--j];
                    a = edges[--j];
                    open.push(triangle(vertices, a, b, c));
                }
            }

            /* Copy any remaining open triangles to the closed list, and then
            * remove any triangles that share a vertex with the supertriangle, building
            * a list of triplets that represent triangles. */
            for (i = open.length; i--; ) {
                closed.push(open[i]);
            }
            open.length = 0;

            for(i = closed.length; i--; ) {
                if(closed[i].i < n && closed[i].j < n && closed[i].k < n) {
                    var i1 = closed[i].i,
                        i2 = closed[i].j,
                        i3 = closed[i].k;
                    var tri = {
                        indices : [i1, i2, i3],
                        vertices : [vertices[i1], vertices[i2], vertices[i3]]
                    };
                    open.push(tri);
                }
            }

            /* Yay, we're done! */
            return open;
        },

        contains: function(tri, p) {
            /* Bounding box test first, for quick rejections. */
            if((p[0] < tri[0][0] && p[0] < tri[1][0] && p[0] < tri[2][0]) ||
              (p[0] > tri[0][0] && p[0] > tri[1][0] && p[0] > tri[2][0]) ||
              (p[1] < tri[0][1] && p[1] < tri[1][1] && p[1] < tri[2][1]) ||
              (p[1] > tri[0][1] && p[1] > tri[1][1] && p[1] > tri[2][1])) {

                return null;
            }

            var a = tri[1][0] - tri[0][0],
                b = tri[2][0] - tri[0][0],
                c = tri[1][1] - tri[0][1],
                d = tri[2][1] - tri[0][1],
                i = a * d - b * c;

            /* Degenerate tri. */
            if(i === 0.0) {
                return null;
            }

            var u = (d * (p[0] - tri[0][0]) - b * (p[1] - tri[0][1])) / i,
                v = (a * (p[1] - tri[0][1]) - c * (p[0] - tri[0][0])) / i;

            /* If we're outside the tri, fail. */
            if(u < 0.0 || v < 0.0 || (u + v) > 1.0) {
                return null;
            }
            
            // normalize
            // u = Math.max(0.0, u);
            // v = Math.max(0.0, v);
            // var s = u + v;
            // if (s > 1.0) {
            //     u = u / s;
            //     v = v / s;
            // }
            return [u, v];
        }
    }

    return delaunay;
});
// 2D Blend clip of blend tree
// http://docs.unity3d.com/Documentation/Manual/2DBlending.html
define('qtek/animation/Blend2DClip',['require','./Clip','../util/delaunay','../math/Vector2','glmatrix'],function(require) {

    var Clip = require('./Clip');

    var delaunay = require('../util/delaunay');
    var Vector2 = require('../math/Vector2');

    var glMatrix = require("glmatrix");
    var quat = glMatrix.quat;
    var vec3 = glMatrix.vec3;

    var Blend2DClip = function(opts) {

        opts = opts || {};
        
        Clip.call(this, opts);

        this.output = opts.output || null;

        // {
        //  position : Vector2()
        //  clip : Clip()
        //  offset : 0
        // }
        this.inputs = opts.inputs || [];

        this.position = new Vector2();

        this._cacheTriangle = null;

        this._triangles = [];

        this._updateTriangles();
    }

    Blend2DClip.prototype = new Clip();
    Blend2DClip.prototype.constructor = Blend2DClip;

    Blend2DClip.prototype.addInput = function(position, inputClip, offset) {
        var obj = {
            position : position,
            clip : inputClip,
            offset : offset || 0
        }
        this.inputs.push(obj);
        this.life = Math.max(inputClip.life, this.life);
        // TODO Change to incrementally adding
        this._updateTriangles();

        return obj;
    }

    // Delaunay triangulate
    Blend2DClip.prototype._updateTriangles = function() {
        var inputs = this.inputs.map(function(a) {
            return a.position;
        });
        this._triangles = delaunay.triangulate(inputs, '_array');
    }

    Blend2DClip.prototype.step = function(time) {

        var ret = Clip.prototype.step.call(this, time);

        if (ret !== 'destroy') {
            this.setTime(this._elapsedTime);
        }

        return ret;
    }

    Blend2DClip.prototype.setTime = function(time) {
        var res = this._findTriangle(this.position);
        if (!res) {
            return;
        }
        // In Barycentric
        var a = res[1]; // Percent of clip2
        var b = res[2]; // Percent of clip3

        var tri = res[0];

        var in1 = this.inputs[tri.indices[0]];
        var in2 = this.inputs[tri.indices[1]];
        var in3 = this.inputs[tri.indices[2]];
        var clip1 = in1.clip;
        var clip2 = in2.clip;
        var clip3 = in3.clip;

        clip1.setTime((time + in1.offset) % clip1.life);
        clip2.setTime((time + in2.offset) % clip2.life);
        clip3.setTime((time + in3.offset) % clip3.life);
        
        var c1 = clip1.output instanceof Clip ? clip1.output : clip1;
        var c2 = clip2.output instanceof Clip ? clip2.output : clip2;
        var c3 = clip3.output instanceof Clip ? clip3.output : clip3;

        this.output.blend2D(c1, c2, c3, a, b);
    }

    Blend2DClip.prototype._findTriangle = function(position) {
        if (this._cacheTriangle) {
            var res = delaunay.contains(this._cacheTriangle.vertices, position._array);
            if (res) {
                return [this._cacheTriangle, res[0], res[1]];
            }
        }
        for (var i = 0; i < this._triangles.length; i++) {
            var tri = this._triangles[i];
            var res = delaunay.contains(tri.vertices, this.position._array);
            if (res) {
                this._cacheTriangle = tri;
                return [tri, res[0], res[1]];
            }
        }
    }

    return Blend2DClip;
});
define('qtek/animation/TransformClip',['require','./Clip','glmatrix'],function(require) {

    
    
    var Clip = require('./Clip');

    var glMatrix = require("glmatrix");
    var quat = glMatrix.quat;
    var vec3 = glMatrix.vec3;

    function keyframeSort(a, b) {
        return a.time - b.time;
    }

    var TransformClip = function(options) {
        
        options = options || {};

        this.name = options.name || '';

        Clip.call(this, options);

        //[{
        //  time : //ms
        //  position :  // optional
        //  rotation :  // optional
        //  scale :     // optional
        //}]
        this.keyFrames = []
        if (options.keyFrames) {
            this.addKeyFrames(options.keyFrames)
        }

        this.position = vec3.create();
        this.rotation = quat.create();
        this.scale = vec3.fromValues(1, 1, 1);

        this._cacheKey = 0;
        this._cacheTime = 0;
    }

    TransformClip.prototype = Object.create(Clip.prototype);

    TransformClip.prototype.constructor = TransformClip;

    TransformClip.prototype.step = function(time) {

        var ret = Clip.prototype.step.call(this, time);

        if (ret !== 'destroy') {
            this.setTime(this._elapsedTime);
        }

        return ret;
    }

    TransformClip.prototype.setTime = function(time) {
        this._interpolateField(time, 'position');
        this._interpolateField(time, 'rotation');
        this._interpolateField(time, 'scale');   
    }

    TransformClip.prototype.addKeyFrame = function(kf) {
        for (var i = 0; i < this.keyFrames.length - 1; i++) {
            var prevFrame = this.keyFrames[i];
            var nextFrame = this.keyFrames[i+1];
            if (prevFrame.time <= kf.time && nextFrame.time >= kf.time) {
                this.keyFrames.splice(i, 0, kf);
                return i;
            }
        }

        this.life = kf.time;
        this.keyFrames.push(kf);
    }

    TransformClip.prototype.addKeyFrames = function(kfs) {
        for (var i = 0; i < kfs.length; i++) {
            this.keyFrames.push(kfs[i]);
        }

        this.keyFrames.sort(keyframeSort);

        this.life = this.keyFrames[this.keyFrames.length - 1].time;
    }

    TransformClip.prototype._interpolateField = function(time, fieldName) {
        var kfs = this.keyFrames;
        var len = kfs.length;
        var start;
        var end;

        if (!kfs.length) {
            return;
        }
        if (time < kfs[0].time || time > kfs[kfs.length-1].time) {
            return;
        }
        if (time < this._cacheTime) {
            var s = this._cacheKey >= len-1 ? len-1 : this._cacheKey+1;
            for (var i = s; i >= 0; i--) {
                if (kfs[i].time <= time && kfs[i][fieldName]) {
                    start = kfs[i];
                    this._cacheKey = i;
                    this._cacheTime = time;
                } else if (kfs[i][fieldName]) {
                    end = kfs[i];
                    break;
                }
            }
        } else {
            for (var i = this._cacheKey; i < len; i++) {
                if (kfs[i].time <= time && kfs[i][fieldName]) {
                    start = kfs[i];
                    this._cacheKey = i;
                    this._cacheTime = time;
                } else if (kfs[i][fieldName]) {
                    end = kfs[i];
                    break;
                }
            }
        }

        if (start && end) {
            var percent = (time-start.time) / (end.time-start.time);
            percent = Math.max(Math.min(percent, 1), 0);
            if (fieldName === "rotation") {
                quat.slerp(this[fieldName], start[fieldName], end[fieldName], percent);
            } else {
                vec3.lerp(this[fieldName], start[fieldName], end[fieldName], percent);
            }
        } else {
            this._cacheKey = 0;
            this._cacheTime = 0;
        }
    }

    TransformClip.prototype.blend1D = function(c1, c2, w) {
        vec3.lerp(this.position, c1.position, c2.position, w);
        vec3.lerp(this.scale, c1.scale, c2.scale, w);
        quat.slerp(this.rotation, c1.rotation, c2.rotation, w);
    }

    TransformClip.prototype.blend2D = (function() {
        var q1 = quat.create();
        var q2 = quat.create();
        return function(c1, c2, c3, f, g) {
            var a = 1 - f - g;

            this.position[0] = c1.position[0] * a + c2.position[0] * f + c3.position[0] * g;
            this.position[1] = c1.position[1] * a + c2.position[1] * f + c3.position[1] * g;
            this.position[2] = c1.position[2] * a + c2.position[2] * f + c3.position[2] * g;

            this.scale[0] = c1.scale[0] * a + c2.scale[0] * f + c3.scale[0] * g;
            this.scale[1] = c1.scale[1] * a + c2.scale[1] * f + c3.scale[1] * g;
            this.scale[2] = c1.scale[2] * a + c2.scale[2] * f + c3.scale[2] * g;

            // http://msdn.microsoft.com/en-us/library/windows/desktop/bb205403(v=vs.85).aspx
            // http://msdn.microsoft.com/en-us/library/windows/desktop/microsoft.directx_sdk.quaternion.xmquaternionbarycentric(v=vs.85).aspx
            var s = f + g;
            if (s === 0) {
                quat.copy(this.rotation, c1.rotation);
            } else {
                quat.slerp(q1, c1.rotation, c2.rotation, s);
                quat.slerp(q2, c1.rotation, c3.rotation, s);
                quat.slerp(this.rotation, q1, q2, g / s);
            }
        }
    })(),

    TransformClip.prototype.additiveBlend = function(c1, c2) {
        vec3.add(this.position, c1.position, c2.position);
        vec3.add(this.scale, c1.scale, c2.scale);
        quat.multiply(this.rotation, c2.rotation, c1.rotation);
    }

    TransformClip.prototype.subtractiveBlend = function(c1, c2) {
        vec3.sub(this.position, c1.position, c2.position);
        vec3.sub(this.scale, c1.scale, c2.scale);
        quat.invert(this.rotation, c2.rotation);
        quat.multiply(this.rotation, this.rotation, c1.rotation);
    }

    TransformClip.prototype.getSubClip = function(startTime, endTime) {
        // TODO
        console.warn('TODO');
    }

    return TransformClip;
});
// Sampler clip is especially for the animation sampler in glTF
// Use Typed Array can reduce a lot of heap memory
define('qtek/animation/SamplerClip',['require','./Clip','./TransformClip','glmatrix'],function(require) {

    

    var Clip = require('./Clip');
    var TransformClip = require('./TransformClip');

    var glMatrix = require("glmatrix");
    var quat = glMatrix.quat;
    var vec3 = glMatrix.vec3;

    // lerp function with offset in large array
    function vec3lerp(out, a, b, t, oa, ob) {
        var ax = a[oa];
        var ay = a[oa + 1];
        var az = a[oa + 2];
        out[0] = ax + t * (b[ob] - ax);
        out[1] = ay + t * (b[ob + 1] - ay);
        out[2] = az + t * (b[ob + 2] - az);

        return out;
    }

    function quatSlerp(out, a, b, t, oa, ob) {
        // benchmarks:
        //    http://jsperf.com/quaternion-slerp-implementations

        var ax = a[0 + oa], ay = a[1 + oa], az = a[2 + oa], aw = a[3 + oa],
            bx = b[0 + ob], by = b[1 + ob], bz = b[2 + ob], bw = b[3 + ob];

        var omega, cosom, sinom, scale0, scale1;

        // calc cosine
        cosom = ax * bx + ay * by + az * bz + aw * bw;
        // adjust signs (if necessary)
        if (cosom < 0.0) {
            cosom = -cosom;
            bx = - bx;
            by = - by;
            bz = - bz;
            bw = - bw;
        }
        // calculate coefficients
        if ((1.0 - cosom) > 0.000001) {
            // standard case (slerp)
            omega  = Math.acos(cosom);
            sinom  = Math.sin(omega);
            scale0 = Math.sin((1.0 - t) * omega) / sinom;
            scale1 = Math.sin(t * omega) / sinom;
        } else {        
            // "from" and "to" quaternions are very close 
            //  ... so we can do a linear interpolation
            scale0 = 1.0 - t;
            scale1 = t;
        }
        // calculate final values
        out[0] = scale0 * ax + scale1 * bx;
        out[1] = scale0 * ay + scale1 * by;
        out[2] = scale0 * az + scale1 * bz;
        out[3] = scale0 * aw + scale1 * bw;
        
        return out;
    };

    var SamplerClip = function(options) {

        options = options || {};

        this.name = options.name || '';

        Clip.call(this, options);

        this.position = vec3.create();
        this.rotation = quat.create();
        this.scale = vec3.fromValues(1, 1, 1);

        this.channels = {
            time : null,
            position : null,
            rotation : null,
            scale : null
        }

        this._cacheKey = 0;
        this._cacheTime = 0;
    }

    SamplerClip.prototype = Object.create(Clip.prototype);

    SamplerClip.prototype.constructor = SamplerClip;

    SamplerClip.prototype.step = function(time) {

        var ret = Clip.prototype.step.call(this, time);

        if (ret !== 'destroy') {
            this.setTime(this._elapsedTime);
        }

        return ret;
    }

    SamplerClip.prototype.setTime = function(time) {
        if (!this.channels.time) {
            return;
        }
        var channels = this.channels;
        var len = channels.time.length;
        var key = -1;
        if (time < this._cacheTime) {
            var s = Math.min(len-2, this._cacheKey);
            for (var i = s; i >= 0; i--) {
                if (channels.time[i-1] <= time && channels.time[i] > time) {
                    key = i - 1;
                    break;
                }
            }
        } else {
            for (var i = this._cacheKey; i < len-1; i++) {
                if (channels.time[i] <= time && channels.time[i+1] > time) {
                    key = i;
                    break;
                }
            }
        }

        if (key > -1) {
            this._cacheKey = i;
            this._cacheTime = time;
            var start = key;
            var end = key+1;
            var startTime = channels.time[start];
            var endTime = channels.time[end];
            var percent = (time-startTime) / (endTime-startTime);

            if (channels.rotation) {
                quatSlerp(this.rotation, channels.rotation, channels.rotation, percent, start * 4, end * 4);
            }
            if (channels.position) {
                vec3lerp(this.position, channels.position, channels.position, percent, start * 3, end * 3);
            }
            if (channels.scale) {
                vec3lerp(this.scale, channels.scale, channels.scale, percent, start * 3, end * 3);
            }
        }
        // Loop handling
        if (key == len - 2) {
            this._cacheKey = 0;
            this._cacheTime = 0;
        }
    }

    SamplerClip.prototype.getSubClip = function(startTime, endTime) {

        var subClip = new SamplerClip({
            name : this.name
        });
        var minTime = this.channels.time[0];
        startTime = Math.min(Math.max(startTime, minTime), this.life);
        endTime = Math.min(Math.max(endTime, minTime), this.life);
            
        var rangeStart = this._findRange(startTime);
        var rangeEnd = this._findRange(endTime);

        var count = rangeEnd[0] - rangeStart[0] + 1;
        if (rangeStart[1] === 0 && rangeEnd[1] === 0) {
            count -= 1;
        }
        if (this.channels.rotation) {
            subClip.channels.rotation = new Float32Array(count * 4);
        }
        if (this.channels.position) {
            subClip.channels.position = new Float32Array(count * 3);
        }
        if (this.channels.scale) {
            subClip.channels.scale = new Float32Array(count * 3);
        }
        if (this.channels.time) {
            subClip.channels.time = new Float32Array(count);
        }
        // Clip at the start
        this.setTime(startTime);
        for (var i = 0; i < 3; i++) {
            subClip.channels.rotation[i] = this.rotation[i];
            subClip.channels.position[i] = this.position[i];
            subClip.channels.scale[i] = this.scale[i];
        }
        subClip.channels.time[0] = 0;
        subClip.channels.rotation[3] = this.rotation[3];

        for (var i = 1; i < count-1; i++) {
            for (var j = 0; j < 3; j++) {
                var i2 = rangeStart[0] + i;
                subClip.channels.rotation[i * 4 + j] = this.channels.rotation[i2 * 4 + j];
                subClip.channels.position[i * 3 + j] = this.channels.position[i2 * 3 + j];
                subClip.channels.scale[i * 3 + j] = this.channels.scale[i2 * 3 + j];
            }   
            subClip.channels.time[i] = this.channels.time[i2] - startTime;
            subClip.channels.rotation[i * 4 + 3] = this.channels.rotation[i2 * 4 + 3];
        }
        // Clip at the end
        this.setTime(endTime);
        for (var i = 0; i < 3; i++) {
            subClip.channels.rotation[(count - 1) * 4 + i] = this.rotation[i];
            subClip.channels.position[(count - 1) * 3 + i] = this.position[i];
            subClip.channels.scale[(count - 1) * 3 + i] = this.scale[i];
        }
        subClip.channels.time[(count - 1)] = endTime - startTime;
        subClip.channels.rotation[(count - 1) * 4 + 3] = this.rotation[3];

        // TODO set back ?
        subClip.life = endTime - startTime;
        return subClip;
    },

    SamplerClip.prototype._findRange = function(time) {
        var channels = this.channels;
        var len = channels.time.length;
        var start = -1;
        for (var i = 0; i < len - 1; i++) {
            if (channels.time[i] <= time && channels.time[i+1] > time) {
                start = i;
            }
        }
        var percent = 0;
        if (start >= 0) {
            var startTime = channels.time[start];
            var endTime = channels.time[start+1];
            var percent = (time-startTime) / (endTime-startTime);
        }
        // Percent [0, 1)
        return [start, percent];
    }

    SamplerClip.prototype.blend1D = TransformClip.prototype.blend1D;
    SamplerClip.prototype.blend2D = TransformClip.prototype.blend2D;
    SamplerClip.prototype.additiveBlend = TransformClip.prototype.additiveBlend;
    SamplerClip.prototype.subtractiveBlend = TransformClip.prototype.subtractiveBlend;

    return SamplerClip;
});
define('qtek/animation/SkinningClip',['require','./Clip','./TransformClip','glmatrix'],function(require) {

    

    var Clip = require('./Clip');

    var TransformClip = require('./TransformClip');

    var glMatrix = require("glmatrix");
    var quat = glMatrix.quat;
    var vec3 = glMatrix.vec3;

    var SkinningClip = function(options) {

        options = options || {};

        this.name = options.name || '';

        Clip.call(this, options);

        this.jointClips = [];

        this.life = 0;
        if (options.jointClips && options.jointClips.length > 0) {    
            for (var j = 0; j < options.jointClips.length; j++) {
                var jointPoseCfg = options.jointClips[j];
                var jointClip = new TransformClip({
                    keyFrames : jointPoseCfg.keyFrames
                });
                jointClip.name = jointPoseCfg.name || '';
                this.jointClips[j] = jointClip;

                this.life = Math.max(jointClip.life, this.life);
            }
        }
    }

    SkinningClip.prototype = Object.create(Clip.prototype);

    SkinningClip.prototype.constructor = SkinningClip;

    SkinningClip.prototype.step = function(time) {

        var ret = Clip.prototype.step.call(this, time);

        if (ret !== 'destroy') {
            this.setTime(this._elapsedTime);
        }

        return ret;
    }

    SkinningClip.prototype.setTime = function(time) {
        for (var i = 0; i < this.jointClips.length; i++) {
            this.jointClips[i].setTime(time);
        }
    }

    SkinningClip.prototype.addJointClip = function(jointClip) {
        this.jointClips.push(jointClip);
        this.life = Math.max(jointClip.life, this.life);
    }

    SkinningClip.prototype.removeJointClip = function(jointClip) {
        this.jointClips.splice(this.jointClips.indexOf(jointClip), 1);
    }

    SkinningClip.prototype.getSubClip = function(startTime, endTime, isLoop) {
        var subClip = new SkinningClip({
            name : this.name
        });

        for (var i = 0; i < this.jointClips.length; i++) {
            var subJointClip = this.jointClips[i].getSubClip(startTime, endTime);
            subClip.addJointClip(subJointClip);
        }

        if (isLoop !== undefined) {
            subClip.setLoop(isLoop);
        }

        return subClip; 
    }

    SkinningClip.prototype.blend1D = function(clip1, clip2, w) {
        for (var i = 0; i < this.jointClips.length; i++) {
            var c1 = clip1.jointClips[i];
            var c2 = clip2.jointClips[i];
            var tClip = this.jointClips[i];

            tClip.blend1D(c1, c2, w);
        }
    }

    SkinningClip.prototype.additiveBlend = function(clip1, clip2) {
        for (var i = 0; i < this.jointClips.length; i++) {
            var c1 = clip1.jointClips[i];
            var c2 = clip2.jointClips[i];
            var tClip = this.jointClips[i];

            tClip.additiveBlend(c1, c2);
        }
    }

    SkinningClip.prototype.subtractiveBlend = function(clip1, clip2) {
        for (var i = 0; i < this.jointClips.length; i++) {
            var c1 = clip1.jointClips[i];
            var c2 = clip2.jointClips[i];
            var tClip = this.jointClips[i];

            tClip.subtractiveBlend(c1, c2);
        }
    }

    SkinningClip.prototype.blend2D = function(clip1, clip2, clip3, f, g) {
        for (var i = 0; i < this.jointClips.length; i++) {
            var c1 = clip1.jointClips[i];
            var c2 = clip2.jointClips[i];
            var c3 = clip3.jointClips[i];
            var tClip = this.jointClips[i];

            tClip.blend2D(c1, c2, c3, f, g);
        }
    }

    SkinningClip.prototype.copy = function(clip) {
        for (var i = 0; i < this.jointClips.length; i++) {
            var sClip = clip.jointClips[i];
            var tClip = this.jointClips[i];

            vec3.copy(tClip.position, sClip.position);
            vec3.copy(tClip.scale, sClip.scale);
            quat.copy(tClip.rotation, sClip.rotation);
        }
    }

    return SkinningClip;
});
/**
 *  @export{object} request
 */
define('qtek/core/request',['require'],function(require) {

    function get(options) {

        var xhr = new XMLHttpRequest();

        xhr.open("get", options.url);
        // With response type set browser can get and put binary data
        // https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/Sending_and_Receiving_Binary_Data
        // Default is text, and it can be set
        // arraybuffer, blob, document, json, text
        xhr.responseType = options.responseType || "text";

        if (options.onprogress) {
            //https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/Using_XMLHttpRequest
            xhr.onprogress = function(e) {
                if (e.lengthComputable) {
                    var percent = e.loaded / e.total;
                    options.onprogress(percent, e.loaded, e.total);
                } else {
                    options.onprogress(null);
                }
            }
        }
        xhr.onload = function(e) {
            options.onload && options.onload(xhr.response);
        }
        if (options.onerror) {
            xhr.onerror = options.onerror;
        }
        xhr.send(null);
    }

    return {
        get : get
    }
});
define('qtek/async/Task',['require','../core/mixin/notifier','../core/request','../core/util'],function(require) {

    var notifier = require('../core/mixin/notifier');
    var request = require('../core/request');
    var util  = require('../core/util');
    
    var Task = function() {
        this._fullfilled = false;
        this._rejected = false;
    }
    Task.prototype.resolve = function(data) {
        this._fullfilled = true;
        this._rejected = false;
        this.trigger('success', data);
    }
    Task.prototype.reject = function(err) {
        this._rejected = true;
        this._fullfilled = false;
        this.trigger('error', err);
    }
    Task.prototype.isFullfilled = function() {
        return this._fullfilled;
    }
    Task.prototype.isRejected = function() {
        return this._rejected;
    }
    Task.prototype.isSettled = function() {
        return this._fullfilled || this._rejected;
    }
    
    util.extend(Task.prototype, notifier);

    function makeRequestTask(url, responseType) {
        var task = new Task();
        request.get({
            url : url,
            responseType : responseType,
            onload : function(res) {
                task.resolve(res);
            },
            onerror : function() {
                self.reject(error);
            }
        });
        return task;
    };

    Task.makeRequestTask = function(url, responseType) {
        var self = this;
        if (typeof url === 'string') {
            return makeRequestTask(url, responseType);
        } else if (url.url) {   //  Configure object
            var obj = url;
            return makeRequestTask(obj.url, obj.responseType);
        } else if (url instanceof Array) {  // Url list
            var count = 0;
            var urlList = url;
            var tasks = [];
            urlList.forEach(function(obj) {
                var url, responseType;
                if (typeof obj === 'string') {
                    url = obj;
                } else if (Object(obj) === obj) {
                    url = obj.url;
                    responseType = obj.responseType;
                }
                tasks.push(makeRequestTask(url, responseType));
            });
            return tasks;
        }
    }

    Task.makeTask = function(obj) {
        return new Task(obj);
    }

    util.extend(Task.prototype, notifier);

    return Task;
});
define('qtek/async/TaskGroup',['require','../core/util','./Task'],function(require) {

    var util  = require('../core/util');
    var Task = require('./Task');

    var TaskGroup = function() {

        Task.apply(this, arguments);

        this._tasks = [];

        this._fulfilledNumber = 0;

        this._rejectedNumber = 0;
    };

    var Ctor = function(){};
    Ctor.prototype = Task.prototype;
    TaskGroup.prototype = new Ctor();

    TaskGroup.prototype.constructor = TaskGroup;

    TaskGroup.prototype.all = function(tasks) {
        var count = tasks.length;
        var self = this;
        var data = [];
        if (tasks.length == 0) {
            setTimeout(function() {
                self.resolve(data);
            });
            return this;
        }
        this._tasks = tasks;
        this._fulfilledNumber = 0;
        this._rejectedNumber = 0;

        util.each(tasks, function(task, idx) {
            task.once('success', function(res) {
                count--;

                self._fulfilledNumber++;
                // TODO
                // Some tasks like texture, loader are not inherited from task
                // We need to set the deferred status here
                task._fulfilled = true;
                task._rejected = false;

                data[idx] = res;
                if (count === 0) {
                    self.resolve(data);
                }
            });
            task.once('error', function() {
                
                self._rejectedNumber ++;

                task._fulfilled = false;
                task._rejected = true;

                self.reject(task);
            });
        });
        return this;
    };

    TaskGroup.prototype.allSettled = function(tasks) {
        var count = tasks.length;
        var success = false;
        var self = this;
        var data = [];
        if (tasks.length == 0) {
            setTimeout(function() {
                self.trigger('success', data);
            });
            return this;
        }
        this._tasks = tasks;

        util.each(tasks, function(task, idx) {
            task.once('success', function(res) {
                count--;
                
                self._fulfilledNumber++;

                task._fulfilled = true;
                task._rejected = false;

                data[idx] = res;
                success = true;
                if (count === 0) {
                    self.resolve(data);
                }
            });
            task.once('error', function(err) {
                count--;

                self._rejectedNumber++;

                task._fulfilled = false;
                task._rejected = true;

                // TODO 
                data[idx] = null;
                if (count === 0) {
                    if (success) {
                        self.resolve(data);
                    } else {
                        self.reject(data);
                    }
                }
            });
        });
        return this;
    }

    TaskGroup.prototype.getFulfilledNumber = function(recursive) {
        if (recursive) {
            var nFulfilled = 0;
            for (var i = 0; i < this._tasks.length; i++) {
                var task = this._tasks[i];
                if (task instanceof TaskGroup) {
                    nFulfilled += task.getFulfilledNumber(recursive);
                } else if(task._fulfilled) {
                    nFulfilled += 1;
                }
            }
            return nFulfilled;
        } else {
            return this._fulfilledNumber;
        }
    }

    TaskGroup.prototype.getRejectedNumber = function(recursive) {
        if (recursive) {
            var nRejected = 0;
            for (var i = 0; i < this._tasks.length; i++) {
                var task = this._tasks[i];
                if (task instanceof TaskGroup) {
                    nRejected += task.getRejectedNumber(recursive);
                } else if(task._rejected) {
                    nRejected += 1;
                }
            }
            return nRejected;
        } else {
            return this._rejectedNumber;
        }
    }

    TaskGroup.prototype.getSettledNumber = function(recursive) {

        if (recursive) {
            var nSettled = 0;
            for (var i = 0; i < this._tasks.length; i++) {
                var task = this._tasks[i];
                if (task instanceof TaskGroup) {
                    nSettled += task.getSettledNumber(recursive);
                } else if(task._rejected || task._fulfilled) {
                    nSettled += 1;
                }
            }
            return nSettled;
        } else {
            return this._fulfilledNumber + this._rejectedNumber;
        }
    }

    TaskGroup.prototype.getTaskNumber = function(recursive) {
        if (recursive) {
            var nTask = 0;
            for (var i = 0; i < this._tasks.length; i++) {
                var task = this._tasks[i];
                if (task instanceof TaskGroup) {
                    nTask += task.getTaskNumber(recursive);
                } else {
                    nTask += 1;
                }
            }
            return nTask;
        } else {
            return this._tasks.length;
        }
    }

    return TaskGroup;
});
define('qtek/camera/Orthographic',['require','../Camera'],function(require) {

    var Camera = require('../Camera');

    var Orthographic = Camera.derive({
        left : -1,
        right : 1,
        near : -1,
        far : 1,
        top : 1,
        bottom : -1
    }, {
        
        updateProjectionMatrix : function() {
            this.projectionMatrix.ortho(this.left, this.right, this.bottom, this.top, this.near, this.far);
        },

        clone: function() {
            var camera = Camera.prototype.clone.call(this);
            camera.left = this.left;
            camera.right = this.right;
            camera.near = this.near;
            camera.far = this.far;
            camera.top = this.top;
            camera.bottom = this.bottom;

            return camera;
        }
    });

    return Orthographic;
} );
define('qtek/compositor/Graph',['require','../core/Base'],function(require) {

    var Base = require("../core/Base");

    var Graph = Base.derive(function() {
        return {
            nodes : []
        }
    }, {
        
        addNode : function(node) {

            this.nodes.push(node);

            this._dirty = true;
        },

        removeNode : function(node) {
            this.nodes.splice(this.nodes.indexOf(node), 1);

            this._dirty = true;
        },

        findNode : function(name) {
            for (var i = 0; i < this.nodes.length; i++) {
                if (this.nodes[i].name === name) {
                    return this.nodes[i];
                }
            }
        },

        update : function() {
            for (var i = 0; i < this.nodes.length; i++) {
                this.nodes[i].clear();
            }
            // Traverse all the nodes and build the graph
            for (var i = 0; i < this.nodes.length; i++) {
                var node = this.nodes[i];

                if (!node.inputs) {
                    continue;
                }
                for (var inputName in node.inputs) {
                    var fromPinInfo = node.inputs[inputName];

                    var fromPin = this.findPin(fromPinInfo);
                    if (fromPin) {
                        node.link(inputName, fromPin.node, fromPin.pin);
                    }else{
                        console.warn("Pin of "+fromPinInfo.node+"."+fromPinInfo.pin+" not exist");
                    }
                }
            }
        },

        findPin : function(input) {
            var node;
            if (typeof(input.node) === 'string') {
                for (var i = 0; i < this.nodes.length; i++) {
                    var tmp = this.nodes[i];
                    if (tmp.name === input.node) {
                        node = tmp;
                    }
                }
            } else {
                node = input.node;
            }
            if (node) {
                if (node.outputs[input.pin]) {
                    return {
                        node : node,
                        pin : input.pin
                    }
                }
            }
        },

        fromJSON : function(json) {

        }
    })
    
    return Graph;
});
define('qtek/compositor/Compositor',['require','./Graph'],function(require){

    

    var Graph = require("./Graph");

    var Compositor = Graph.derive(function() {
        return {
            // Output node
            _outputs : []
        }
    }, {
        addNode : function(node) {
            Graph.prototype.addNode.call(this, node);
            if (!node.outputs) {
                this.addOutput(node);
            }
        },

        render : function(renderer) {
            if (this._dirty) {
                this.update();
                this._dirty = false;
            }
            for (var i = 0; i < this.nodes.length; i++) {
                // Update the reference number of each output texture
                this.nodes[i].beforeFrame();
            }

            for (var i = 0; i < this._outputs.length; i++) {
                this._outputs[i].updateReference();
            }
            for (var i = 0; i < this._outputs.length; i++) {
                this._outputs[i].render(renderer);
            }

            for (var i = 0; i < this.nodes.length; i++) {
                // Clear up
                this.nodes[i].afterFrame();
            }
        },

        addOutput : function(node) {
            if (this._outputs.indexOf(node) < 0) {
                this._outputs.push(node);
            }
        },

        removeOutput : function(node) {
            this._outputs.splice(this._outputs.indexOf(node), 1);
        }
    })

    return Compositor;
});
define('qtek/geometry/Plane',['require','../DynamicGeometry','../math/BoundingBox'],function(require) {

    var DynamicGeometry = require('../DynamicGeometry');
    var BoundingBox = require('../math/BoundingBox');

    var Plane = DynamicGeometry.derive({
        widthSegments : 1,
        heightSegments : 1
    }, function() {

        var heightSegments = this.heightSegments;
        var widthSegments = this.widthSegments;
        var positions = this.attributes.position.value;
        var texcoords = this.attributes.texcoord0.value;
        var normals = this.attributes.normal.value;
        var faces = this.faces;         

        for (var y = 0; y <= heightSegments; y++) {
            var t = y / heightSegments;
            for (var x = 0; x <= widthSegments; x++) {
                var s = x / widthSegments;

                positions.push([2 * s - 1, 2 * t - 1, 0]);
                if (texcoords) {
                    texcoords.push([s, t]);
                }
                if (normals) {
                    normals.push([0, 0, 1]);
                }
                if (x < widthSegments && y < heightSegments) {
                    var i = x + y * (widthSegments + 1);
                    faces.push([i, i + 1, i + widthSegments + 1]);
                    faces.push([i + widthSegments + 1, i + 1, i + widthSegments + 2]);
                }
            }
        }

        this.boundingBox = new BoundingBox();
        this.boundingBox.min.set(-1, -1, 0);
        this.boundingBox.max.set(1, 1, 0);
    })

    return Plane;
});
define('qtek/compositor/Pass',['require','../core/Base','../Scene','../camera/Orthographic','../geometry/Plane','../Shader','../Material','../Mesh','../Scene','../Texture','../core/glinfo','../core/glenum'],function(require) {

    var Base = require("../core/Base");
    var Scene = require("../Scene");
    var OrthoCamera = require('../camera/Orthographic');
    var Plane = require('../geometry/Plane');
    var Shader = require('../Shader');
    var Material = require('../Material');
    var Mesh = require('../Mesh');
    var Scene = require('../Scene');
    var Texture = require('../Texture');
    var glinfo = require('../core/glinfo');
    var glenum = require('../core/glenum');

    var planeGeo = new Plane();
    var mesh = new Mesh({
        geometry : planeGeo
    });
    var camera = new OrthoCamera();

    var Pass = Base.derive(function() {
        return {
            // Fragment shader string
            fragment : "",

            outputs : null,

            material : null
        }
    }, function() {

        var shader = new Shader({
            vertex : Shader.source('buildin.compositor.vertex'),
            fragment : this.fragment
        })
        var material = new Material({
            shader : shader
        });
        shader.enableTexturesAll();

        this.material = material;

    }, {

        setUniform : function(name, value) {
            var uniform = this.material.uniforms[name];
            if (uniform) {
                uniform.value = value;
            }
        },

        getUniform : function(name) {
            var uniform = this.material.uniforms[name];
            if (uniform) {
                return uniform.value;
            }
        },

        attachOutput : function(texture, attachment) {
            if (!this.outputs) {
                this.outputs = {};
            }
            attachment = attachment || glenum.COLOR_ATTACHMENT0;
            this.outputs[attachment] = texture;
        },

        detachOutput : function(texture) {
            for (var attachment in this.outputs) {
                if (this.outputs[attachment] === texture) {
                    this.outputs[attachment] = null;
                }
            }
        },

        bind : function(renderer, frameBuffer) {
            
            if (this.outputs) {
                for (var attachment in this.outputs) {
                    var texture = this.outputs[attachment];
                    if (texture) {
                        frameBuffer.attach(renderer.gl, texture, attachment);
                    }
                }
                frameBuffer.bind(renderer);
            }
        },

        unbind : function(renderer, frameBuffer) {
            frameBuffer.unbind(renderer);
        },

        render : function(renderer, frameBuffer) {

            var _gl = renderer.gl;

            mesh.material = this.material;

            if (frameBuffer) {
                this.bind(renderer, frameBuffer);
                // MRT Support in chrome
                // https://www.khronos.org/registry/webgl/sdk/tests/conformance/extensions/ext-draw-buffers.html
                var ext = glinfo.getExtension(_gl, "EXT_draw_buffers");
                if (ext) {
                    var bufs = [];
                    for (var attachment in this.outputs) {
                        attachment = +attachment;
                        if (attachment >= _gl.COLOR_ATTACHMENT0 && attachment <= _gl.COLOR_ATTACHMENT0 + 8) {
                            bufs.push(attachment);
                        }
                    }
                    ext.drawBuffersEXT(bufs);
                }
            }

            this.trigger("beforerender", this, renderer);
            // Don't clear in each pass, let the color overwrite the buffer
            _gl.disable(_gl.BLEND);
            _gl.clear(_gl.DEPTH_BUFFER_BIT);
            renderer.renderQueue([mesh], camera);
            this.trigger("afterrender", this, renderer);

            if (frameBuffer) {
                this.unbind(renderer, frameBuffer);
            }
        }
    })

    return Pass;
});
define('qtek/compositor/texturePool',['require','../texture/Texture2D','../core/glenum','../core/util'],function(require) {
    
    var Texture2D = require('../texture/Texture2D');
    var glenum = require('../core/glenum');
    var util = require('../core/util');

    var pool = {};

    var allocatedTextures = [];

    var texturePool = {

        get : function(parameters) {
            var key = generateKey(parameters);
            if (!pool.hasOwnProperty(key)) {
                pool[key] = [];
            }
            var list = pool[key];
            if (!list.length) {
                var texture = new Texture2D(parameters);
                allocatedTextures.push(texture);
                return texture;
            }
            return list.pop();
        },

        put : function(texture) {
            var key = generateKey(texture);
            if (!pool.hasOwnProperty(key)) {
                pool[key] = [];
            }
            var list = pool[key];
            list.push(texture);
        },

        clear : function(gl) {
            for (i = 0; i < allocatedTextures.length; i++) {
                allocatedTextures[i].dispose(gl);
            }
            pool = {};
            allocatedTextures = [];
        }
    }

    var defaultParams = {
        width : 512,
        height : 512,
        type : glenum.UNSIGNED_BYTE,
        format : glenum.RGBA,
        wrapS : glenum.CLAMP_TO_EDGE,
        wrapT : glenum.CLAMP_TO_EDGE,
        minFilter : glenum.LINEAR_MIPMAP_LINEAR,
        magFilter : glenum.LINEAR,
        useMipmap : true,
        anisotropic : 1,
        flipY : true,
        unpackAlignment : 4,
        premultiplyAlpha : false
    }

    var defaultParamPropList = Object.keys(defaultParams);

    function generateKey(parameters) {
        util.defaultsWithPropList(parameters, defaultParams, defaultParamPropList);
        fallBack(parameters);

        var key = '';
        for (var i = 0; i < defaultParamPropList.length; i++) {
            var name = defaultParamPropList[i];
            var chunk = parameters[name].toString();
            key += chunk;
        }
        return key;
    }

    function fallBack(target) {

        var IPOT = isPowerOfTwo(target.width, target.height);

        if (target.format === glenum.DEPTH_COMPONENT) {
            target.useMipmap = false;
        }

        if (!IPOT || !target.useMipmap) {
            if (target.minFilter == glenum.NEAREST_MIPMAP_NEAREST ||
                target.minFilter == glenum.NEAREST_MIPMAP_LINEAR) {
                target.minFilter = glenum.NEAREST;
            } else if (
                target.minFilter == glenum.LINEAR_MIPMAP_LINEAR ||
                target.minFilter == glenum.LINEAR_MIPMAP_NEAREST
            ) {
                target.minFilter = glenum.LINEAR
            }

            target.wrapS = glenum.CLAMP_TO_EDGE;
            target.wrapT = glenum.CLAMP_TO_EDGE;
        }
    }

    function isPowerOfTwo(width, height) {
        return (width & (width-1)) === 0 &&
                (height & (height-1)) === 0;
    }

    return texturePool;
});
/**
 * Example
 * {
 *  name : "xxx",
 *  shader : shader,
 *  inputs :{ 
 *      "texture" : {
 *          node : "xxx",
 *          pin : "diffuse"
        }
    },
    outputs : {
            color : {
                attachment : FrameBuffer.COLOR_ATTACHMENT0
                parameters : {
                    format : Texture.RGBA,
                    width : 512,
                    height : 512
                },
                // Node will keep the texture rendered in last frame
                keepLastFrame : true,
                // Force the node output the texture rendered in last frame
                outputLastFrame : true
            }
        }
    }
 * Multiple outputs is reserved for MRT support in WebGL2.0
 *
 * TODO blending 
 */
define('qtek/compositor/Node',['require','../core/Base','./Pass','../FrameBuffer','../Shader','./texturePool'],function(require) {

    

    var Base = require("../core/Base");
    var Pass = require("./Pass");
    var FrameBuffer = require("../FrameBuffer");
    var Shader = require("../Shader");
    var texturePool = require("./texturePool");

    var Node = Base.derive(function() {
        return {

            name : "",

            inputs : {},
            
            outputs : null,

            shader : '',
            /**
             * Input links, will be auto updated by the graph
             * Example:
             * inputName : {
             *     node : [Node],
             *     pin : 'xxxx'    
             * }
             * @type {Object}
             */
            inputLinks : {},
            /**
             * Output links, will be auto updated by the graph
             * Example:
             * outputName : {
             *     node : [Node],
             *     pin : 'xxxx'    
             * }
             * @type {Object}
             */
            outputLinks : {},
            /**
             * @type {qtek.compositor.Pass}
             */
            pass : null,

            // Save the output texture of previous frame
            // Will be used when there exist a circular reference
            _prevOutputTextures : {},
            _outputTextures : {},
            //{
            //  name : 2
            //}
            _outputReferences : {},

            _rendering : false,
            // If rendered in this frame
            _rendered : false
        }
    }, function() {
        
        var pass = new Pass({
            fragment : this.shader
        });
        this.pass = pass;

        if (this.outputs) {
            this.frameBuffer = new FrameBuffer({
                depthBuffer : false
            })
        }
    }, {
        /**
         * Do rendering
         * @param  {qtek.Renderer} renderer
         */
        render : function(renderer) {
                        
            this._rendering = true;

            var _gl = renderer.gl;

            for (var inputName in this.inputLinks) {
                var link = this.inputLinks[inputName];
                var inputTexture = link.node.getOutput(renderer, link.pin);
                this.pass.setUniform(inputName, inputTexture);
            }
            // Output
            if (! this.outputs) {
                this.pass.outputs = null;
                this.pass.render(renderer);
            } else {
                this.pass.outputs = {};

                for (var name in this.outputs) {
                    var parameters = this.updateParameter(name, renderer);
                    var outputInfo = this.outputs[name];
                    var texture = texturePool.get(parameters);
                    this._outputTextures[name] = texture;
                    var attachment = outputInfo.attachment || _gl.COLOR_ATTACHMENT0;
                    if (typeof(attachment) == "string") {
                        attachment = _gl[attachment];
                    }
                    this.pass.outputs[attachment] = texture;
                }

                this.pass.render(renderer, this.frameBuffer);
            }
            
            for (var inputName in this.inputLinks) {
                var link = this.inputLinks[inputName];
                link.node.removeReference(link.pin);
            }

            this._rendering = false;
            this._rendered = true;
        },

        // TODO Remove parameter function callback
        updateParameter : function(outputName, renderer) {
            var outputInfo = this.outputs[outputName];
            var parameters = outputInfo.parameters;
            var parametersCopy = outputInfo._parametersCopy;
            if (!parametersCopy) {
                parametersCopy = outputInfo._parametersCopy = {};
            }
            if (parameters) {
                for (var key in parameters) {
                    if (key !== 'width' && key !== 'height') {
                        parametersCopy[key] = parameters[key];
                    }
                }
            }
            var width, height;
            if (parameters.width instanceof Function) {
                width = parameters.width(renderer);
            } else {
                width = parameters.width;
            }
            if (parameters.height instanceof Function) {
                height = parameters.height(renderer);
            } else {
                height = parameters.height;
            }
            if (
                parametersCopy.width !== width
                || parametersCopy.height !== height
            ) {
                if (this._outputTextures[outputName]) {
                    this._outputTextures[outputName].dispose(renderer.gl);
                }
            }
            parametersCopy.width = width;
            parametersCopy.height = height;

            return parametersCopy;
        },

        setParameter : function(name, value) {
            this.pass.setUniform(name, value);
        },

        getParameter : function(name) {
            return this.pass.getUniform(name);
        },

        setParameters : function(obj) {
            for (var name in obj) {
                this.setParameter(name, obj[name]);
            }
        },

        setShader : function(shaderStr) {
            var material = this.pass.material;
            material.shader.setFragment(shaderStr);
            material.attachShader(shader, true);
        },

        getOutput : function(renderer /*optional*/, name) {
            if (name === undefined) {
                // Return the output texture without rendering
                name = renderer;
                return this._outputTextures[name];
            }
            var outputInfo = this.outputs[name];
            if (! outputInfo) {
                return ;
            }

            // Already been rendered in this frame
            if (this._rendered) {
                // Force return texture in last frame
                if (outputInfo.outputLastFrame) {
                    return this._prevOutputTextures[name];
                } else {
                    return this._outputTextures[name];
                }
            } else if (
                // TODO
                this._rendering   // Solve Circular Reference
            ) {
                if (!this._prevOutputTextures[name]) {
                    // Create a blank texture at first pass
                    this._prevOutputTextures[name] = texturePool.get(outputInfo.parameters || {});
                }
                return this._prevOutputTextures[name];
            }

            this.render(renderer);
            
            return this._outputTextures[name];
        },

        removeReference : function(outputName) {
            this._outputReferences[outputName]--;
            if (this._outputReferences[outputName] === 0) {
                var outputInfo = this.outputs[outputName];
                if (outputInfo.keepLastFrame) {
                    if (this._prevOutputTextures[outputName]) {
                        texturePool.put(this._prevOutputTextures[outputName]);
                    }
                    this._prevOutputTextures[outputName] = this._outputTextures[outputName];
                } else {
                    // Output of this node have alreay been used by all other nodes
                    // Put the texture back to the pool.
                    texturePool.put(this._outputTextures[outputName]);
                }
            }
        },

        link : function(inputPinName, fromNode, fromPinName) {

            // The relationship from output pin to input pin is one-on-multiple
            this.inputLinks[inputPinName] = {
                node : fromNode,
                pin : fromPinName
            }
            if (! fromNode.outputLinks[fromPinName]) {
                fromNode.outputLinks[fromPinName] = [];
            }
            fromNode.outputLinks[ fromPinName ].push({
                node : this,
                pin : inputPinName
            });
            // Enabled the pin texture in shader
            var shader = this.pass.material.shader;
            shader.enableTexture(inputPinName);
        },

        clear : function() {
            this.inputLinks = {};
            this.outputLinks = {};

            var shader = this.pass.material.shader;
            shader.disableTexturesAll();   
        },

        updateReference : function(outputName) {
            if (!this._rendering) {
                this._rendering = true;
                for (var inputName in this.inputLinks) {
                    var link = this.inputLinks[inputName];
                    link.node.updateReference(link.pin);
                }
                this._rendering = false;
            }
            if (outputName) {
                this._outputReferences[outputName] ++;
            }
        },

        beforeFrame : function() {
            this._rendered = false;

            for (var name in this.outputLinks) {
                this._outputReferences[name] = 0;
            }
        },

        afterFrame : function() {
            // Put back all the textures to pool
            for (var name in this.outputLinks) {
                if (this._outputReferences[name] > 0) {
                    var outputInfo = this.outputs[name];
                    if (outputInfo.keepLastFrame) {
                        if (this._prevOutputTextures[name]) {
                            texturePool.put(this._prevOutputTextures[name]);
                        }
                        this._prevOutputTextures[name] = this._outputTextures[name];
                    } else {
                        texturePool.put(this._outputTextures[name]);
                    }
                }
            }
        }
    })

    return Node;
});
define('qtek/compositor/SceneNode',['require','./Node','./Pass','../FrameBuffer','./texturePool','../core/glinfo'],function(require) {

    var Node = require("./Node");
    var Pass = require("./Pass");
    var FrameBuffer = require("../FrameBuffer");
    var texturePool = require("./texturePool");
    var glinfo = require('../core/glinfo');

    var SceneNode = Node.derive({
            
        name : 'scene',
        
        scene : null,
        
        camera : null,
        
        autoUpdateScene : true,

        preZ : false
        
    }, function() {
        if (this.frameBuffer) {
            this.frameBuffer.depthBuffer = true;
        }
    }, {
        render : function(renderer) {
            
            this._rendering = true;
            var _gl = renderer.gl;

            this.trigger('beforerender');

            if (! this.outputs) {
                
                var renderInfo = renderer.render(this.scene, this.camera, !this.autoUpdateScene, this.preZ);

            } else {

                var frameBuffer = this.frameBuffer;
                for (var name in this.outputs) {
                    var parameters = this.updateParameter(name, renderer);
                    var outputInfo = this.outputs[name];
                    var texture = texturePool.get(parameters);
                    this._outputTextures[name] = texture;

                    var attachment = outputInfo.attachment || _gl.COLOR_ATTACHMENT0;
                    if (typeof(attachment) == "string") {
                        attachment = _gl[attachment];
                    }
                    frameBuffer.attach(renderer.gl, texture, attachment);
                }
                frameBuffer.bind(renderer);

                // MRT Support in chrome
                // https://www.khronos.org/registry/webgl/sdk/tests/conformance/extensions/ext-draw-buffers.html
                var ext = glinfo.getExtension(_gl, "EXT_draw_buffers");
                if (ext) {
                    var bufs = [];
                    for (var attachment in this.outputs) {
                        attachment = parseInt(attachment);
                        if (attachment >= _gl.COLOR_ATTACHMENT0 && attachment <= _gl.COLOR_ATTACHMENT0 + 8) {
                            bufs.push(attachment);
                        }
                    }
                    ext.drawBuffersEXT(bufs);
                }

                var renderInfo = renderer.render(this.scene, this.camera, !this.autoUpdateScene, this.preZ);

                frameBuffer.unbind(renderer);
            }

            this.trigger('afterrender', renderInfo);

            this._rendering = false;
            this._rendered = true;
        }
    })

    return SceneNode;
});
define('qtek/compositor/TextureNode',['require','./Node','../FrameBuffer','./texturePool','../Shader'],function(require) {

    var Node = require("./Node");
    var FrameBuffer = require("../FrameBuffer");
    var texturePool = require("./texturePool");
    var Shader = require("../Shader");

    var TextureNode = Node.derive(function() {
        return {
            shader : Shader.source("buildin.compositor.output"),
            texture : null
        }
    }, {
        render : function(renderer) {

            this._rendering = true;

            var _gl = renderer.gl;
            this.pass.setUniform("texture", this.texture);
            
            if (! this.outputs) {
                this.pass.outputs = null;
                this.pass.render(renderer);
            } else {
                
                this.pass.outputs = {};

                for (var name in this.outputs) {
                    var parameters = this.updateParameter(name, renderer);
                    var outputInfo = this.outputs[name];
                    var texture = texturePool.get(parameters);
                    this._outputTextures[name] = texture;

                    var attachment = outputInfo.attachment || _gl.COLOR_ATTACHMENT0;
                    if (typeof(attachment) == "string") {
                        attachment = _gl[attachment];
                    }
                    this.pass.outputs[ attachment ] = texture;

                }

                this.pass.render(renderer, this.frameBuffer);
            }

            this._rendering = false;
            this._rendered = true;
        }
    })

    return TextureNode;
});
/**
 * Simple double linked list
 */
define('qtek/core/LinkedList',['require'],function(require) {
    
    var LinkedList = function() {

        this.head = null;

        this.tail = null;

        this._length = 0;
    }

    LinkedList.prototype.insert = function(val) {
        var entry = new LinkedList.Entry(val);
        this.insertEntry(entry);
        return entry;
    }

    LinkedList.prototype.insertAt = function(idx, val) {
        if (idx < 0) {
            return;
        }
        var next = this.head;
        var cursor = 0;
        while (next && cursor != idx) {
            next = next.next;
            cursor++;
        }
        if (next) {
            var entry = new LinkedList.Entry(val);
            var prev = next.prev;
            prev.next = entry;
            entry.prev = prev;
            entry.next = next;
            next.prev = entry;
        } else {
            this.insert(val);
        }
    }

    LinkedList.prototype.insertEntry = function(entry) {
        if (!this.head) {
            this.head = this.tail = entry;
        } else {
            this.tail.next = entry;
            entry.prev = this.tail;
            this.tail = entry;
        }
        this._length++;
    }

    LinkedList.prototype.remove = function(entry) {
        var prev = entry.prev;
        var next = entry.next;
        if (prev) {
            prev.next = next;
        } else {
            // Is head
            this.head = next;
        }
        if (next) {
            next.prev = prev;
        } else {
            // Is tail
            this.tail = prev;
        }
        entry.next = entry.prev = null;
        this._length--;
    }

    LinkedList.prototype.removeAt = function(idx) {
        if (idx < 0) {
            return;
        }
        var curr = this.head;
        var cursor = 0;
        while (curr && cursor != idx) {
            curr = curr.next;
            cursor++;
        }
        if (curr) {
            this.remove(curr);
            return curr.value;
        }
    }

    LinkedList.prototype.getHead = function() {
        if (this.head) {
            return this.head.value;
        }
    }

    LinkedList.prototype.getTail = function() {
        if (this.tail) {
            return this.tail.value;
        }
    }

    LinkedList.prototype.getAt = function(idx) {
        if (idx < 0) {
            return;
        }
        var curr = this.head;
        var cursor = 0;
        while (curr && cursor != idx) {
            curr = curr.next;
            cursor++;
        }
        return curr.value;
    }

    LinkedList.prototype.indexOf = function(value) {
        var curr = this.head;
        var cursor = 0;
        while (curr) {
            if (curr.value === value) {
                return cursor;
            }
            curr = curr.next;
            cursor++;
        }
    }

    LinkedList.prototype.length = function() {
        return this._length;
    }

    LinkedList.prototype.isEmpty = function() {
        return this._length == 0;
    }

    LinkedList.prototype.forEach = function(f, context) {
        var curr = this.head;
        var idx = 0;
        var haveContext = typeof(context) != 'undefined';
        while (curr) {
            if (haveContext) {
                f.call(context, curr.value, idx);
            } else {
                f(curr.value, idx);
            }
            curr = curr.next;
            idx++;
        }
    }

    LinkedList.prototype.clear = function() {
        this.tail = this.head = null;
        this._length = 0;
    }

    LinkedList.Entry = function(val) {

        this.value = val;

        this.next = null;

        this.prev = null;
    }

    return LinkedList;
});
define('qtek/core/LRU',['require','./LinkedList'],function(require) {

    var LinkedList = require('./LinkedList');

    var LRU = function(maxSize) {

        this._list = new LinkedList();

        this._map = {};

        this._maxSize = maxSize || 10;
    }

    LRU.prototype.setMaxSize = function(size) {
        this._maxSize = size;
    }

    LRU.prototype.put = function(key, value) {
        if (typeof(this._map[key]) == 'undefined') {
            var len = this._list.length();
            if (len >= this._maxSize && len > 0) {
                // Remove the least recently used
                var leastUsedEntry = this._list.head;
                this._list.remove(leastUsedEntry);
                delete this._map[leastUsedEntry.key];
            }

            var entry = this._list.insert(value);
            entry.key = key;
            this._map[key] = entry;
        }
    }

    LRU.prototype.get = function(key) {
        var entry = this._map[key];
        if (typeof(entry) != 'undefined') {
            // Put the latest used entry in the tail
            if (entry !== this._list.tail) {
                this._list.remove(entry);
                this._list.insertEntry(entry);
            }

            return entry.value;
        }
    }

    LRU.prototype.remove = function(key) {
        var entry = this._map[key];
        if (typeof(entry) != 'undefined') {
            delete this._map[key];
            this._list.remove(entry);
        }
    }

    LRU.prototype.clear = function() {
        this._list.clear();
        this._map = {};
    }

    return LRU;
});
;
define("qtek/deferred/Renderer", function(){});

;
define("qtek/deferred/StandardMaterial", function(){});

;
define("qtek/geometry/Capsule", function(){});

define('qtek/geometry/Cone',['require','../DynamicGeometry','../math/BoundingBox','glmatrix'],function(require) {

    var DynamicGeometry = require('../DynamicGeometry');
    var BoundingBox = require('../math/BoundingBox');
    var glMatrix = require('glmatrix');
    var vec3 = glMatrix.vec3;
    var vec2 = glMatrix.vec2;

    var Cone = DynamicGeometry.derive({

        topRadius : 0,
        bottomRadius : 1,

        height : 2,

        capSegments : 50,
        heightSegments : 1
    }, function() {
        this.build();
    }, {
        build : function() {
            var positions = this.attributes.position.value;
            var texcoords = this.attributes.texcoord0.value;
            var faces = this.faces;
            positions.length = 0;
            texcoords.length = 0;
            faces.length = 0;
            // Top cap
            var capSegRadial = Math.PI * 2 / this.capSegments;

            var topCap = [];
            var bottomCap = [];

            var r1 = this.topRadius;
            var r2 = this.bottomRadius;
            var y = this.height / 2;

            var c1 = vec3.fromValues(0, y, 0);
            var c2 = vec3.fromValues(0, -y, 0);
            for (var i = 0; i < this.capSegments; i++) {
                var theta = i * capSegRadial;
                var x = r1 * Math.sin(theta);
                var z = r1 * Math.cos(theta);
                topCap.push(vec3.fromValues(x, y, z));

                x = r2 * Math.sin(theta);
                z = r2 * Math.cos(theta);
                bottomCap.push(vec3.fromValues(x, -y, z));
            }

            // Build top cap
            positions.push(c1);
            // TODO
            texcoords.push(vec2.fromValues(0, 1));
            var n = this.capSegments;
            for (var i = 0; i < n; i++) {
                positions.push(topCap[i]);
                // TODO
                texcoords.push(vec2.fromValues(i / n, 0));
                faces.push([0, i+1, (i+1) % n + 1]);
            }

            // Build bottom cap
            var offset = positions.length;
            positions.push(c2);
            texcoords.push(vec2.fromValues(0, 1));
            for (var i = 0; i < n; i++) {
                positions.push(bottomCap[i]);
                // TODO
                texcoords.push(vec2.fromValues(i / n, 0));
                faces.push([offset, offset+((i+1) % n + 1), offset+i+1]);
            }

            // // Build side
            offset = positions.length;
            var n2 = this.heightSegments;
            for (var i =0; i < n; i++) {
                for (var j = 0; j < n2+1; j++) {
                    var v = j / n2;
                    positions.push(vec3.lerp(vec3.create(), topCap[i], bottomCap[i], v));
                    texcoords.push(vec2.fromValues(i / n, v));
                }
            }
            for (var i = 0; i < n; i++) {
                for (var j = 0; j < n2; j++) {
                    var i1 = i * (n2 + 1) + j;
                    var i2 = ((i + 1) % n) * (n2 + 1) + j;
                    var i3 = ((i + 1) % n) * (n2 + 1) + j + 1;
                    var i4 = i * (n2 + 1) + j + 1;
                    faces.push([offset+i2, offset+i1, offset+i4]);
                    faces.push([offset+i4, offset+i3, offset+i2]);
                }
            }

            this.generateVertexNormals();

            this.boundingBox = new BoundingBox();
            var r = Math.max(this.topRadius, this.bottomRadius);
            this.boundingBox.min.set(-r, -this.height/2, -r);
            this.boundingBox.max.set(r, this.height/2, r);
        }
    });

    return Cone;
});

define('qtek/geometry/Cube',['require','../DynamicGeometry','./Plane','../math/Matrix4','../math/Vector3','../math/BoundingBox'],function(require) {

    var DynamicGeometry = require('../DynamicGeometry');
    var Plane = require('./Plane');
    var Matrix4 = require('../math/Matrix4');
    var Vector3 = require('../math/Vector3');
    var BoundingBox = require('../math/BoundingBox');

    var planeMatrix = new Matrix4();
    
    var Cube = DynamicGeometry.derive({
        widthSegments : 1,
        heightSegments : 1,
        depthSegments : 1,
        // TODO double side material
        inside : false
    }, function() {
        var planes = {
            "px" : createPlane("px", this.depthSegments, this.heightSegments),
            "nx" : createPlane("nx", this.depthSegments, this.heightSegments),
            "py" : createPlane("py", this.widthSegments, this.depthSegments),
            "ny" : createPlane("ny", this.widthSegments, this.depthSegments),
            "pz" : createPlane("pz", this.widthSegments, this.heightSegments),
            "nz" : createPlane("nz", this.widthSegments, this.heightSegments),
        };
        var cursor = 0;
        var self = this;
        for (var pos in planes) {
            ['position', 'texcoord0', 'normal'].forEach(function(attrName) {
                var attrArray = planes[pos].attributes[attrName].value;
                for (var i = 0; i < attrArray.length; i++) {
                    var value = attrArray[i];
                    if (this.inside && attrName === "normal") {
                        value[0] = -value[0];
                        value[1] = -value[1];
                        value[2] = -value[2];
                    }
                    self.attributes[attrName].value.push(value);
                }
                var plane = planes[pos];
                for (var i = 0; i < plane.faces.length; i++) {
                    var face = plane.faces[i];
                    self.faces.push([face[0]+cursor, face[1]+cursor, face[2]+cursor]);
                }
            });
            cursor += planes[pos].getVertexNumber();
        }

        this.boundingBox = new BoundingBox();
        this.boundingBox.max.set(1, 1, 1);
        this.boundingBox.min.set(-1, -1, -1);
    })

    function createPlane(pos, widthSegments, heightSegments) {

        planeMatrix.identity();

        var plane = new Plane({
            widthSegments : widthSegments,
            heightSegments : heightSegments
        })

        switch(pos) {
            case "px":
                planeMatrix.translate(new Vector3(1, 0, 0));
                planeMatrix.rotateY(Math.PI/2);
                break;
            case "nx":
                planeMatrix.translate(new Vector3(-1, 0, 0));
                planeMatrix.rotateY(-Math.PI/2);
                break;
            case "py":
                planeMatrix.translate(new Vector3(0, 1, 0));
                planeMatrix.rotateX(-Math.PI/2);
                break;
            case "ny":
                planeMatrix.translate(new Vector3(0, -1, 0));
                planeMatrix.rotateX(Math.PI/2);
                break;
            case "pz":
                planeMatrix.translate(new Vector3(0, 0, 1));
                break;
            case "nz":
                planeMatrix.translate(new Vector3(0, 0, -1));
                planeMatrix.rotateY(Math.PI);
                break;
        }
        plane.applyTransform(planeMatrix);
        return plane;
    }

    return Cube;
});
define('qtek/geometry/Cylinder',['require','../DynamicGeometry','../math/BoundingBox','./Cone'],function(require) {

    var DynamicGeometry = require('../DynamicGeometry');
    var BoundingBox = require('../math/BoundingBox');
    var ConeGeometry = require('./Cone');

    var Cylinder = DynamicGeometry.derive({
        radius : 1,
        height : 2,

        capSegments : 50,
        heightSegments : 1
    }, function() {
        this.build();
    }, {
        build : function() {
            var cone = new ConeGeometry({
                topRadius : this.radius,
                bottomRadius : this.radius,
                capSegments : this.capSegments,
                heightSegments : this.heightSegments,
                height : this.height
            });

            this.attributes.position.value = cone.attributes.position.value;
            this.attributes.normal.value = cone.attributes.normal.value;
            this.attributes.texcoord0.value = cone.attributes.texcoord0.value;
            this.faces = cone.faces;

            this.boundingBox = cone.boundingBox;
        }
    })

    return Cylinder;
});
define('qtek/geometry/Sphere',['require','../DynamicGeometry','glmatrix','../math/BoundingBox'],function(require) {

    var DynamicGeometry = require('../DynamicGeometry');
    var glMatrix = require('glmatrix');
    var vec3 = glMatrix.vec3;
    var vec2 = glMatrix.vec2;
    var BoundingBox = require('../math/BoundingBox');

	// From three.js SphereGeometry
    var Sphere = DynamicGeometry.derive({
        widthSegments : 20,
        heightSegments : 20,

        phiStart : 0,
        phiLength : Math.PI * 2,

        thetaStart : 0,
        thetaLength : Math.PI,

        radius : 1
    }, function() {
        
        var positions = this.attributes.position.value;
        var texcoords = this.attributes.texcoord0.value;
        var normals = this.attributes.normal.value;

        var x, y, z,
            u, v,
            i, j;
        var normal;

        var heightSegments = this.heightSegments;
        var widthSegments = this.widthSegments;
        var radius = this.radius;
        var phiStart = this.phiStart;
        var phiLength = this.phiLength;
        var thetaStart = this.thetaStart;
        var thetaLength = this.thetaLength;
        var radius = this.radius;

        for (j = 0; j <= heightSegments; j ++) {
            for (i = 0; i <= widthSegments; i ++) {
                u = i / widthSegments;
                v = j / heightSegments;

                x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                y = radius * Math.cos(thetaStart + v * thetaLength);
                z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);

                positions.push(vec3.fromValues(x, y, z));
                texcoords.push(vec2.fromValues(u, v));

                normal = vec3.fromValues(x, y, z);
                vec3.normalize(normal, normal)
                normals.push(normal);
            }
        }

        var p1, p2, p3,
            i1, i2, i3, i4;
        var faces = this.faces;

        var len = widthSegments + 1;

        for (j = 0; j < heightSegments; j ++) {
            for (i = 0; i < widthSegments; i ++) {
                i2 = j * len + i;
                i1 = (j * len + i + 1);
                i4 = (j + 1) * len + i + 1;
                i3 = (j + 1) * len + i;

                faces.push(vec3.fromValues(i1, i2, i4));
                faces.push(vec3.fromValues(i2, i3, i4));
            }
        }

        this.boundingBox = new BoundingBox();
        this.boundingBox.max.set(radius, radius, radius);
        this.boundingBox.min.set(-radius, -radius, -radius);
    })

    return Sphere;
});
define('qtek/light/Ambient',['require','../Light','../Shader'],function(require) {

    var Light = require('../Light');
    var Shader = require('../Shader');

    var AmbientLight = Light.derive({
        castShadow : false
    }, {

        type : 'AMBIENT_LIGHT',

        uniformTemplates : {
            'ambientLightColor' : {
                type : '3f',
                value : function(instance) {
                    var color = instance.color,
                        intensity = instance.intensity;
                    return [color[0]*intensity, color[1]*intensity, color[1]*intensity];
                }
            }
        }
    })

    return AmbientLight;
});
define('qtek/light/Directional',['require','../Light','../Shader','../math/Vector3'],function(require) {

    var Light = require('../Light');
    var Shader = require('../Shader');
    var Vector3 = require('../math/Vector3');

    var DirectionalLight = Light.derive({
        shadowBias : 0.0002,
        shadowSlopeScale : 2.0
    }, {

        type : 'DIRECTIONAL_LIGHT',

        uniformTemplates : {
            'directionalLightDirection' : {
                type : '3f',
                value : (function() {
                    var z = new Vector3();
                    return function(instance) {
                        return z.copy(instance.worldTransform.forward).negate()._array;
                    }
                })()
            },
            'directionalLightColor' : {
                type : '3f',
                value : function(instance) {
                    var color = instance.color;
                    var intensity = instance.intensity;
                    return [color[0]*intensity, color[1]*intensity, color[1]*intensity];
                }
            }
        },

        clone: function() {
            var light = Light.prototype.clone.call(this);
            light.shadowBias = this.shadowBias;
            light.shadowSlopeScale = this.shadowSlopeScale;
            return light;
        }
    })

    return DirectionalLight;
} );
define('qtek/light/Point',['require','../Light','../Shader'],function(require) {

    var Light = require('../Light');
    var Shader = require('../Shader');

    var PointLight = Light.derive({
        range : 100,

        castShadow : false
    }, {

        type : 'POINT_LIGHT',

        uniformTemplates : {
            'pointLightPosition' : {
                type : '3f',
                value : function(instance) {
                    return instance.getWorldPosition()._array;
                }
            },
            'pointLightRange' : {
                type : '1f',
                value : function(instance) {
                    return instance.range;
                }
            },
            'pointLightColor' : {
                type : '3f',
                value : function(instance) {
                    var color = instance.color,
                        intensity = instance.intensity;
                    return [ color[0]*intensity, color[1]*intensity, color[1]*intensity ];
                }
            }
        },

        clone: function() {
            var light = Light.prototype.clone.call(this);
            light.range = this.range;
            return light;
        }
    })

    return PointLight;
});
define('qtek/light/Spot',['require','../Light','../Shader','../math/Vector3'],function(require) {

    var Light = require('../Light');
    var Shader = require('../Shader');
    var Vector3 = require('../math/Vector3');

    var SpotLight = Light.derive({
        range : 20,
        umbraAngle : 30,
        penumbraAngle : 45,
        falloffFactor : 2.0,
        
        shadowBias : 0.0002,
        shadowSlopeScale : 2.0
    },{

        type : 'SPOT_LIGHT',

        uniformTemplates : {
            'spotLightPosition' : {
                type : '3f',
                value : function(instance) {
                    return instance.getWorldPosition()._array;
                }
            },
            'spotLightRange' : {
                type : '1f',
                value : function(instance) {
                    return instance.range;
                }
            },
            'spotLightUmbraAngleCosine' : {
                type : '1f',
                value : function(instance) {
                    return Math.cos(instance.umbraAngle * Math.PI / 180);
                }
            },
            'spotLightPenumbraAngleCosine' : {
                type : '1f',
                value : function(instance) {
                    return Math.cos(instance.penumbraAngle * Math.PI / 180);
                }
            },
            'spotLightFalloffFactor' : {
                type : '1f',
                value : function(instance) {
                    return instance.falloffFactor
                }
            },
            'spotLightDirection' : {
                type : '3f',
                value : (function() {
                    var z = new Vector3();
                    return function(instance) {
                        // Direction is target to eye
                        return z.copy(instance.worldTransform.forward).negate()._array;
                    }
                })()
            },
            'spotLightColor' : {
                type : '3f',
                value : function(instance) {
                    var color = instance.color,
                        intensity = instance.intensity;
                    return [ color[0]*intensity, color[1]*intensity, color[1]*intensity ];
                }
            }
        },

        clone: function() {
            var light = Light.prototype.clone.call(this);
            light.range = this.range;
            light.umbraAngle = this.umbraAngle;
            light.penumbraAngle = this.penumbraAngle;
            light.falloffFactor = this.falloffFactor;
            light.shadowBias = this.shadowBias;
            light.shadowSlopeScale = this.shadowSlopeScale;
            return light
        }
    });

    return SpotLight;
} );
define('qtek/loader/FX',['require','../core/Base','../core/request','../core/util','../compositor/Compositor','../compositor/Node','../compositor/SceneNode','../compositor/TextureNode','../Shader','../Texture','../texture/Texture2D','../texture/TextureCube'],function(require) {
    
    

    var Base = require('../core/Base');
    var request = require('../core/request');
    var util = require('../core/util');
    var Compositor = require('../compositor/Compositor');
    var CompoNode = require('../compositor/Node');
    var CompoSceneNode = require('../compositor/SceneNode');
    var CompoTextureNode = require('../compositor/TextureNode');
    var Shader = require('../Shader');
    var Texture = require('../Texture');
    var Texture2D = require('../texture/Texture2D');
    var TextureCube = require('../texture/TextureCube');

    var shaderSourceReg = /#source\((.*?)\)/;
    var urlReg = /#url\((.*?)\)/;

    var FXLoader = Base.derive({
        rootPath : "",
        textureRootPath : "",
        shaderRootPath : ""
    }, {
        load : function(url) {
            var self = this;

            if (!this.rootPath) {
                this.rootPath = url.slice(0, url.lastIndexOf("/"));
            }

            request.get({
                url : url,
                onprogress : function(percent, loaded, total) {
                    self.trigger("progress", percent, loaded, total);
                },
                onerror : function(e) {
                    self.trigger("error", e);
                },
                responseType : "text",
                onload : function(data) {
                    self.parse(JSON.parse(data));
                }
            });
        },

        parse : function(json) {
            var self = this;
            var compositor = new Compositor();

            var lib = {
                textures : {},
                shaders : {},
                parameters : {}
            }
            var afterLoad = function(shaderLib, textureLib) {
                for (var i = 0; i < json.nodes.length; i++) {
                    var nodeInfo = json.nodes[i];
                    var node = self._createNode(nodeInfo, lib);
                    if (node) {
                        compositor.addNode(node);
                    }
                    if (nodeInfo.output) {
                        compositor.addOutput(node);
                    }
                }

                self.trigger('success', compositor);
            }

            for (var name in json.parameters) {
                var paramInfo = json.parameters[name];
                lib.parameters[name] = this._convertParameter(paramInfo);
            }
            this._loadShaders(json, function(shaderLib) {
                self._loadTextures(json, lib, function(textureLib) {
                    lib.textures = textureLib;
                    lib.shaders = shaderLib;
                    afterLoad();
                });
            });

            return compositor;
        },

        _createNode : function(nodeInfo, lib) {
            if (!nodeInfo.shader) {
                return;
            }
            var type = nodeInfo.type || 'processor';
            var shaderSource;
            var inputs;
            var outputs;

            if (type === 'processor') {
                var shaderExp = nodeInfo.shader.trim();
                var res = shaderSourceReg.exec(shaderExp);
                if (res) {
                    shaderSource = Shader.source(res[1].trim());
                } else if (shaderExp.charAt(0) === '#') {
                    shaderSource = lib.shaders[shaderExp.substr(1)];
                }
                if (!shaderSource) {
                    shaderSource = shaderExp;
                }
                if (!shaderSource) {
                    return;
                }
            }

            if (nodeInfo.inputs) {
                inputs = {};      
                for (var name in nodeInfo.inputs) {
                    inputs[name] = {
                        node : nodeInfo.inputs[name].node,
                        pin : nodeInfo.inputs[name].pin
                    }
                }
            }
            if (nodeInfo.outputs) {
                outputs = {};
                for (var name in nodeInfo.outputs) {
                    var outputInfo = nodeInfo.outputs[name];
                    outputs[name] = {};
                    if (outputInfo.attachment !== undefined) {
                        outputs[name].attachment = outputInfo.attachment;
                    }
                    if (outputInfo.keepLastFrame !== undefined) {
                        outputs[name].keepLastFrame = outputInfo.keepLastFrame;
                    }
                    if (outputInfo.outputLastFrame !== undefined) {
                        outputs[name].outputLastFrame = outputInfo.outputLastFrame;
                    }
                    if (typeof(outputInfo.parameters) === 'string') {
                        var paramExp = outputInfo.parameters;
                        if (paramExp.charAt(0) === '#') {
                            outputs[name].parameters = lib.parameters[paramExp.substr(1)];
                        }
                    } else if (outputInfo.parameters) {
                        outputs[name].parameters = this._convertParameter(outputInfo.parameters);
                    }
                }   
            }
            var node;
            if (type === 'processor') {
                node = new CompoNode({
                    name : nodeInfo.name,
                    shader : shaderSource,
                    inputs : inputs,
                    outputs : outputs
                });
            }
            if (node) {
                if (nodeInfo.parameters) {
                    for (var name in nodeInfo.parameters) {
                        var val = nodeInfo.parameters[name];
                        if (typeof(val) === 'string') {
                            val = val.trim();
                            if (val.charAt(0) === '#'){
                                val = lib.textures[val.substr(1)];
                            }
                        }
                        node.setParameter(name, val);
                    }
                }
                if (nodeInfo.defines) {
                    for (var name in nodeInfo.defines) {
                        var val = nodeInfo.defines[name];
                        node.pass.material.shader.define('fragment', name, val);
                    }
                }
            }
            return node;
        },

        _convertParameter : function(paramInfo) {
            var param = {};
            if (!paramInfo) {
                return param;
            }
            ['type', 'minFilter', 'magFilter', 'wrapS', 'wrapT']
                .forEach(function(name) {
                    var val = paramInfo[name];
                    if (val !== undefined) {
                        // Convert string to enum
                        if (typeof(val) === 'string') {
                            val = Texture[val];
                        }
                        param[name] = val;
                    }
                });
            ['width', 'height']
                .forEach(function(name) {
                    if (paramInfo[name] !== undefined) {
                        var val = paramInfo[name];
                        if (typeof val === 'string') {
                            val = val.trim();
                            if (val.match(/%$/)) {
                                if (name === 'width') {
                                    param[name] = percentToWidth.bind(null, val);
                                } else {
                                    param[name] = percentToHeight.bind(null, val);
                                }
                            }
                        } else {
                            param[name] = val;
                        }
                    }
                });
            if (paramInfo.useMipmap !== undefined) {
                param.useMipmap = paramInfo.useMipmap;
            }
            return param;
        },
        
        _loadShaders : function(json, callback) {
            if (!json.shaders) {
                callback({});
                return;
            }
            var shaders = {};
            var loading = 0;
            var cbd = false;
            var shaderRootPath = this.shaderRootPath || this.rootPath;
            util.each(json.shaders, function(shaderExp, name) {
                var res = urlReg.exec(shaderExp);
                if (res) {
                    var path = res[1];
                    path = util.relative2absolute(path, shaderRootPath);
                    loading++;
                    request.get({
                        url : path,
                        onload : function(shaderSource) {
                            shaders[name] = shaderSource;
                            Shader['import'](shaderSource);
                            loading--;
                            if (loading === 0) {
                                callback(shaders);
                                cbd = true;
                            }
                        }
                    })
                } else {
                    shaders[name] = shaderExp;
                    Shader['import'](shaderSource);
                }
            }, this);
            if (loading === 0 && !cbd) {
                callback(shaders);
            }
        },

        _loadTextures : function(json, lib, callback) {
            if (!json.textures) {
                callback({});
                return;
            }
            var textures = {};
            var loading = 0;

            var cbd = false;
            var textureRootPath = this.textureRootPath || this.rootPath;
            util.each(json.textures, function(textureInfo, name) {
                var texture;
                var path = textureInfo.path;
                var parameters = this._convertParameter(textureInfo.parameters);
                if (typeof(path) === 'array' && path.length === 6) {
                    path = path.map(function(item) {
                        return util.relative2absolute(item, textureRootPath);
                    })
                    texture = new TextureCube();
                } else if(typeof(path) === 'string') {
                    path = util.relative2absolute(path, textureRootPath);
                    texture = new Texture2D();
                } else {
                    return;
                }

                texture.load(path);
                loading++;
                texture.once('success', function() {
                    textures[name] = texture;
                    loading--;
                    if (loading === 0) {
                        callback(textures);
                        cbd = true;
                    }
                });
            }, this);

            if (loading === 0 && !cbd) {
                callback(textures);
            }
        }
    });

    function percentToWidth(percentStr, renderer) {
        var percent = parseFloat(percentStr.substr(0, percentStr.length-1));
        return Math.max(
            percent / 100 * renderer.width,
            1
        );
    }

    function percentToHeight(percentStr, renderer) {
        var percent = parseFloat(percentStr.substr(0, percentStr.length-1));
        return Math.max(
            percent / 100 * renderer.height,
            1
        );
    }

    return FXLoader;
});
/**
 * glTF Loader
 * Specification : https://github.com/KhronosGroup/glTF/blob/master/specification/README.md
 */
define('qtek/loader/GLTF',['require','../core/Base','../core/request','../core/util','../Scene','../Shader','../Material','../Mesh','../Node','../Texture','../texture/Texture2D','../texture/TextureCube','../shader/library','../Skeleton','../Joint','../camera/Perspective','../camera/Orthographic','../light/Point','../light/Spot','../light/Directional','../core/glenum','../math/Vector3','../math/Quaternion','../math/BoundingBox','../animation/SamplerClip','../animation/SkinningClip','../StaticGeometry','glmatrix'],function(require) {

    

    var Base = require('../core/Base');
    var request = require("../core/request");
    var util = require('../core/util');

    var Scene = require('../Scene');
    var Shader = require("../Shader");
    var Material = require("../Material");
    var Mesh = require("../Mesh");
    var Node = require("../Node");
    var Texture = require('../Texture');
    var Texture2D = require("../texture/Texture2D");
    var TextureCube = require("../texture/TextureCube");
    var shaderLibrary = require("../shader/library");
    var Skeleton = require("../Skeleton");
    var Joint = require("../Joint");
    var PerspectiveCamera = require("../camera/Perspective");
    var OrthographicCamera = require("../camera/Orthographic");
    var PointLight = require("../light/Point");
    var SpotLight = require("../light/Spot");
    var DirectionalLight = require("../light/Directional");
    var glenum = require("../core/glenum");

    var Vector3 = require("../math/Vector3");
    var Quaternion = require("../math/Quaternion");
    var BoundingBox = require('../math/BoundingBox');

    var SamplerClip = require("../animation/SamplerClip");
    var SkinningClip = require("../animation/SkinningClip");

    var StaticGeometry = require("../StaticGeometry");

    var glMatrix = require("glmatrix");
    var vec4 = glMatrix.vec4;
    var vec3 = glMatrix.vec3;
    var quat = glMatrix.quat;

    var semanticAttributeMap = {
        'NORMAL' : 'normal',
        'POSITION' : 'position',
        'TEXCOORD_0' : 'texcoord0',
        'WEIGHT' : 'weight',
        'JOINT' : 'joint',
        'COLOR' : 'color'
    }

    var Loader = Base.derive({
        rootPath : "",
        textureRootPath : "",
        bufferRootPath : "",

        shaderName : 'buildin.physical'
    }, {
        
        load : function(url) {
            var self = this;

            if (!this.rootPath) {
                this.rootPath = url.slice(0, url.lastIndexOf("/"));
            }

            request.get({
                url : url,
                onprogress : function(percent, loaded, total) {
                    self.trigger("progress", percent, loaded, total);
                },
                onerror : function(e) {
                    self.trigger("error", e);
                },
                responseType : "text",
                onload : function(data) {
                    self.parse(JSON.parse(data));
                }
            });
        },

        parse : function(json) {
            var self = this;
            var loading = 0;

            var lib = {
                buffers : {},
                materials : {},
                textures : {},
                meshes : {},
                joints : {},
                skeletons : {},
                cameras : {},
                nodes : {}
            };
            // Build scene
            var scene = new Scene();
            // Load buffers
            util.each(json.buffers, function(bufferInfo, name) {
                loading++;
                self._loadBuffer(bufferInfo.path, function(buffer) {
                    lib.buffers[name] = buffer;
                    loading--;
                    if (loading === 0) {
                        afterLoadBuffer();
                    }
                }, function() {
                    loading--;
                    if (loading === 0) {
                        afterLoadBuffer();
                    }
                });
            });

            function afterLoadBuffer() {
                self._parseTextures(json, lib);
                self._parseMaterials(json, lib);
                self._parseMeshes(json, lib);
                self._parseNodes(json, lib);

                var sceneInfo = json.scenes[json.scene];
                for (var i = 0; i < sceneInfo.nodes.length; i++) {
                    var node = lib.nodes[sceneInfo.nodes[i]];
                    node.update();
                    scene.add(node);
                }

                var isOldVersion = false;
                for (var name in json.skins) {
                    if (json.skins[name].roots) {
                        isOldVersion = true;
                        break;
                    }
                }
                if (isOldVersion) {
                    self._parseSkins(json, lib);
                } else {
                    self._parseSkins2(json, lib);
                }

                var clip = self._parseAnimations(json, lib);
                if (clip) {
                    for (var name in lib.skeletons) {
                        lib.skeletons[name].addClip(clip);
                    }
                }

                self.trigger("success", {
                    scene : scene,
                    cameras : lib.cameras,
                    textures : lib.textures,
                    materials : lib.materials,
                    skeletons : lib.skeletons,
                    clip : clip
                });
            }

            return {
                scene : scene,
                cameras : lib.cameras,
                textures : lib.textures,
                materials : lib.materials,
                skeletons : lib.skeletons,
                clip : null
            }
        },

        _loadBuffer : function(path, onsuccess, onerror) {
            var root = this.bufferRootPath || this.rootPath;
            if (root) {
                path = root + "/" + path;
            }
            request.get({
                url : path,
                responseType : "arraybuffer",
                onload : function(buffer) {
                    onsuccess && onsuccess(buffer);
                },
                onerror : function(buffer) {
                    onerror && onerror(buffer);
                }
            });
        },

        // https://github.com/KhronosGroup/glTF/issues/100
        // https://github.com/KhronosGroup/glTF/issues/193
        _parseSkins2 : function(json, lib) {
            var self = this;

            // Create skeletons and joints
            var haveInvBindMatrices = false;
            for (var name in json.skins) {
                var skinInfo = json.skins[name];
                var skeleton = new Skeleton({
                    name : name
                });
                for (var i = 0; i < skinInfo.joints.length; i++) {
                    var jointId = skinInfo.joints[i];
                    var joint = new Joint({
                        name : jointId,
                        index : skeleton.joints.length
                    });
                    skeleton.joints.push(joint);
                }
                if (skinInfo.inverseBindMatrices) {
                    haveInvBindMatrices = true;
                    var IBMInfo = skinInfo.inverseBindMatrices;
                    var bufferViewName = IBMInfo.bufferView;
                    var bufferViewInfo = json.bufferViews[bufferViewName];
                    var buffer = lib.buffers[bufferViewInfo.buffer];

                    var offset = IBMInfo.byteOffset + bufferViewInfo.byteOffset;
                    var size = IBMInfo.count * 16;

                    var array = new Float32Array(buffer, offset, size);

                    skeleton._invBindPoseMatricesArray = array;
                    skeleton._skinMatricesArray = new Float32Array(array.length);
                }
                lib.skeletons[name] = skeleton;
            }

            var bindNodeToJoint = function(jointsMap, nodeName, parentIndex, rootNode) {
                var node = lib.nodes[nodeName];
                var nodeInfo = json.nodes[nodeName];
                var joint = jointsMap[nodeInfo.jointId];
                // TODO 
                // collada2gltf may have jointId in node but corresponding skin doesn't have this jointId
                // maybe because the joint has no weight on the skinned mesh, so converter removed it for optimization
                // Skip it ??
                // wired
                if (joint) {
                    // throw new Error('Joint bind to ' + nodeInfo.name + ' doesn\'t exist in skin');
                    joint.node = node;
                    joint.parentIndex = parentIndex;
                    joint.rootNode = rootNode;
                    parentIndex = joint.index;
                }

                for (var i = 0; i < nodeInfo.children.length; i++) {
                    bindNodeToJoint(jointsMap, nodeInfo.children[i], parentIndex, rootNode);
                }

                return joint;
            }

            var instanceSkins = {};

            for (var name in json.nodes) {

                var nodeInfo = json.nodes[name];

                if (nodeInfo.instanceSkin) {
                    var skinName = nodeInfo.instanceSkin.skin;
                    var skeleton = lib.skeletons[skinName];
                    instanceSkins[skinName] = skeleton;

                    var node = lib.nodes[name];
                    var jointIndices = skeleton.joints.map(function(joint) {
                        return joint.index;
                    });
                    if (node instanceof Mesh) {
                        node.skeleton = skeleton;
                        node.joints = jointIndices;
                        var material = node.material;
                        material.shader = material.shader.clone();
                        material.shader.define('vertex', 'SKINNING');
                        material.shader.define('vertex', 'JOINT_NUMBER', jointIndices.length);
                    } else {
                        // Mesh have multiple primitives
                        for (var i = 0; i < node._children.length; i++) {
                            var child = node._children[i];
                            if (child.skeleton) {
                                child.skeleton = skeleton;
                                child.joints = jointIndices;
                                var material = child.material;
                                material.shader = material.shader.clone();
                                material.shader.define('vertex', 'SKINNING');
                                material.shader.define('vertex', 'JOINT_NUMBER', jointIndices.length);
                            }
                        }
                    }

                    var jointsMap = {};
                    for (var i = 0; i < skeleton.joints.length; i++) {
                        var joint = skeleton.joints[i];
                        jointsMap[joint.name] = joint;
                    }
                    // Build up hierarchy from root nodes
                    var rootNodes = nodeInfo.instanceSkin.skeletons;
                    for (i = 0; i < rootNodes.length; i++) {
                        var rootNode = lib.nodes[rootNodes[i]];
                        var rootJoint = bindNodeToJoint(jointsMap, rootNodes[i], -1, rootNode);
                        // Root joint may not in the skeleton
                        if (rootJoint) {
                            skeleton.roots.push(rootJoint);
                        }
                    }
                }
            }

            for (var name in instanceSkins) {
                var skeleton = instanceSkins[name];
                if (haveInvBindMatrices) {
                    skeleton.updateMatricesSubArrays();
                } else {
                    skeleton.updateJointMatrices();
                }
                skeleton.update();
            }
        },     

        // DEPRECATED
        _parseSkins : function(json, lib) {
            var self = this;

            var createJoint = function(nodeName, parentIndex, skeleton) {
                var nodeInfo = json.nodes[nodeName];
                nodeInfo._isJoint = true;
                // Cast node to joint
                var joint = new Joint();
                joint.name = nodeName;
                var node = lib.nodes[nodeName];
                joint.node = node;
                joint.index = skeleton.joints.length;
                if (parentIndex !== undefined) {
                    joint.parentIndex = parentIndex;
                }
                
                skeleton.joints.push(joint);
                lib.joints[nodeName] = joint;
                
                for (var i = 0; i < nodeInfo.children.length; i++) {
                    var child = createJoint(nodeInfo.children[i], joint.index, skeleton);
                }
                return joint;
            }

            for (var name in json.skins) {
                var skinInfo = json.skins[name];
                var skeleton = new Skeleton({
                    name : name
                });
                for (var i = 0; i < skinInfo.roots.length; i++) {
                    var rootJointName = skinInfo.roots[i];
                    var rootJoint = createJoint(rootJointName, undefined, skeleton);
                    if (rootJoint) {
                        skeleton.roots.push(rootJoint);
                    }
                }
                if (skeleton.joints.length) {
                    lib.skeletons[name] = skeleton;
                    skeleton.updateJointMatrices();
                    skeleton.update();
                }
            }

            for (var name in lib.meshes) {
                var meshList = lib.meshes[name];
                for (var i = 0; i < meshList.length; i++) {
                    var mesh = meshList[i];
                    if (mesh.skeleton) {
                        var material = mesh.material;
                        mesh.skeleton = lib.skeletons[mesh.skeleton];
                        if (mesh.skeleton) {
                            for (var j = 0; j < mesh.skeleton.joints.length; j++) {
                                mesh.joints.push(j);
                            }
                            material.shader = material.shader.clone();
                            material.shader.define('vertex', 'SKINNING');
                            material.shader.define('vertex', 'JOINT_NUMBER', mesh.joints.length);
                        } 
                    }
                }
            }
        },

        _parseTextures : function(json, lib) {
            var root = this.textureRootPath || this.rootPath;
            util.each(json.textures, function(textureInfo, name){
                var samplerInfo = json.samplers[textureInfo.sampler];
                var parameters = {};
                ['wrapS', 'wrapT', 'magFilter', 'minFilter']
                .forEach(function(name) {
                    var value = samplerInfo[name];
                    if (value !== undefined) {
                        if (typeof(value) === 'string') {
                            // DEPRECATED, sampler parameter now use gl enum instead of string
                            value = glenum[value];
                        }
                        parameters[name] = value;   
                    }
                });

                var target = textureInfo.target;
                var format = textureInfo.format;
                if (typeof(target) === 'string') {
                    // DEPRECATED
                    target = glenum[target];
                    format = glenum[format];
                }
                parameters.format = format;

                if (target === glenum.TEXTURE_2D) {
                    var texture = new Texture2D(parameters);
                    var imageInfo = json.images[textureInfo.source];
                    texture.load(util.relative2absolute(imageInfo.path, root));
                    lib.textures[name] = texture;
                } else if(target === glenum.TEXTURE_CUBE_MAP) {
                    // TODO
                }
            }, this);
        },

        // Only phong material is support yet
        // TODO : support custom material
        _parseMaterials : function(json, lib) {
            var self = this;
            var techniques = {};
            // Parse techniques
            for (var name in json.techniques) {
                var techniqueInfo = json.techniques[name];
                // Default phong shader
                // var shader = new Shader({
                //     vertex : Shader.source("buildin.phong.vertex"),
                //     fragment : Shader.source("buildin.phong.fragment")
                // });
                techniques[name] = {
                    // shader : shader,
                    pass : techniqueInfo.passes[techniqueInfo.pass]
                }
            }
            for (var name in json.materials) {
                var materialInfo = json.materials[name];

                var instanceTechniqueInfo = materialInfo.instanceTechnique;
                var technique = techniques[instanceTechniqueInfo.technique];
                var pass = technique.pass;
                var uniforms = {};
                // DEPRECATED
                // https://github.com/KhronosGroup/glTF/issues/108
                // https://github.com/KhronosGroup/glTF/issues/110
                if (instanceTechniqueInfo.values instanceof Array) {
                    instanceTechniqueInfo.values.forEach(function(item){
                        uniforms[item.parameter] = item.value;
                    });
                } else {
                    uniforms = instanceTechniqueInfo.values;
                }
                for (var symbol in uniforms) {
                    var value = uniforms[symbol];
                    // TODO: texture judgement should be more robust
                    if (typeof(value) === 'string' && lib.textures[value]) {
                        uniforms[symbol] = lib.textures[value];
                    }
                }
                var enabledTextures = [];
                if (uniforms['diffuse'] instanceof Texture2D) {
                    enabledTextures.push('diffuseMap');
                }
                if (uniforms['normalMap'] instanceof Texture2D) {
                    enabledTextures.push('normalMap');
                }
                var material = new Material({
                    name : materialInfo.name,
                    shader : shaderLibrary.get(this.shaderName, enabledTextures)
                });
                if (pass.states.depthMask !== undefined) {
                    material.depthMask = pass.states.depthMask;
                }
                if (pass.states.depthTestEnable !== undefined) {
                    material.depthTest = pass.states.depthTestEnable;
                }
                material.cullFace = pass.states.cullFaceEnable || false;
                if (pass.states.blendEnable) {
                    material.transparent = true;
                    // TODO blend Func and blend Equation
                }

                if (uniforms['diffuse']) {
                    // Color
                    if (uniforms['diffuse'] instanceof Array) {
                        material.set("color", uniforms['diffuse'].slice(0, 3));
                    } else { // Texture
                        material.set("diffuseMap", uniforms["diffuse"]);
                    }
                }
                if (uniforms['normalMap'] !== undefined) {
                    material.set("normalMap", uniforms["normalMap"]);
                }
                if (uniforms['emission'] !== undefined) {
                    material.set('emission', uniforms['emission'].slice(0, 3));
                }
                if (uniforms['shininess'] !== undefined) {
                    material.set("glossiness", Math.log(uniforms["shininess"]) / Math.log(8192));
                    material.set("shininess", uniforms["shininess"]);
                } else {
                    material.set("glossiness", 0.5);
                    material.set("shininess", 0.5);
                }
                if (uniforms["specular"] !== undefined) {
                    material.set("specularColor", uniforms["specular"].slice(0, 3));
                }
                if (uniforms["transparency"] !== undefined) {
                    material.set("alpha", uniforms["transparency"]);
                }

                lib.materials[name] = material;
            }
        },

        _parseMeshes : function(json, lib) {
            var self = this;

            var meshKeys = Object.keys(json.meshes);
            for (var nn = 0; nn < meshKeys.length; nn++) {
                var name = meshKeys[nn];
                var meshInfo = json.meshes[name];

                lib.meshes[name] = [];
                // Geometry
                for (var pp = 0; pp < meshInfo.primitives.length; pp++) {
                    var primitiveInfo = meshInfo.primitives[pp];
                    var geometry = new StaticGeometry({
                        boundingBox : new BoundingBox()
                    });
                    // Parse indices
                    if (json.indices) {
                        // DEPRECATED
                        // https://github.com/KhronosGroup/glTF/issues/161
                        var indicesInfo = json.indices[primitiveInfo.indices];
                    } else {
                        var indicesInfo = json.accessors[primitiveInfo.indices];
                    }
                    var bufferViewInfo = json.bufferViews[indicesInfo.bufferView];
                    var buffer = lib.buffers[bufferViewInfo.buffer];
                    var byteOffset = bufferViewInfo.byteOffset + indicesInfo.byteOffset;

                    geometry.faces = new Uint16Array(buffer, byteOffset, indicesInfo.count);

                    // DEPRECATED
                    // https://github.com/KhronosGroup/glTF/issues/162
                    if (primitiveInfo.semantics) {
                        primitiveInfo.attributes = primitiveInfo.semantics
                    }
                    // Parse attributes
                    var semantics = Object.keys(primitiveInfo.attributes);
                    for (var ss = 0; ss < semantics.length; ss++) {
                        var semantic = semantics[ss];
                        var accessorName = primitiveInfo.attributes[semantic];
                        if (json.attributes) {
                            // DEPRECATED
                            // https://github.com/KhronosGroup/glTF/issues/161
                            var attributeInfo = json.attributes[accessorName];
                        } else {
                            var attributeInfo = json.accessors[accessorName];
                        }
                        var attributeName = semanticAttributeMap[semantic];
                        if (!attributeName) {
                            continue;
                        }
                        var attributeType = attributeInfo.type;
                        var bufferViewInfo = json.bufferViews[attributeInfo.bufferView];
                        var buffer = lib.buffers[bufferViewInfo.buffer];
                        var byteOffset = bufferViewInfo.byteOffset + attributeInfo.byteOffset;

                        if (typeof(attributeType) === 'string') {
                            // DEPRECATED
                            attributeType = glenum[attributeType];
                        }
                        switch(attributeType) {
                            case 0x8B50:     // FLOAT_VEC2
                                var size = 2;
                                var type = 'float';
                                var arrayConstructor = Float32Array;
                                break;
                            case 0x8B51:     // FLOAT_VEC3
                                var size = 3;
                                var type = 'float';
                                var arrayConstructor = Float32Array;
                                break;
                            case 0x8B52:     // FLOAT_VEC4
                                var size = 4;
                                var type = 'float';
                                var arrayConstructor = Float32Array;
                                break;
                            case 0x1406:     // FLOAT
                                var size = 1;
                                var type = 'float';
                                var arrayConstructor = Float32Array;
                                break;
                            default:
                                console.warn("Attribute type "+attributeInfo.type+" not support yet");
                                break;
                        }
                        var attributeArray = new arrayConstructor(buffer, byteOffset, attributeInfo.count * size);
                        if (semantic === 'WEIGHT' && size === 4) {
                            // Weight data in QTEK has only 3 component, the last component can be evaluated since it is normalized
                            var weightArray = new arrayConstructor(attributeInfo.count * 3);
                            for (var i = 0; i < attributeInfo.count; i++) {
                                weightArray[i * 3] = attributeArray[i * 4];
                                weightArray[i * 3 + 1] = attributeArray[i * 4 + 1];
                                weightArray[i * 3 + 2] = attributeArray[i * 4 + 2];
                            }
                            geometry.attributes[attributeName].value = weightArray;
                        } else {
                            geometry.attributes[attributeName].value = attributeArray;
                        }
                        if (semantic === 'POSITION') {
                            // Bounding Box
                            var min = attributeInfo.min;
                            var max = attributeInfo.max;
                            if (min) {
                                geometry.boundingBox.min.set(min[0], min[1], min[2]);
                            }
                            if (max) {
                                geometry.boundingBox.max.set(max[0], max[1], max[2]);
                            }
                        }
                    }

                    var material = lib.materials[primitiveInfo.material];
                    //Collada export from blender may not have default material
                    if (!material) {
                        material = new Material({
                            shader : shaderLibrary.get(self.shaderName)
                        })
                    }
                    var mesh = new Mesh({
                        geometry : geometry,
                        material : material
                    });
                    if (material.shader.isTextureEnabled('normalMap')) {
                        if (!mesh.geometry.attributes.tangent.value) {
                            mesh.geometry.generateTangents();
                        }
                    }

                    // DEPRECATED
                    var skinName = primitiveInfo.skin;
                    if (skinName) {
                        mesh.skeleton = skinName;
                    }
                    if (meshInfo.name) {
                        if (meshInfo.primitives.length > 1) {
                            mesh.name = [meshInfo.name, pp].join('-');
                        }
                        else {
                            // PENDING name or meshInfo.name ?
                            mesh.name = meshInfo.name;
                        }
                    }

                    lib.meshes[name].push(mesh);
                }
            }
        },

        _parseNodes : function(json, lib) {

            for (var name in json.nodes) {
                var nodeInfo = json.nodes[name];
                var node;
                if (nodeInfo.camera) {
                    var cameraInfo = json.cameras[nodeInfo.camera];

                    if (cameraInfo.projection === "perspective") {
                        node = new PerspectiveCamera({
                            name : nodeInfo.name,
                            aspect : cameraInfo.aspect_ratio,
                            fov : cameraInfo.xfov,
                            far : cameraInfo.zfar,
                            near : cameraInfo.znear
                        });
                    } else {
                        // TODO
                        node = new OrthographicCamera();
                        console.warn("TODO:Orthographic camera")
                    }
                    node.setName(nodeInfo.name);
                    lib.cameras[nodeInfo.name] = node;
                }
                else if (nodeInfo.lights) {
                    var lights = [];
                    for (var i = 0; i < nodeInfo.lights.length; i++) {
                        var lightInfo = json.lights[nodeInfo.lights[i]];
                        var light = this._parseLight(lightInfo);
                        if (light) {
                            lights.push(light);
                        }
                    }
                    if (lights.length == 1) {
                        // Replace the node with light
                        node = light;
                        node.setName(nodeInfo.name);
                    } else {
                        node = new Node();
                        node.setName(nodeInfo.name);
                        for (var i = 0; i < lights.length; i++) {
                            node.add(light);
                        }
                    }
                }
                else if (nodeInfo.meshes || nodeInfo.instanceSkin) {
                    // TODO one node have multiple meshes ?
                    if (nodeInfo.meshes) {
                        var meshKey = nodeInfo.meshes[0];
                    } else {
                        var meshKey = nodeInfo.instanceSkin.sources[0];
                    }
                    if (meshKey) {
                        var primitives = lib.meshes[meshKey];
                        if (primitives) {
                            if (primitives.length === 1) {
                                // Replace the node with mesh directly
                                node = primitives[0];
                                node.setName(nodeInfo.name);
                            } else {
                                node = new Node();
                                node.setName(nodeInfo.name);
                                for (var j = 0; j < primitives.length; j++) {                            
                                    if (nodeInfo.instanceSkin) {
                                        primitives[j].skeleton = nodeInfo.instanceSkin.skin;
                                    }
                                    node.add(primitives[j]);
                                }   
                            }
                        }
                    }
                } else {
                    node = new Node();
                    node.setName(nodeInfo.name);
                }
                if (nodeInfo.matrix) {
                    for (var i = 0; i < 16; i++) {
                        node.localTransform._array[i] = nodeInfo.matrix[i];
                    }
                    node.decomposeLocalTransform();
                } else {
                    if (nodeInfo.translation) {
                        node.position.setArray(nodeInfo.translation);
                    }
                    if (nodeInfo.rotation) {
                        // glTF use axis angle in rotation
                        // https://github.com/KhronosGroup/glTF/issues/144
                        quat.setAxisAngle(node.rotation._array, nodeInfo.rotation.slice(0, 3), nodeInfo.rotation[3]);
                        node.rotation._dirty = true;
                    }
                    if (nodeInfo.scale) {
                        node.scale.setArray(nodeInfo.scale);
                    }
                }

                lib.nodes[name] = node;
            }

            // Build hierarchy
            for (var name in json.nodes) {
                var nodeInfo = json.nodes[name];
                var node = lib.nodes[name];
                if (nodeInfo.children) {
                    for (var i = 0; i < nodeInfo.children.length; i++) {
                        var childName = nodeInfo.children[i];
                        var child = lib.nodes[childName];
                        node.add(child);
                    }
                }
            }
         },

        _parseLight : function(lightInfo) {
            // TODO : Light parameters
            switch(lightInfo.type) {
                case "point":
                    var light = new PointLight({
                        name : lightInfo.id,
                        color : lightInfo.point.color,
                    });
                    break;
                case "spot":
                    var light = new SpotLight({
                        name : lightInfo.id,
                        color : lightInfo.spot.color
                    });
                    break;
                case "directional":
                    var light = new DirectionalLight({
                        name : lightInfo.id,
                        color : lightInfo.directional.color
                    });
                    break;
                default:
                    console.warn("Light " + lightInfo.type + " not support yet");
            }

            return light;
        },

        _parseAnimations : function(json, lib) {
            // TODO Only support nodes animation now
            var clip = new SkinningClip();
            var haveAnimation = false;

            var jointClips = {};

            var quatTmp = quat.create();

            for (var animName in json.animations) {
                haveAnimation = true;
                var animationInfo = json.animations[animName];
                var parameters = {};

                for (var paramName in animationInfo.parameters) {
                    var accessorName = animationInfo.parameters[paramName];
                    var accessorInfo = json.accessors[accessorName];

                    var bufferViewInfo = json.bufferViews[accessorInfo.bufferView];
                    var buffer = lib.buffers[bufferViewInfo.buffer];
                    var byteOffset = bufferViewInfo.byteOffset + accessorInfo.byteOffset;
                    switch(accessorInfo.type) {
                        case 0x8B50:     // FLOAT_VEC2
                            var size = 2;
                            break;
                        case 0x8B51:     // FLOAT_VEC3
                            var size = 3;
                            break;
                        case 0x8B52:     // FLOAT_VEC4
                            var size = 4;
                            break;
                        case 0x1406:     // FLOAT
                            var size = 1;
                            break;
                    }
                    parameters[paramName] = new Float32Array(buffer, byteOffset, size * accessorInfo.count);
                }

                if (!parameters.TIME) {
                    continue;
                }

                // Use the first channels target
                var targetId = animationInfo.channels[0].target.id;
                var targetNode = lib.nodes[targetId];

                // glTF use axis angle in rotation, convert to quaternion
                // https://github.com/KhronosGroup/glTF/issues/144
                var rotationArr = parameters.rotation;
                if (rotationArr) {
                    for (i = 0; i < parameters.TIME.length; i++) {
                        parameters.TIME[i] *= 1000;
                        var offset = i * 4;
                        if (rotationArr) {
                            quatTmp[0] = rotationArr[offset];
                            quatTmp[1] = rotationArr[offset + 1];
                            quatTmp[2] = rotationArr[offset + 2];
                            quat.setAxisAngle(quatTmp, quatTmp, rotationArr[offset + 3]);
                            parameters.rotation[offset] = quatTmp[0];
                            parameters.rotation[offset + 1] = quatTmp[1];
                            parameters.rotation[offset + 2] = quatTmp[2];
                            parameters.rotation[offset + 3] = quatTmp[3];
                        }
                    }
                }

                // TODO
                // if (jointClips[targetId]) {
                //     continue;
                // }
                jointClips[targetId] = new SamplerClip({
                    name : targetNode.name
                });
                var jointClip = jointClips[targetId];
                jointClip.channels.time = parameters.TIME;
                jointClip.channels.rotation = parameters.rotation || null;
                jointClip.channels.position = parameters.translation || null;
                jointClip.channels.scale = parameters.scale || null;
                jointClip.life = parameters.TIME[parameters.TIME.length - 1];
            }

            for (var targetId in jointClips) {
                clip.addJointClip(jointClips[targetId]);
            }

            if (haveAnimation) {
                return clip;
            } else {
                return null;
            }
        }
    });

    return Loader;
});
/**
 * Load three.js JSON Format model
 *
 * Format specification : https://github.com/mrdoob/three.js/wiki/JSON-Model-format-3.1
 */
define('qtek/loader/ThreeModel',['require','../core/Base','../core/request','../core/util','../Shader','../Material','../DynamicGeometry','../Mesh','../Node','../texture/Texture2D','../texture/TextureCube','../shader/library','../Skeleton','../Joint','../math/Vector3','../math/Quaternion','../core/glenum','../animation/SkinningClip','glmatrix'],function(require) {

    var Base = require('../core/Base');

    var request = require("../core/request");
    var util = require('../core/util');
    var Shader = require("../Shader");
    var Material = require("../Material");
    var DynamicGeometry = require("../DynamicGeometry");
    var Mesh = require("../Mesh");
    var Node = require("../Node");
    var Texture2D = require("../texture/Texture2D");
    var TextureCube = require("../texture/TextureCube");
    var shaderLibrary = require("../shader/library");
    var Skeleton = require("../Skeleton");
    var Joint = require("../Joint");
    var Vector3 = require("../math/Vector3");
    var Quaternion = require("../math/Quaternion");
    var glenum = require('../core/glenum');
    var SkinningClip = require('../animation/SkinningClip');

    var glMatrix = require("glmatrix");
    var vec3 = glMatrix.vec3;
    var vec2 = glMatrix.vec2;
    var quat = glMatrix.quat;

    var Loader = Base.derive({
        rootPath : "",
        textureRootPath : ""
    }, {
        load : function(url) {
            var self = this;

            if (!this.rootPath) {
                this.rootPath = url.slice(0, url.lastIndexOf("/"));
            }

            request.get({
                url : url,
                onprogress : function(percent, loaded, total) {
                    self.trigger("progress", percent, loaded, total);
                },
                onerror : function(e) {
                    self.trigger("error", e);
                },
                responseType : "text",
                onload : function(data) {
                    self.parse(JSON.parse(data));
                }
            });
        },
        parse : function(data) {
            
            var geometryList = this._parseGeometry(data);

            var dSkinIndices = data.skinIndices,
                dSkinWeights = data.skinWeights;
            var skinned = dSkinIndices && dSkinIndices.length
                        && dSkinWeights && dSkinWeights.length;

            if (skinned) {
                var skeleton = this._parseSkeleton(data);
                var jointNumber = skeleton.joints.length;
            }else{
                var jointNumber = 0;
            }

            if (skinned) {
                var skeleton = this._parseSkeleton(data);
                var jointNumber = skeleton.joints.length;
            }else{
                var jointNumber = 0;
            }

            var meshList = [];
            for (var i = 0; i < data.materials.length; i++) {
                var geometry = geometryList[i];
                if (geometry 
                    && geometry.faces.length 
                    && geometry.attributes.position.value.length) {
                    geometry.updateBoundingBox();
                    var material = this._parseMaterial(data.materials[i], jointNumber);
                    var mesh = new Mesh({
                        geometry : geometryList[i],
                        material : material
                    }) ;
                    if (skinned) {
                        mesh.skeleton = skeleton;
                        for (var i = 0; i < skeleton.joints.length; i++) {
                            // Use all the joints of skeleton
                            mesh.joints[i] = i;
                        }
                    }
                    meshList.push(mesh);
                }
            }
            
            this.trigger('success', meshList);

            return meshList;
        },

        _parseGeometry : function(data) {

            var geometryList = [];
            var cursorList = [];
            
            for (var i = 0; i < data.materials.length; i++) {
                geometryList[i] = null;
                cursorList[i] = 0;
            }
            geometryList[0] = new DynamicGeometry();

            var faceMaterial = data.materials && data.materials.length > 1;

            var dFaces = data.faces;
            var dVertices = data.vertices;
            var dNormals = data.normals;
            var dColors = data.colors;
            var dSkinIndices = data.skinIndices;
            var dSkinWeights = data.skinWeights;
            var dUvs = data.uvs;

            var skinned = dSkinIndices && dSkinIndices.length
                        && dSkinWeights && dSkinWeights.length;

            var geometry = geometryList[0];
            var attributes = geometry.attributes;
            var positions = attributes.position.value;
            var normals = attributes.normal.value;
            var texcoords = [attributes.texcoord0.value,
                            attributes.texcoord1.value];
            var colors = attributes.color.value;
            var jointIndices = attributes.joint.value;
            var jointWeights = attributes.weight.value;
            var faces = geometry.faces;

            var nUvLayers = 0;
            if (dUvs[0] && dUvs[0].length) {
                nUvLayers++;
            }
            if (dUvs[1] && dUvs[1].length) {
                nUvLayers++;
            }

            var offset = 0;
            var len = dFaces.length;

            // Cache the reorganized index
            var newIndexMap = [];
            var geoIndexMap = [];
            for (var i = 0; i < dVertices.length; i++) {
                newIndexMap[i] = -1;
                geoIndexMap[i] = -1;
            }

            var currentGeometryIndex = 0;
            var isNew = [];
            function getNewIndex(oi, faceIndex) {
                if ( newIndexMap[oi] >= 0) {
                    // Switch to the geometry of existed index 
                    currentGeometryIndex = geoIndexMap[oi];
                    geometry = geometryList[currentGeometryIndex];
                    attributes = geometry.attributes;
                    positions = attributes.position.value;
                    normals = attributes.normal.value;
                    texcoords = [attributes.texcoord0.value,
                                attributes.texcoord1.value];
                    colors = attributes.color.value;
                    jointWeights = attributes.weight.value;
                    jointIndices = attributes.joint.value;

                    isNew[faceIndex] = false;
                    return newIndexMap[oi];
                }else{

                    positions.push([dVertices[oi*3], dVertices[oi*3+1], dVertices[oi*3+2]]);
                    //Skin data
                    if (skinned) {
                        jointWeights.push([dSkinWeights[oi*2], dSkinWeights[oi*2+1], 0]);
                        jointIndices.push([dSkinIndices[oi*2], dSkinIndices[oi*2+1], -1, -1]);
                    }

                    newIndexMap[oi] = cursorList[materialIndex];
                    geoIndexMap[oi] = materialIndex;

                    isNew[faceIndex] = true;
                    return cursorList[materialIndex]++;
                }
            }
            // Put the vertex data of one face here
            // Incase the program create amount of tmp arrays and cause
            // GC bottleneck
            var faceUvs = [];
            var faceNormals = [];
            var faceColors = [];
            for (var i =0; i < 4; i++) {
                faceUvs[i] = [0, 0];
                faceNormals[i] = [0, 0, 0];
                faceColors[i] = [0, 0, 0];
            }
            var materialIndex = 0;

            while (offset < len) {
                var type = dFaces[offset++];
                var isQuad = isBitSet(type, 0),
                    hasMaterial = isBitSet(type, 1),
                    hasFaceUv = isBitSet(type, 2),
                    hasFaceVertexUv = isBitSet(type, 3),
                    hasFaceNormal = isBitSet(type, 4),
                    hasFaceVertexNormal = isBitSet(type, 5),
                    hasFaceColor = isBitSet(type, 6),
                    hasFaceVertexColor = isBitSet(type, 7);

                var nVertices = isQuad ? 4 : 3;

                if (hasMaterial) {
                    materialIndex = dFaces[ offset+ (isQuad ? 4 : 3) ];
                    if ( ! geometryList[materialIndex] ) {
                        geometryList[materialIndex] = new DynamicGeometry();
                    }
                    geometry = geometryList[materialIndex];
                    attributes = geometry.attributes;
                    positions = attributes.position.value;
                    normals = attributes.normal.value;
                    texcoords = [attributes.texcoord0.value,
                                attributes.texcoord1.value];
                    colors = attributes.color.value;
                    jointWeights = attributes.weight.value;
                    jointIndices = attributes.joint.value;
                    faces = geometry.faces;
                }
                if (isQuad) {
                    // Split into two triangle faces, 1-2-4 and 2-3-4
                    var i1o = dFaces[offset++],
                        i2o = dFaces[offset++],
                        i3o = dFaces[offset++],
                        i4o = dFaces[offset++];
                    // Face1
                    var i1 = getNewIndex(i1o, 0),
                        i2 = getNewIndex(i2o, 1),
                        i3 = getNewIndex(i4o, 2),
                    // Face2
                        i4 = getNewIndex(i2o, 3),
                        i5 = getNewIndex(i3o, 4),
                        i6 = getNewIndex(i4o, 5);
                    faces.push([i1, i2, i3], [i4, i5, i6]);
                } else {
                    var i1 = dFaces[offset++],
                        i2 = dFaces[offset++],
                        i3 = dFaces[offset++];
                    i1 = getNewIndex(i1, 0);
                    i2 = getNewIndex(i2, 1);
                    i3 = getNewIndex(i3, 2);
                    faces.push([i1, i2, i3]);
                }
                if (hasMaterial) {
                    offset++;
                }
                if (hasFaceUv) {
                    for (var i = 0; i < nUvLayers; i++) {
                        var uvLayer = dUvs[i];
                        var uvIndex = faces[offset++];
                        var u = uvLayer[uvIndex*2];
                        var v = uvLayer[uvIndex*2+1];
                        if (isQuad) {
                            // Random write of array seems not slow
                            // http://jsperf.com/random-vs-sequence-array-set
                            isNew[0] && (texcoords[i][i1] = [u, v]);
                            isNew[1] && (texcoords[i][i2] = [u, v]);
                            isNew[2] && (texcoords[i][i3] = [u, v]);
                            isNew[3] && (texcoords[i][i4] = [u, v]);
                            isNew[4] && (texcoords[i][i5] = [u, v]);
                            isNew[5] && (texcoords[i][i6] = [u, v]);
                        } else {
                            isNew[0] && (texcoords[i][i1] = [u, v]);
                            isNew[1] && (texcoords[i][i2] = [u, v]);
                            isNew[2] && (texcoords[i][i3] = [u, v]);
                        }
                    }
                }
                if (hasFaceVertexUv) {
                    for (var i = 0; i < nUvLayers; i++) {
                        var uvLayer = dUvs[i];
                        for (var j = 0; j < nVertices; j++) {
                            var uvIndex = dFaces[offset++];
                            faceUvs[j][0] = uvLayer[uvIndex*2];
                            faceUvs[j][1] = uvLayer[uvIndex*2+1];
                        }
                        if (isQuad) {
                            // Use array slice to clone array is incredibly faster than 
                            // Construct from Float32Array
                            // http://jsperf.com/typedarray-v-s-array-clone/2
                            isNew[0] && (texcoords[i][i1] = faceUvs[0].slice());
                            isNew[1] && (texcoords[i][i2] = faceUvs[1].slice());
                            isNew[2] && (texcoords[i][i3] = faceUvs[3].slice());
                            isNew[3] && (texcoords[i][i4] = faceUvs[1].slice());
                            isNew[4] && (texcoords[i][i5] = faceUvs[2].slice());
                            isNew[5] && (texcoords[i][i6] = faceUvs[3].slice());
                        } else {
                            isNew[0] && (texcoords[i][i1] = faceUvs[0].slice());
                            isNew[1] && (texcoords[i][i2] = faceUvs[1].slice());
                            isNew[2] && (texcoords[i][i3] = faceUvs[2].slice());
                        }
                    }
                }
                if (hasFaceNormal) {
                    var normalIndex = dFaces[offset++]*3;
                    var x = dNormals[normalIndex++];
                    var y = dNormals[normalIndex++];
                    var z = dNormals[normalIndex];
                    if (isQuad) {
                        isNew[0] && (normals[i1] = [x, y, z]);
                        isNew[1] && (normals[i2] = [x, y, z]);
                        isNew[2] && (normals[i3] = [x, y, z]);
                        isNew[3] && (normals[i4] = [x, y, z]);
                        isNew[4] && (normals[i5] = [x, y, z]);
                        isNew[5] && (normals[i6] = [x, y, z]);
                    }else{
                        isNew[0] && (normals[i1] = [x, y, z]);
                        isNew[1] && (normals[i2] = [x, y, z]);
                        isNew[2] && (normals[i3] = [x, y, z]);
                    }
                }
                if (hasFaceVertexNormal) {
                    for (var i = 0; i < nVertices; i++) {
                        var normalIndex = dFaces[offset++]*3;
                        faceNormals[i][0] = dNormals[normalIndex++];
                        faceNormals[i][1] = dNormals[normalIndex++];
                        faceNormals[i][2] = dNormals[normalIndex];
                    }
                    if (isQuad) {
                        isNew[0] && (normals[i1] = faceNormals[0].slice());
                        isNew[1] && (normals[i2] = faceNormals[1].slice());
                        isNew[2] && (normals[i3] = faceNormals[3].slice());
                        isNew[3] && (normals[i4] = faceNormals[1].slice());
                        isNew[4] && (normals[i5] = faceNormals[2].slice());
                        isNew[5] && (normals[i6] = faceNormals[3].slice());
                    } else {
                        isNew[0] && (normals[i1] = faceNormals[0].slice());
                        isNew[1] && (normals[i2] = faceNormals[1].slice());
                        isNew[2] && (normals[i3] = faceNormals[2].slice());
                    }
                }
                if (hasFaceColor) {
                    var colorIndex = dFaces[offset++];
                    var color = hex2rgb(dColors[colorIndex]);
                    if (isQuad) {
                        // Does't clone the color here
                        isNew[0] && (colors[i1] = color);
                        isNew[1] && (colors[i2] = color);
                        isNew[2] && (colors[i3] = color);
                        isNew[3] && (colors[i4] = color);
                        isNew[4] && (colors[i5] = color);
                        isNew[5] && (colors[i6] = color);
                    } else {
                        isNew[0] && (colors[i1] = color);
                        isNew[1] && (colors[i2] = color);
                        isNew[2] && (colors[i3] = color);
                    }
                }
                if (hasFaceVertexColor) {
                    for (var i = 0; i < nVertices; i++) {
                        var colorIndex = dFaces[offset++];
                        faceColors[i] = hex2rgb(dColors[colorIndex]);
                    }
                    if (isQuad) {
                        isNew[0] && (colors[i1] = faceColors[0].slice());
                        isNew[1] && (colors[i2] = faceColors[1].slice());
                        isNew[2] && (colors[i3] = faceColors[3].slice());
                        isNew[3] && (colors[i4] = faceColors[1].slice());
                        isNew[4] && (colors[i5] = faceColors[2].slice());
                        isNew[5] && (colors[i6] = faceColors[3].slice());
                    } else {
                        isNew[0] && (colors[i1] = faceColors[0].slice());
                        isNew[1] && (colors[i2] = faceColors[1].slice());
                        isNew[2] && (colors[i3] = faceColors[2].slice());
                    }
                }
            }

            return geometryList;
        },

        _parseSkeleton : function(data) {
            var joints = [];
            var dBones = data.bones;
            for ( var i = 0; i < dBones.length; i++) {
                var dBone = dBones[i];
                var joint = new Joint({
                    index : i,
                    parentIndex : dBone.parent,
                    name : dBone.name
                });
                joint.node = new Node({
                    name : dBone.name,
                    position : new Vector3(dBone.pos[0], dBone.pos[1], dBone.pos[2]),
                    rotation : new Quaternion(dBone.rotq[0], dBone.rotq[1], dBone.rotq[2], dBone.rotq[3]),
                    scale : new Vector3(dBone.scl[0], dBone.scl[1], dBone.scl[2])
                })
                joints.push(joint);
            }

            var skeleton = new Skeleton({
                joints : joints
            });
            skeleton.updateHierarchy();
            skeleton.updateJointMatrices();
            skeleton.update();

            if (data.animation) {
                var dFrames = data.animation.hierarchy;

                var jointClips = [];
                // Parse Animations
                for (var i = 0; i < dFrames.length; i++) {
                    var channel = dFrames[i];
                    var jointPose = jointClips[i] = {
                        keyFrames : []
                    };
                    jointPose.name = joints[i].name;
                    for (var j = 0; j < channel.keys.length; j++) {
                        var key = channel.keys[j];
                        jointPose.keyFrames[j] = {};
                        var kf = jointPose.keyFrames[j];
                        kf.time = parseFloat(key.time) * 1000;
                        if (key.pos) {
                            kf.position = vec3.fromValues(key.pos[0], key.pos[1], key.pos[2]);
                        }
                        if (key.rot) {
                            kf.rotation = quat.fromValues(key.rot[0], key.rot[1], key.rot[2], key.rot[3]);
                        }
                        if (key.scl) {
                            kf.scale = vec3.fromValues(key.scl[0], key.scl[1], key.scl[2]);
                        }
                    }
                }

                var skinningClip = new SkinningClip({
                    jointClips : jointClips
                });

                skeleton.addClip(skinningClip);
            }

            return skeleton;
        },

        _parseMaterial : function(mConfig, jointNumber) {
            var shaderName = "buildin.lambert";
            var shading = mConfig.shading && mConfig.shading.toLowerCase();
            if (shading === "phong" || shading === "lambert") {
                shaderName = "buildin." + shading;
            }
            var enabledTextures = [];
            if (mConfig.mapDiffuse) {
                enabledTextures.push("diffuseMap");
            }
            if (mConfig.mapNormal || mConfig.mapBump) {
                enabledTextures.push('normalMap');
            }
            if (jointNumber == 0) {
                var shader = shaderLibrary.get(shaderName, enabledTextures);
            } else {
                // Shader for skinned mesh
                var shader = new Shader({
                    vertex : Shader.source(shaderName+".vertex"),
                    fragment : Shader.source(shaderName+".fragment")
                })
                for (var i = 0; i < enabledTextures; i++) {
                    shader.enableTexture(enabledTextures[i]);
                }
                shader.define('vertex', "SKINNING");
                shader.define('vertex', "JOINT_NUMBER", jointNumber);
            }

            var material = new Material({
                shader : shader
            });
            if (mConfig.colorDiffuse) {
                material.set("color", mConfig.colorDiffuse );
            } else if (mConfig.DbgColor) {
                material.set("color", hex2rgb(mConfig.DbgColor));
            }
            if (mConfig.colorSpecular) {
                material.set("specular", mConfig.colorSpecular );
            }
            if (mConfig.transparent !== undefined && mConfig.transparent) {
                material.transparent = true;
            }
            if (mConfig.depthTest !== undefined) {
                material.depthTest = mConfig.depthTest;
            }
            if (mConfig.depthWrite !== undefined) {
                material.depthMask = mConfig.depthWrite;
            }
            
            if (mConfig.transparency && mConfig.transparency < 1) {
                material.set("opacity", mConfig.transparency);
            }
            if (mConfig.specularCoef) {
                material.set("shininess", mConfig.specularCoef);
            }

            // Textures
            if (mConfig.mapDiffuse) {
                material.set("diffuseMap", this._loadTexture(mConfig.mapDiffuse, mConfig.mapDiffuseWrap) );
            }
            if (mConfig.mapBump) {
                material.set("normalMap", this._loadTexture(mConfig.mapBump, mConfig.mapBumpWrap) );
            }
            if (mConfig.mapNormal) {
                material.set("normalMap", this._loadTexture(mConfig.mapNormal, mConfig.mapBumpWrap) );
            }

            return material;
        },

        _loadTexture : function(path, wrap) {
            var self = this;

            var img = new Image();
            var texture = new Texture2D();
            texture.image = img;

            if (wrap && wrap.length) {
                texture.wrapS = glenum[wrap[0].toUpperCase()];
                texture.wrapT = glenum[wrap[1].toUpperCase()];
            }
            img.onload = function() {
                texture.dirty();
            }
            var root = this.textureRootPath || this.rootPath;
            img.src = util.relative2absolute(path, root);

            return texture;
        }
    })


    function isBitSet(value, position) {
        return value & ( 1 << position );
    }


    function hex2rgb(hex) {
        var r = (hex >> 16) & 0xff,
            g = (hex >> 8) & 0xff,
            b = hex & 0xff;
        return [r/255, g/255, b/255];
    }

    function translateColor(color) {
        return [color[0]/255, color[1]/255, color[2]/255];
    }

    return Loader
} );
define('qtek/math/Matrix2',['require','glmatrix'],function(require) {

    

    var glMatrix = require("glmatrix");
    var mat2 = glMatrix.mat2;

    function makeProperty(n) {
        return {
            configurable : false,
            set : function(value) {
                this._array[n] = value;
                this._dirty = true;
            },
            get : function() {
                return this._array[n];
            }
        }
    }

    /**
     * @constructor
     * @alias qtek.math.Matrix2
     */
    var Matrix2 = function() {

        /**
         * Storage of Matrix2
         * @type {Float32Array}
         */
        this._array = mat2.create();

        /**
         * @type {boolean}
         */
        this._dirty = true;
    };

    Matrix2.prototype = {

        constructor : Matrix2,

        /**
         * Clone a new Matrix2
         * @return {qtek.math.Matrix2}
         */
        clone : function() {
            return (new Matrix2()).copy(this);
        },

        /**
         * Copy from b
         * @param  {qtek.math.Matrix2} b
         * @return {qtek.math.Matrix2}
         */
        copy : function(b) {
            mat2.copy(this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Calculate the adjugate of self, in-place
         * @return {qtek.math.Matrix2}
         */
        adjoint : function() {
            mat2.adjoint(this._array, this._array);
            this._dirty = true;
            return this;
        },

        /**
         * Calculate matrix determinant
         * @return {number}
         */
        determinant : function() {
            return mat2.determinant(this._array);
        },

        /**
         * Set to a identity matrix
         * @return {qtek.math.Matrix2}
         */
        identity : function() {
            mat2.identity(this._array);
            this._dirty = true;
            return this;
        },

        /**
         * Invert self
         * @return {qtek.math.Matrix2}
         */
        invert : function() {
            mat2.invert(this._array, this._array);
            this._dirty = true;
            return this;
        },

        /**
         * Alias for mutiply
         * @param  {qtek.math.Matrix2} b
         * @return {qtek.math.Matrix2}
         */
        mul : function(b) {
            mat2.mul(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Alias for multiplyLeft
         * @param  {qtek.math.Matrix2} a
         * @return {qtek.math.Matrix2}
         */
        mulLeft : function(a) {
            mat2.mul(this._array, a._array, this._array);
            this._dirty = true;
            return this;
        },

        /**
         * Multiply self and b
         * @param  {qtek.math.Matrix2} b
         * @return {qtek.math.Matrix2}
         */
        multiply : function(b) {
            mat2.multiply(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Multiply a and self, a is on the left
         * @param  {qtek.math.Matrix2} a
         * @return {qtek.math.Matrix2}
         */
        multiplyLeft : function(a) {
            mat2.multiply(this._array, a._array, this._array);
            this._dirty = true;
            return this;
        },

        /**
         * Rotate self by a given radian
         * @param  {number}   rad
         * @return {qtek.math.Matrix2}
         */
        rotate : function(rad) {
            mat2.rotate(this._array, this._array, rad);
            this._dirty = true;
            return this;
        },

        /**
         * Scale self by s
         * @param  {qtek.math.Vector2}  s
         * @return {qtek.math.Matrix2}
         */
        scale : function(v) {
            mat2.scale(this._array, this._array, v._array);
            this._dirty = true;
            return this;
        },
        /**
         * Transpose self, in-place.
         * @return {qtek.math.Matrix2}
         */
        transpose: function() {
            mat2.transpose(this._array, this._array);
            this._dirty = true;
            return this;
        },
        toString : function() {
            return "[" + Array.prototype.join.call(this._array, ",") + "]";
        }
    }

    /**
     * @param  {Matrix2} out
     * @param  {Matrix2} a
     * @return {Matrix2}
     */
    Matrix2.adjoint = function(out, a) {
        mat2.adjoint(out._array, a._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix2} out
     * @param  {qtek.math.Matrix2} a
     * @return {qtek.math.Matrix2}
     */
    Matrix2.copy = function(out, a) {
        mat2.copy(out._array, a._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix2} a
     * @return {number}
     */
    Matrix2.determinant = function(a) {
        return mat2.determinant(a._array);
    }

    /**
     * @param  {qtek.math.Matrix2} out
     * @return {qtek.math.Matrix2}
     */
    Matrix2.identity = function(out) {
        mat2.identity(out._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix2} out
     * @param  {qtek.math.Matrix2} a
     * @return {qtek.math.Matrix2}
     */
    Matrix2.invert = function(out, a) {
        mat2.invert(out._array, a._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix2} out
     * @param  {qtek.math.Matrix2} a
     * @param  {qtek.math.Matrix2} b
     * @return {qtek.math.Matrix2}
     */
    Matrix2.mul = function(out, a, b) {
        mat2.mul(out._array, a._array, b._array);
        out._dirty = true;
        return out;
    }

    /**
     * @method
     * @param  {qtek.math.Matrix2} out
     * @param  {qtek.math.Matrix2} a
     * @param  {qtek.math.Matrix2} b
     * @return {qtek.math.Matrix2}
     */
    Matrix2.multiply = Matrix2.mul;

    /**
     * @param  {qtek.math.Matrix2} out
     * @param  {qtek.math.Matrix2} a
     * @param  {number}   rad
     * @return {qtek.math.Matrix2}
     */
    Matrix2.rotate = function(out, a, rad) {
        mat2.rotate(out._array, a._array, rad);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix2} out
     * @param  {qtek.math.Matrix2} a
     * @param  {qtek.math.Vector2}  v
     * @return {qtek.math.Matrix2}
     */
    Matrix2.scale = function(out, a, v) {
        mat2.scale(out._array, a._array, v._array);
        out._dirty = true;
        return out;
    }
    /**
     * @param  {Matrix2} out
     * @param  {Matrix2} a
     * @return {Matrix2}
     */
    Matrix2.transpose = function(out, a) {
        mat2.transpose(out._array, a._array);
        out._dirty = true;
        return out;
    }

    return Matrix2;
});
define('qtek/math/Matrix2d',['require','glmatrix'],function(require) {

    

    var glMatrix = require("glmatrix");
    var mat2d = glMatrix.mat2d;

    function makeProperty(n) {
        return {
            configurable : false,
            set : function(value) {
                this._array[n] = value;
                this._dirty = true;
            },
            get : function() {
                return this._array[n];
            }
        }
    }

    /**
     * @constructor
     * @alias qtek.math.Matrix2d
     */
    var Matrix2d = function() {
        /**
         * Storage of Matrix2d
         * @type {Float32Array}
         */
        this._array = mat2d.create();

        /**
         * @type {boolean}
         */
        this._dirty = true;
    };

    Matrix2d.prototype = {

        constructor : Matrix2d,

        /**
         * Clone a new Matrix2d
         * @return {qtek.math.Matrix2d}
         */
        clone : function() {
            return (new Matrix2d()).copy(this);
        },

        /**
         * Copy from b
         * @param  {qtek.math.Matrix2d} b
         * @return {qtek.math.Matrix2d}
         */
        copy : function(b) {
            mat2d.copy(this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Calculate matrix determinant
         * @return {number}
         */
        determinant : function() {
            return mat2d.determinant(this._array);
        },

        /**
         * Set to a identity matrix
         * @return {qtek.math.Matrix2d}
         */
        identity : function() {
            mat2d.identity(this._array);
            this._dirty = true;
            return this;
        },

        /**
         * Invert self
         * @return {qtek.math.Matrix2d}
         */
        invert : function() {
            mat2d.invert(this._array, this._array);
            this._dirty = true;
            return this;
        },

        /**
         * Alias for mutiply
         * @param  {qtek.math.Matrix2d} b
         * @return {qtek.math.Matrix2d}
         */
        mul : function(b) {
            mat2d.mul(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Alias for multiplyLeft
         * @param  {qtek.math.Matrix2d} a
         * @return {qtek.math.Matrix2d}
         */
        mulLeft : function(b) {
            mat2d.mul(this._array, b._array, this._array);
            this._dirty = true;
            return this;
        },

        /**
         * Multiply self and b
         * @param  {qtek.math.Matrix2d} b
         * @return {qtek.math.Matrix2d}
         */
        multiply : function(b) {
            mat2d.multiply(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Multiply a and self, a is on the left
         * @param  {qtek.math.Matrix2d} a
         * @return {qtek.math.Matrix2d}
         */
        multiplyLeft : function(b) {
            mat2d.multiply(this._array, b._array, this._array);
            this._dirty = true;
            return this;
        },

        /**
         * Rotate self by a given radian
         * @param  {number}   rad
         * @return {qtek.math.Matrix2d}
         */
        rotate : function(rad) {
            mat2d.rotate(this._array, this._array, rad);
            this._dirty = true;
            return this;
        },

        /**
         * Scale self by s
         * @param  {qtek.math.Vector2}  s
         * @return {qtek.math.Matrix2d}
         */
        scale : function(s) {
            mat2d.scale(this._array, this._array, s._array);
            this._dirty = true;
            return this;
        },

        /**
         * Translate self by v
         * @param  {qtek.math.Vector2}  v
         * @return {qtek.math.Matrix2d}
         */
        translate : function(v) {
            mat2d.translate(this._array, this._array, v._array);
            this._dirty = true;
            return this;
        },
        toString : function() {
            return "[" + Array.prototype.join.call(this._array, ",") + "]";
        }
    }

    /**
     * @param  {qtek.math.Matrix2d} out
     * @param  {qtek.math.Matrix2d} a
     * @return {qtek.math.Matrix2d}
     */
    Matrix2d.copy = function(out, a) {
        mat2d.copy(out._array, a._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix2d} a
     * @return {number}
     */
    Matrix2d.determinant = function(a) {
        return mat2d.determinant(a._array);
    }

    /**
     * @param  {qtek.math.Matrix2d} out
     * @return {qtek.math.Matrix2d}
     */
    Matrix2d.identity = function(out) {
        mat2d.identity(out._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix2d} out
     * @param  {qtek.math.Matrix2d} a
     * @return {qtek.math.Matrix2d}
     */
    Matrix2d.invert = function(out, a) {
        mat2d.invert(out._array, a._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix2d} out
     * @param  {qtek.math.Matrix2d} a
     * @param  {qtek.math.Matrix2d} b
     * @return {qtek.math.Matrix2d}
     */
    Matrix2d.mul = function(out, a, b) {
        mat2d.mul(out._array, a._array, b._array);
        out._dirty = true;
        return out;
    }

    /**
     * @method
     * @param  {qtek.math.Matrix2d} out
     * @param  {qtek.math.Matrix2d} a
     * @param  {qtek.math.Matrix2d} b
     * @return {qtek.math.Matrix2d}
     */
    Matrix2d.multiply = Matrix2d.mul;

    /**
     * @param  {qtek.math.Matrix2d} out
     * @param  {qtek.math.Matrix2d} a
     * @param  {number}   rad
     * @return {qtek.math.Matrix2d}
     */
    Matrix2d.rotate = function(out, a, rad) {
        mat2d.rotate(out._array, a._array, rad);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix2d} out
     * @param  {qtek.math.Matrix2d} a
     * @param  {qtek.math.Vector2}  v
     * @return {qtek.math.Matrix2d}
     */
    Matrix2d.scale = function(out, a, v) {
        mat2d.scale(out._array, a._array, v._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Matrix2d} out
     * @param  {qtek.math.Matrix2d} a
     * @param  {qtek.math.Vector2}  v
     * @return {qtek.math.Matrix2d}
     */
    Matrix2d.translate = function(out, a, v) {
        mat2d.translate(out._array, a._array, v._array);
        out._dirty = true;
        return out;
    }

    return Matrix2d;
});
define('qtek/math/Value',['require','./Vector3','./Vector2'],function(require) {

    var Vector3 = require('./Vector3');
    var Vector2 = require('./Vector2');

    /**
     * Random or constant 1d, 2d, 3d vector generator
     * @constructor
     * @alias qtek.math.Value
     */
    var Value = function() {};

    /**
     * @method
     * @param {number|qtek.math.Vector2|qtek.math.Vector3} [out]
     * @return {number|qtek.math.Vector2|qtek.math.Vector3}
     */
    Value.prototype.get = function(out) {};

    // Constant
    var ConstantValue = function(val) {
        this.get = function() {
            return val;
        }
    }
    ConstantValue.prototype = new Value();
    ConstantValue.prototype.constructor = ConstantValue;

    // Vector
    var VectorValue = function(val) {
        var Constructor = val.constructor;
        this.get = function(out) {
            if (!out) {
                out = new Constructor();
            }
            out.copy(val);
            return out;
        }
    }
    VectorValue.prototype = new Value();
    VectorValue.prototype.constructor = VectorValue;
    //Random 1D
    var Random1D = function(min, max) {
        var range = max - min;
        this.get = function() {
            return Math.random() * range + min;
        }
    }
    Random1D.prototype = new Value();
    Random1D.prototype.constructor = Random1D;

    // Random2D
    var Random2D = function(min, max) {
        var rangeX = max.x - min.x;
        var rangeY = max.y - min.y;

        this.get = function(out) {
            if (!out) {
                out = new Vector2();
            }
            Vector2.set(
                out,
                rangeX * Math.random() + min._array[0],
                rangeY * Math.random() + min._array[1]
            );

            return out;
        }
    }
    Random2D.prototype = new Value();
    Random2D.prototype.constructor = Random2D;

    var Random3D = function(min, max) {
        var rangeX = max.x - min.x;
        var rangeY = max.y - min.y;
        var rangeZ = max.z - min.z;

        this.get = function(out) {
            if (!out) {
                out = new Vector3();
            }
            Vector3.set(
                out,
                rangeX * Math.random() + min._array[0],
                rangeY * Math.random() + min._array[1],
                rangeZ * Math.random() + min._array[2]
            );

            return out;
        }
    }
    Random3D.prototype = new Value()
    Random3D.prototype.constructor = Random3D;

    // Factory methods
    
    /**
     * Create a constant 1d value generator
     * @param  {number} constant
     * @return {qtek.math.Value}
     */
    Value.constant = function(constant) {
        return new ConstantValue(constant);
    }

    /**
     * Create a constant vector value(2d or 3d) generator
     * @param  {qtek.math.Vector2|qtek.math.Vector3} vector
     * @return {qtek.math.Value}
     */
    Value.vector = function(vector) {
        return new VectorValue(vector);
    }

    /**
     * Create a random 1d value generator
     * @param  {number} min
     * @param  {number} max
     * @return {qtek.math.Value}
     */
    Value.random1D = function(min, max) {
        return new Random1D(min, max);
    }

    /**
     * Create a random 2d value generator
     * @param  {qtek.math.Vector2} min
     * @param  {qtek.math.Vector2} max
     * @return {qtek.math.Value}
     */
    Value.random2D = function(min, max) {
        return new Random2D(min, max);
    }

    /**
     * Create a random 3d value generator
     * @param  {qtek.math.Vector3} min
     * @param  {qtek.math.Vector3} max
     * @return {qtek.math.Value}
     */
    Value.random3D = function(min, max) {
        return new Random3D(min, max);
    }

    return Value;
});
define('qtek/math/Vector4',['require','glmatrix'], function(require) {

    

    var glMatrix = require("glmatrix");
    var vec4 = glMatrix.vec4;

    /**
     * @constructor
     * @alias qtek.math.Vector4
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @param {number} w
     */
    var Vector4 = function(x, y, z, w) {
        
        x = x || 0;
        y = y || 0;
        z = z || 0;
        w = w || 0;

        /**
         * Storage of Vector4, read and write of x, y, z, w will change the values in _array
         * All methods also operate on the _array instead of x, y, z, w components
         * @type {Float32Array}
         */
        this._array = vec4.fromValues(x, y, z, w);

        /**
         * Dirty flag is used by the Node to determine
         * if the matrix is updated to latest
         * @type {boolean}
         */
        this._dirty = true;
    }

    Vector4.prototype = {

        constructor : Vector4,

        /**
         * @name x
         * @type {number}
         * @memberOf qtek.math.Vector4
         * @instance
         */
        get x() {
            return this._array[0];
        },

        set x(value) {
            this._array[0] = value;
            this._dirty = true;
        },

        /**
         * @name y
         * @type {number}
         * @memberOf qtek.math.Vector4
         * @instance
         */
        get y() {
            return this._array[1];
        },

        set y(value) {
            this._array[1] = value;
            this._dirty = true;
        },

        /**
         * @name z
         * @type {number}
         * @memberOf qtek.math.Vector4
         * @instance
         */
        get z() {
            return this._array[2];
        },

        set z(value) {
            this._array[2] = value;
            this._dirty = true;
        },

        /**
         * @name w
         * @type {number}
         * @memberOf qtek.math.Vector4
         * @instance
         */
        get w() {
            return this._array[3];
        },

        set w(value) {
            this._array[3] = value;
            this._dirty = true;
        },

        /**
         * Add b to self
         * @param  {qtek.math.Vector4} b
         * @return {qtek.math.Vector4}
         */
        add : function(b) {
            vec4.add( this._array, this._array, b._array );
            this._dirty = true;
            return this;
        },

        /**
         * Set x, y and z components
         * @param  {number}  x
         * @param  {number}  y
         * @param  {number}  z
         * @param  {number}  w
         * @return {qtek.math.Vector4}
         */
        set : function(x, y, z, w) {
            this._array[0] = x;
            this._array[1] = y;
            this._array[2] = z;
            this._array[3] = w;
            this._dirty = true;
            return this;
        },

        /**
         * Set x, y, z and w components from array
         * @param  {Float32Array|number[]} arr
         * @return {qtek.math.Vector4}
         */
        setArray : function(arr) {
            this._array[0] = arr[0];
            this._array[1] = arr[1];
            this._array[2] = arr[2];
            this._array[3] = arr[3];

            this._dirty = true;
            return this;
        },

        /**
         * Clone a new Vector4
         * @return {qtek.math.Vector4}
         */
        clone : function() {
            return new Vector4( this.x, this.y, this.z, this.w);
        },

        /**
         * Copy from b
         * @param  {qtek.math.Vector4} b
         * @return {qtek.math.Vector4}
         */
        copy : function(b) {
            vec4.copy( this._array, b._array );
            this._dirty = true;
            return this;
        },

        /**
         * Alias for distance
         * @param  {qtek.math.Vector4} b
         * @return {number}
         */
        dist : function(b) {
            return vec4.dist(this._array, b._array);
        },

        /**
         * Distance between self and b
         * @param  {qtek.math.Vector4} b
         * @return {number}
         */
        distance : function(b) {
            return vec4.distance(this._array, b._array);
        },

        /**
         * Alias for divide
         * @param  {qtek.math.Vector4} b
         * @return {qtek.math.Vector4}
         */
        div : function(b) {
            vec4.div(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Divide self by b
         * @param  {qtek.math.Vector4} b
         * @return {qtek.math.Vector4}
         */
        divide : function(b) {
            vec4.divide(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Dot product of self and b
         * @param  {qtek.math.Vector4} b
         * @return {number}
         */
        dot : function(b) {
            return vec4.dot(this._array, b._array);
        },

        /**
         * Alias of length
         * @return {number}
         */
        len : function() {
            return vec4.len(this._array);
        },

        /**
         * Calculate the length
         * @return {number}
         */
        length : function() {
            return vec4.length(this._array);
        },
        /**
         * Linear interpolation between a and b
         * @param  {qtek.math.Vector4} a
         * @param  {qtek.math.Vector4} b
         * @param  {number}  t
         * @return {qtek.math.Vector4}
         */
        lerp : function(a, b, t) {
            vec4.lerp(this._array, a._array, b._array, t);
            this._dirty = true;
            return this;
        },

        /**
         * Minimum of self and b
         * @param  {qtek.math.Vector4} b
         * @return {qtek.math.Vector4}
         */
        min : function(b) {
            vec2.min(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Maximum of self and b
         * @param  {qtek.math.Vector4} b
         * @return {qtek.math.Vector4}
         */
        max : function(b) {
            vec2.max(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Alias for multiply
         * @param  {qtek.math.Vector4} b
         * @return {qtek.math.Vector4}
         */
        mul : function(b) {
            vec4.mul(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Mutiply self and b
         * @param  {qtek.math.Vector4} b
         * @return {qtek.math.Vector4}
         */
        multiply : function(b) {
            vec4.multiply(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Negate self
         * @return {qtek.math.Vector4}
         */
        negate : function() {
            vec4.negate(this._array, this._array);
            this._dirty = true;
            return this;
        },

        /**
         * Normalize self
         * @return {qtek.math.Vector4}
         */
        normalize : function() {
            vec4.normalize(this._array, this._array);
            this._dirty = true;
            return this;
        },

        /**
         * Generate random x, y, z, w components with a given scale
         * @param  {number} scale
         * @return {qtek.math.Vector4}
         */
        random : function(scale) {
            vec4.random(this._array, scale);
            this._dirty = true;
            return this;
        },

        /**
         * Scale self
         * @param  {number}  scale
         * @return {qtek.math.Vector4}
         */
        scale : function(s) {
            vec4.scale(this._array, this._array, s);
            this._dirty = true;
            return this;
        },
        /**
         * Scale b and add to self
         * @param  {qtek.math.Vector4} b
         * @param  {number}  scale
         * @return {qtek.math.Vector4}
         */
        scaleAndAdd : function(b, s) {
            vec4.scaleAndAdd(this._array, this._array, b._array, s);
            this._dirty = true;
            return this;
        },

        /**
         * Alias for squaredDistance
         * @param  {qtek.math.Vector4} b
         * @return {number}
         */
        sqrDist : function(b) {
            return vec4.sqrDist(this._array, b._array);
        },

        /**
         * Squared distance between self and b
         * @param  {qtek.math.Vector4} b
         * @return {number}
         */
        squaredDistance : function(b) {
            return vec4.squaredDistance(this._array, b._array);
        },

        /**
         * Alias for squaredLength
         * @return {number}
         */
        sqrLen : function() {
            return vec4.sqrLen(this._array);
        },

        /**
         * Squared length of self
         * @return {number}
         */
        squaredLength : function() {
            return vec4.squaredLength(this._array);
        },

        /**
         * Alias for subtract
         * @param  {qtek.math.Vector4} b
         * @return {qtek.math.Vector4}
         */
        sub : function(b) {
            vec4.sub(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Subtract b from self
         * @param  {qtek.math.Vector4} b
         * @return {qtek.math.Vector4}
         */
        subtract : function(b) {
            vec4.subtract(this._array, this._array, b._array);
            this._dirty = true;
            return this;
        },

        /**
         * Transform self with a Matrix4 m
         * @param  {qtek.math.Matrix4} m
         * @return {qtek.math.Vector4}
         */
        transformMat4 : function(m) {
            vec4.transformMat4(this._array, this._array, m._array);
            this._dirty = true;
            return this;
        },

        /**
         * Transform self with a Quaternion q
         * @param  {qtek.math.Quaternion} q
         * @return {qtek.math.Vector4}
         */
        transformQuat : function(q) {
            vec4.transformQuat(this._array, this._array, q._array);
            this._dirty = true;
            return this;
        },     

        toString : function() {
            return "[" + Array.prototype.join.call(this._array, ",") + "]";
        }
    }

    // Supply methods that are not in place
    
    /**
     * @param  {qtek.math.Vector4} out
     * @param  {qtek.math.Vector4} a
     * @param  {qtek.math.Vector4} b
     * @return {qtek.math.Vector4}
     */
    Vector4.add = function(out, a, b) {
        vec4.add(out._array, a._array, b._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Vector4} out
     * @param  {number}  x
     * @param  {number}  y
     * @param  {number}  z
     * @return {qtek.math.Vector4}  
     */
    Vector4.set = function(out, x, y, z, w) {
        vec4.set(out._array, x, y, z, w);
        out._dirty = true;
    }

    /**
     * @param  {qtek.math.Vector4} out
     * @param  {qtek.math.Vector4} b
     * @return {qtek.math.Vector4}
     */
    Vector4.copy = function(out, b) {
        vec4.copy(out._array, b._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Vector4} a
     * @param  {qtek.math.Vector4} b
     * @return {number}
     */
    Vector4.dist = function(a, b) {
        return vec4.distance(a._array, b._array);
    }

    /**
     * @method
     * @param  {qtek.math.Vector4} a
     * @param  {qtek.math.Vector4} b
     * @return {number}
     */
    Vector4.distance = Vector4.dist;

    /**
     * @param  {qtek.math.Vector4} out
     * @param  {qtek.math.Vector4} a
     * @param  {qtek.math.Vector4} b
     * @return {qtek.math.Vector4}
     */
    Vector4.div = function(out, a, b) {
        vec4.divide(out._array, a._array, b._array);
        out._dirty = true;
        return out;
    }

    /**
     * @method
     * @param  {qtek.math.Vector4} out
     * @param  {qtek.math.Vector4} a
     * @param  {qtek.math.Vector4} b
     * @return {qtek.math.Vector4}
     */
    Vector4.divide = Vector4.div;

    /**
     * @param  {qtek.math.Vector4} a
     * @param  {qtek.math.Vector4} b
     * @return {number}
     */
    Vector4.dot = function(a, b) {
        return vec4.dot(a._array, b._array);
    }

    /**
     * @param  {qtek.math.Vector4} a
     * @return {number}
     */
    Vector4.len = function(b) {
        return vec4.length(b._array);
    }

    // Vector4.length = Vector4.len;

    /**
     * @param  {qtek.math.Vector4} out
     * @param  {qtek.math.Vector4} a
     * @param  {qtek.math.Vector4} b
     * @param  {number}  t
     * @return {qtek.math.Vector4}
     */
    Vector4.lerp = function(out, a, b, t) {
        vec4.lerp(out._array, a._array, b._array, t);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Vector4} out
     * @param  {qtek.math.Vector4} a
     * @param  {qtek.math.Vector4} b
     * @return {qtek.math.Vector4}
     */
    Vector4.min = function(out, a, b) {
        vec4.min(out._array, a._array, b._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Vector4} out
     * @param  {qtek.math.Vector4} a
     * @param  {qtek.math.Vector4} b
     * @return {qtek.math.Vector4}
     */
    Vector4.max = function(out, a, b) {
        vec4.max(out._array, a._array, b._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Vector4} out
     * @param  {qtek.math.Vector4} a
     * @param  {qtek.math.Vector4} b
     * @return {qtek.math.Vector4}
     */
    Vector4.mul = function(out, a, b) {
        vec4.multiply(out._array, a._array, b._array);
        out._dirty = true;
        return out;
    }

    /**
     * @method
     * @param  {qtek.math.Vector4} out
     * @param  {qtek.math.Vector4} a
     * @param  {qtek.math.Vector4} b
     * @return {qtek.math.Vector4}
     */
    Vector4.multiply = Vector4.mul;

    /**
     * @param  {qtek.math.Vector4} out
     * @param  {qtek.math.Vector4} a
     * @return {qtek.math.Vector4}
     */
    Vector4.negate = function(out, a) {
        vec4.negate(out._array, a._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Vector4} out
     * @param  {qtek.math.Vector4} a
     * @return {qtek.math.Vector4}
     */
    Vector4.normalize = function(out, a) {
        vec4.normalize(out._array, a._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Vector4} out
     * @param  {number}  scale
     * @return {qtek.math.Vector4}
     */
    Vector4.random = function(out, scale) {
        vec4.random(out._array, scale);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Vector4} out
     * @param  {qtek.math.Vector4} a
     * @param  {number}  scale
     * @return {qtek.math.Vector4}
     */
    Vector4.scale = function(out, a, scale) {
        vec4.scale(out._array, a._array, scale);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Vector4} out
     * @param  {qtek.math.Vector4} a
     * @param  {qtek.math.Vector4} b
     * @param  {number}  scale
     * @return {qtek.math.Vector4}
     */
    Vector4.scaleAndAdd = function(out, a, b, scale) {
        vec4.scale(out._array, a._array, b._array, scale);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Vector4} a
     * @param  {qtek.math.Vector4} b
     * @return {number}
     */
    Vector4.sqrDist = function(a, b) {
        return vec4.sqrDist(a._array, b._array);
    }

    /**
     * @method
     * @param  {qtek.math.Vector4} a
     * @param  {qtek.math.Vector4} b
     * @return {number}
     */
    Vector4.squaredDistance = Vector4.sqrDist;

    /**
     * @param  {qtek.math.Vector4} a
     * @return {number}
     */
    Vector4.sqrLen = function(a) {
        return vec4.sqrLen(a._array);
    }
    /**
     * @method
     * @param  {qtek.math.Vector4} a
     * @return {number}
     */
    Vector4.squaredLength = Vector4.sqrLen;

    /**
     * @param  {qtek.math.Vector4} out
     * @param  {qtek.math.Vector4} a
     * @param  {qtek.math.Vector4} b
     * @return {qtek.math.Vector4}
     */
    Vector4.sub = function(out, a, b) {
        vec4.subtract(out._array, a._array, b._array);
        out._dirty = true;
        return out;
    }
    /**
     * @method
     * @param  {qtek.math.Vector4} out
     * @param  {qtek.math.Vector4} a
     * @param  {qtek.math.Vector4} b
     * @return {qtek.math.Vector4}
     */
    Vector4.subtract = Vector4.sub;

    /**
     * @param  {qtek.math.Vector4} out
     * @param  {qtek.math.Vector4} a
     * @param  {qtek.math.Matrix4} m
     * @return {qtek.math.Vector4}
     */
    Vector4.transformMat4 = function(out, a, m) {
        vec4.transformMat4(out._array, a._array, m._array);
        out._dirty = true;
        return out;
    }

    /**
     * @param  {qtek.math.Vector4} out
     * @param  {qtek.math.Vector4} a
     * @param  {qtek.math.Quaternion} q
     * @return {qtek.math.Vector4}
     */
    Vector4.transformQuat = function(out, a, q) {
        vec4.transformQuat(out._array, a._array, m._array);
        out._dirty = true;
        return out;
    }

    return Vector4;
} );
define('qtek/particleSystem/Particle',['require','../math/Vector3','glmatrix'],function(require) {

    var Vector3 = require('../math/Vector3');
    var glMatrix = require('glmatrix');
    var vec3 = glMatrix.vec3;

    var Particle = function() {
        
        this.position = new Vector3();

        // Use euler angle to represent rotation
        this.rotation = new Vector3();

        this.velocity = null;

        this.angularVelocity = null;

        this.life = 1;

        this.age = 0;

        this.spriteSize = 1;

        this.weight = 1;

        this.emitter = null;
    }

    Particle.prototype.update = function(deltaTime) {
        if (this.velocity) {
            vec3.scaleAndAdd(this.position._array, this.position._array, this.velocity._array, deltaTime);
        }
        if (this.angularVelocity) {
            vec3.scaleAndAdd(this.rotation._array, this.rotation._array, this.angularVelocity._array, deltaTime);
        }
    }

    return Particle;
});
define('qtek/particleSystem/Emitter',['require','../core/Base','../math/Vector3','./Particle','../math/Value','glmatrix'],function(require) {

    var Base = require('../core/Base');
    var Vector3 = require('../math/Vector3');
    var Particle = require('./Particle');
    var Value = require('../math/Value');
    var glMatrix = require('glmatrix');
    var vec3 =  glMatrix.vec3;

    var Emitter = Base.derive({

        max : 1000,
        amount : 20,

        // Init status for each particle
        life : null,
        position : null,
        rotation : null,
        velocity : null,
        angularVelocity : null,
        spriteSize : null,
        weight : null,

        _particlePool : null
        
    }, function() {
        
        this._particlePool = [];

        // TODO Reduce heap memory
        for (var i = 0; i < this.max; i++) {
            var particle = new Particle();
            particle.emitter = this;
            this._particlePool.push(particle);

            if (this.velocity) {
                particle.velocity = new Vector3();
            }
            if (this.angularVelocity) {
                particle.angularVelocity = new Vector3();
            }
        }

    }, {

        emit : function(out) {
            var amount = Math.min(this._particlePool.length, this.amount);

            var particle;
            for (var i = 0; i < amount; i++) {
                particle = this._particlePool.pop();
                // Initialize particle status
                if (this.position) {
                    this.position.get(particle.position);
                }
                if (this.rotation) {
                    this.rotation.get(particle.rotation);
                }
                if (this.velocity) {
                    this.velocity.get(particle.velocity);
                }
                if (this.angularVelocity) {
                    this.angularVelocity.get(particle.angularVelocity);
                }
                if (this.life) {
                    particle.life = this.life.get();
                }
                if (this.spriteSize) {
                    particle.spriteSize = this.spriteSize.get();
                }
                if (this.weight) {
                    particle.weight = this.weight.get();
                }
                particle.age = 0;

                out.push(particle);
            }
        },

        kill : function(particle) {
            this._particlePool.push(particle);
        }
    });
    
    Emitter.constant = Value.constant;
    Emitter.vector = Value.vector;
    Emitter.random1D = Value.random1D;
    Emitter.random2D = Value.random2D;
    Emitter.random3D = Value.random3D;

    return Emitter;
});
define('qtek/particleSystem/ForceField',['require','../core/Base','../math/Vector3','glmatrix'],function(require) {

    var Base = require('../core/Base');
    var Vector3 = require('../math/Vector3');
    var glMatrix = require('glmatrix');
    var vec3 =  glMatrix.vec3;

    var ForceField = Base.derive(function() {
        return {
            force : new Vector3()
        }
    }, {
        applyTo : function(velocity, position, weight, deltaTime) {
            if (weight > 0) {
                vec3.scaleAndAdd(velocity._array, velocity._array, this.force._array, deltaTime / weight);
            }
        }
    });

    return ForceField;
});
define('qtek/particleSystem/particle.essl',[],function () { return '@export buildin.particle.vertex\n\nuniform mat4 worldView : WORLDVIEW;\nuniform mat4 projection : PROJECTION;\n\nattribute vec3 position : POSITION;\nattribute vec3 normal : NORMAL;\n\n#ifdef UV_ANIMATION\nattribute vec2 texcoord0 : TEXCOORD_0;\nattribute vec2 texcoord1 : TEXCOORD_1;\n\nvarying vec2 v_Uv0;\nvarying vec2 v_Uv1;\n#endif\n\nvarying float v_Age;\n\nvoid main() {\n    v_Age = normal.x;\n    float rotation = normal.y;\n\n    vec4 worldViewPosition = worldView * vec4(position, 1.0);\n    gl_Position = projection * worldViewPosition;\n    float w = gl_Position.w;\n    // TODO\n    gl_PointSize = normal.z * projection[0].x / w;\n\n    #ifdef UV_ANIMATION\n        v_Uv0 = texcoord0;\n        v_Uv1 = texcoord1;\n    #endif\n}\n\n@end\n\n@export buildin.particle.fragment\n\nuniform sampler2D sprite;\nuniform sampler2D gradient;\nuniform vec3 color : [1.0, 1.0, 1.0];\nuniform float alpha : 1.0;\n\nvarying float v_Age;\n\n#ifdef UV_ANIMATION\nvarying vec2 v_Uv0;\nvarying vec2 v_Uv1;\n#endif\n\nvoid main() {\n    vec4 color = vec4(color, alpha);\n    #ifdef SPRITE_ENABLED\n        #ifdef UV_ANIMATION\n            color *= texture2D(sprite, mix(v_Uv0, v_Uv1, gl_PointCoord));\n        #else\n            color *= texture2D(sprite, gl_PointCoord);\n        #endif\n    #endif\n    #ifdef GRADIENT_ENABLED\n        color *= texture2D(gradient, vec2(v_Age, 0.5));\n    #endif\n\n    gl_FragColor = color;\n}\n\n@end';});

define('qtek/particleSystem/ParticleSystem',['require','../Renderable','../math/Vector3','../core/glenum','../StaticGeometry','../Material','../Shader','glmatrix','./particle.essl'],function(require) {

    

    var Renderable = require('../Renderable');
    var Vector3 = require('../math/Vector3');
    var glenum = require("../core/glenum");

    var StaticGeometry = require('../StaticGeometry');
    var Material = require('../Material');
    var Shader = require('../Shader');

    var glMatrix = require('glmatrix');
    var vec3 = glMatrix.vec3;

    Shader['import'](require('./particle.essl'));

    // TODO shader with uv animation
    var particleShader = new Shader({
        vertex : Shader.source('buildin.particle.vertex'),
        fragment : Shader.source('buildin.particle.fragment')
    });
    particleShader.enableTexture('sprite');

    var ParticleSystem = Renderable.derive({
        
        loop : true,

        oneshot : false,

        duration : 1,

        // UV Animation
        spriteAnimationTileX : 1,
        spriteAnimationTileY : 1,
        spriteAnimationRepeat : 0,

        mode : Renderable.POINTS,

        _elapsedTime : 0,

        _emitting : true

    }, function(){

        this.geometry = new StaticGeometry({
            hint : glenum.DYNAMIC_DRAW
        });
        
        if (!this.material) {
            this.material = new Material({
                shader : particleShader,
                transparent : true,
                depthMask : false
            });
        }

        this._drawCache = {};
        this._particles = [];
        this._fields = [];
        this._emitters = [];
    }, {

        culling : false,

        frustumCulling : false,

        castShadow : false,
        receiveShadow : false,

        addEmitter : function(emitter) {
            this._emitters.push(emitter);
        },

        removeEmitter : function(emitter) {
            this._emitters.splice(this._emitters.indexOf(emitter), 1);
        },

        addField : function(field) {
            this._fields.push(field);
        },

        removeField : function(field) {
            this._fields.splice(this._fields.indexOf(field), 1);
        },

        reset: function() {
            // Put all the particles back
            for (var i = 0; i < this._particles.length; i++) {
                var p = this._particles[i];
                p.emitter.kill(p);
            }
            this._particles.length = 0;
            this._elapsedTime = 0;
            this._emitting = true;
        },

        updateParticles : function(deltaTime) {

            // MS => Seconds
            deltaTime /= 1000;
            this._elapsedTime += deltaTime;

            var particles = this._particles;

            if (this._emitting) {
                for (var i = 0; i < this._emitters.length; i++) {
                    this._emitters[i].emit(particles);
                }
                if (this.oneshot) {
                    this._emitting = false;
                }
            }

            // Aging
            var len = particles.length;
            for (var i = 0; i < len;) {
                var p = particles[i];
                p.age += deltaTime;
                if (p.age >= p.life) {
                    p.emitter.kill(p);
                    particles[i] = particles[len-1];
                    particles.pop();
                    len--;
                } else {
                    i++;
                }
            }

            for (var i = 0; i < len; i++) {
                // Update
                var p = particles[i];
                if (this._fields.length > 0) {
                    for (var j = 0; j < this._fields.length; j++) {
                        this._fields[j].applyTo(p.velocity, p.position, p.weight, deltaTime);
                    }
                }
                p.update(deltaTime);
            }
        },

        _updateVertices : function() {
            var particles = this._particles;
            var geometry = this.geometry;
            // If has uv animation
            var animTileX = this.spriteAnimationTileX;
            var animTileY = this.spriteAnimationTileY;
            var animRepeat = this.spriteAnimationRepeat;
            var nUvAnimFrame = animTileY * animTileX * animRepeat;
            var hasUvAnimation = nUvAnimFrame > 1;
            var positions = geometry.attributes.position.value;
            // Put particle status in normal
            var normals = geometry.attributes.normal.value;
            var uvs = geometry.attributes.texcoord0.value;
            var uvs2 = geometry.attributes.texcoord1.value;

            var len = this._particles.length;
            if (!positions || positions.length !== len * 3) {
                // TODO Optimize
                positions = geometry.attributes.position.value = new Float32Array(len * 3);
                normals = geometry.attributes.normal.value = new Float32Array(len * 3);
                if (hasUvAnimation) {
                    uvs = geometry.attributes.texcoord0.value = new Float32Array(len * 2);
                    uvs2 = geometry.attributes.texcoord1.value = new Float32Array(len * 2);
                }
            }

            var invAnimTileX = 1 / animTileX;
            for (var i = 0; i < len; i++) {
                var particle = this._particles[i];
                var offset = i * 3;
                for (var j = 0; j < 3; j++) {
                    positions[offset + j] = particle.position._array[j];
                    normals[offset] = particle.age / particle.life;
                    normals[offset + 1] = particle.rotation;
                    normals[offset + 2] = particle.spriteSize;
                }
                var offset2 = i * 2;
                if (hasUvAnimation) {
                    // TODO 
                    var p = particle.age / particle.life;
                    var stage = Math.round(p * (nUvAnimFrame - 1)) * animRepeat;
                    var v = Math.floor(stage * invAnimTileX);
                    var u = stage - v * animTileX;
                    uvs[offset2] = u / animTileX;
                    uvs[offset2 + 1] = 1 - v / animTileY;
                    uvs2[offset2] = (u + 1) / animTileX;
                    uvs2[offset2 + 1] = 1 - (v + 1) / animTileY;
                }
            }

            geometry.dirty();
        },

        render : function(_gl) {
            this._updateVertices();
            return Renderable.prototype.render.call(this, _gl);
        },

        isFinished : function() {
            return this._elapsedTime > this.duration && !this.loop;
        },

        dispose : function(_gl) {
            // Put all the particles back
            for (var i = 0; i < this._particles.length; i++) {
                var p = this._particles[i];
                p.emitter.kill(p);
            }
            this.geometry.dispose(_gl);
            // TODO Dispose texture, shader ?
        },

        clone : function() {
            var particleSystem = new ParticleSystem({
                material : this.material
            });
            particleSystem.loop = this.loop;
            particleSystem.duration = this.duration;
            particleSystem.oneshot = this.oneshot;
            particleSystem.spriteAnimationRepeat = this.spriteAnimationRepeat;
            particleSystem.spriteAnimationTileY = this.spriteAnimationTileY;
            particleSystem.spriteAnimationTileX = this.spriteAnimationTileX;

            particleSystem.position.copy(this.position);
            particleSystem.rotation.copy(this.rotation);
            particleSystem.scale.copy(this.scale);

            for (var i = 0; i < this._children.length; i++) {
                particleSystem.add(this._children[i].clone());
            }
            return particleSystem;
        }
    });

    

    return ParticleSystem;
});
define('qtek/picking/color.essl',[],function () { return '@export buildin.picking.color.vertex\n\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\n\nattribute vec3 position : POSITION;\n\n#ifdef SKINNING\nattribute vec3 weight : WEIGHT;\nattribute vec4 joint : JOINT;\n\nuniform mat4 skinMatrix[JOINT_NUMBER] : SKIN_MATRIX;\n#endif\n\nvoid main(){\n\n    vec3 skinnedPosition = position;\n\n    #ifdef SKINNING\n        \n        @import buildin.chunk.skin_matrix\n\n        skinnedPosition = (skinMatrixWS * vec4(position, 1.0)).xyz;\n    #endif\n\n    gl_Position = worldViewProjection * vec4(skinnedPosition, 1.0);\n}\n\n@end\n\n@end\n@export buildin.picking.color.fragment\n\nuniform vec4 color : [1.0, 1.0, 1.0, 1.0];\n\nvoid main(){\n    gl_FragColor = color;\n}\n\n@end';});

define('qtek/picking/Pixel',['require','../core/Base','../FrameBuffer','../texture/Texture2D','../Shader','../Material','./color.essl'],function (require) {

    var Base = require('../core/Base');
    var FrameBuffer = require('../FrameBuffer');
    var Texture2D = require('../texture/Texture2D');
    var Shader = require('../Shader');
    var Material = require('../Material');

    Shader.import(require('./color.essl'));    

    var PixelPicking = Base.derive(function() {
        return {
            renderer : null,

            downSampleRatio : 1,
            width : 100,
            height : 100,

            lookupOffset : 1,

            _frameBuffer : null,
            _texture : null,
            _shader : null,

            _idMaterials : [],
            _lookupTable : [],

            _meshMaterials : [],

            _idOffset : 0
        }
    }, function() {
        this.init();
    }, {
        init : function() {
            this._texture = new Texture2D({
                width : this.width * this.downSampleRatio,
                height : this.height * this.downSampleRatio
            });
            this._frameBuffer = new FrameBuffer();

            this._shader = new Shader({
                vertex : Shader.source('buildin.picking.color.vertex'),
                fragment : Shader.source('buildin.picking.color.fragment')
            });
        },
        setPrecision : function(ratio) {
            this._texture.width = this.width * ratio;
            this._texture.height = this.height * ratio;
            this.downSampleRatio = ratio;
        },
        resize : function(width, height) {
            this._texture.width = width * this.downSampleRatio;
            this._texture.height = height * this.downSampleRatio;
            this.width = width;
            this.height = height;
        },
        update : function(scene, camera) {
            var renderer = this.renderer;
            this._frameBuffer.attach(renderer.gl, this._texture);
            this._frameBuffer.bind(renderer);
            this._idOffset = this.lookupOffset;
            this._setMaterial(scene);
            renderer.render(scene, camera);
            this._restoreMaterial();
            this._frameBuffer.unbind(renderer);
        },

        _setMaterial : function(root) {
            for (var i =0; i < root._children.length; i++) {
                var child = root._children[i];
                if (child.geometry && child.material && child.material.shader) {
                    var id = this._idOffset++;
                    var idx = id - this.lookupOffset;
                    var material = this._idMaterials[idx];
                    if (!material) {
                        material = new Material({
                            shader : this._shader
                        });
                        var color = packID(id);
                        color[0] /= 255;
                        color[1] /= 255;
                        color[2] /= 255;
                        color[3] = 1.0;
                        material.set('color', color);
                        this._idMaterials[idx] = material;
                    }
                    this._meshMaterials[idx] = child.material;
                    this._lookupTable[idx] = child;
                    child.material = material;
                }
                if (child._children.length) {
                    this._setMaterial(child);
                }
            }
        },

        pick : function(x, y) {
            var renderer = this.renderer;

            var ratio = this.downSampleRatio;
            var width = this._texture.width;
            var height = this._texture.height;
            x = Math.ceil(ratio * x);
            y = Math.ceil(ratio * (this.height - y));

            this._frameBuffer.bind(renderer);
            var pixel = new Uint8Array(4);
            var _gl = renderer.gl;
            // TODO out of bounds ?
            // preserveDrawingBuffer ?
            _gl.readPixels(x, y, 1, 1, _gl.RGBA, _gl.UNSIGNED_BYTE, pixel);
            this._frameBuffer.unbind(renderer);
            // Skip interpolated pixel because of anti alias
            if (pixel[3] === 255) {
                var id = unpackID(pixel[0], pixel[1], pixel[2]);
                if (id) {
                    var el = this._lookupTable[id - this.lookupOffset];
                    return el;
                }
            }
        },

        _restoreMaterial : function() {
            for (var i = 0; i < this._lookupTable.length; i++) {
                this._lookupTable[i].material = this._meshMaterials[i];
            }
        },

        dispose : function(_gl) {

        }
    });

    function packID(id){
        var r = id >> 16;
        var g = (id - (r << 8)) >> 8;
        var b = id - (r << 16) - (g<<8);
        return [r, g, b];
    }

    function unpackID(r, g, b){
        return (r << 16) + (g<<8) + b;
    }

    return PixelPicking;
});
define('qtek/plugin/FirstPersonControl',['require','../core/Base','../math/Vector3','../math/Matrix4','../math/Quaternion'],function(require) {

    var Base = require("../core/Base");
    var Vector3 = require("../math/Vector3");
    var Matrix4 = require("../math/Matrix4");
    var Quaternion = require("../math/Quaternion");

    var FirstPersonControl = Base.derive(function() {
        return {
            target : null,
            domElement : null,

            sensitivity : 1,
            speed : 0.4,

            up : new Vector3(0, 1, 0),

            verticalMoveLock : false,

            _moveForward : false,
            _moveBackward : false,
            _moveLeft : false,
            _moveRight : false,

            _offsetPitch : 0,
            _offsetRoll : 0
        }
    }, function() {
        if (this.domElement) {
            this.enable();
        }
    }, {
        enable : function() {
            // Use pointer lock
            // http://www.html5rocks.com/en/tutorials/pointerlock/intro/
            var el = this.domElement;

            //Must request pointer lock after click event, can't not do it directly
            //Why ? ?
            el.addEventListener("click", this._requestPointerLock);

            document.addEventListener("pointerlockchange", bindOnce(this._lockChange, this), false);
            document.addEventListener("mozpointerlockchange", bindOnce(this._lockChange, this), false);
            document.addEventListener("webkitpointerlockchange", bindOnce(this._lockChange, this), false);

            document.addEventListener("keydown", bindOnce(this._keyDown, this), false);
            document.addEventListener("keyup", bindOnce(this._keyUp, this), false);
        },

        disable : function() {

            this.target.off('beforeupdate', this._beforeUpdateCamera);

            var el = this.domElement;

            el.exitPointerLock = el.exitPointerLock ||
                                    el.mozExitPointerLock ||
                                    el.webkitExitPointerLock

            if (el.exitPointerLock) {
                el.exitPointerLock();
            }

            this.domElement.removeEventListener("click", this._requestPointerLock);

            document.removeEventListener("pointerlockchange", bindOnce(this._lockChange, this));
            document.removeEventListener("mozpointerlockchange", bindOnce(this._lockChange, this));
            document.removeEventListener("webkitpointerlockchange", bindOnce(this._lockChange, this));
            
            document.removeEventListener("keydown", bindOnce(this._keyDown, this));
            document.removeEventListener("keyup", bindOnce(this._keyUp, this));
        },

        _requestPointerLock : function() {
            var el = this;
            el.requestPointerLock = el.requestPointerLock ||
                                    el.mozRequestPointerLock ||
                                    el.webkitRequestPointerLock;

            el.requestPointerLock();
        },

        update : (function() {

            var rotateQuat = new Quaternion();
            
            return function(deltaTime) {
                
                var target = this.target;

                var position = this.target.position;
                var xAxis = target.localTransform.right.normalize();
                var zAxis = target.localTransform.forward.normalize();

                if (this.verticalMoveLock) {
                    zAxis.y = 0;
                }

                if (this._moveForward) {
                    // Opposite direction of z
                    position.scaleAndAdd(zAxis, -this.speed);
                }
                if (this._moveBackward) {
                    position.scaleAndAdd(zAxis, this.speed);
                }
                if (this._moveLeft) {
                    position.scaleAndAdd(xAxis, -this.speed/2);
                }
                if (this._moveRight) {
                    position.scaleAndAdd(xAxis, this.speed/2);
                }


                target.rotateAround(target.position, this.up, -this._offsetPitch * Math.PI / 180);
                var xAxis = target.localTransform.right;
                target.rotateAround(target.position, xAxis, -this._offsetRoll * Math.PI / 180);

                this._offsetRoll = this._offsetPitch = 0;
            }

        })(),

        _lockChange : function() {
            if (document.pointerlockElement === this.domElement ||
                document.mozPointerlockElement === this.domElement ||
                document.webkitPointerLockElement === this.domElement) {

                document.addEventListener('mousemove', bindOnce(this._mouseMove, this), false);
            }else{
                document.removeEventListener('mousemove', bindOnce(this._mouseMove, this));
            }
        },

        _mouseMove : function(e) {
            var dx = e.movementX || 
                    e.mozMovementX ||
                    e.webkitMovementX || 0;
            var dy = e.movementY ||
                    e.mozMovementY ||
                    e.webkitMovementY || 0;

            this._offsetPitch += dx * this.sensitivity / 10;
            this._offsetRoll += dy * this.sensitivity / 10;
            
        },

        _keyDown : function(e) {
            switch(e.keyCode) {
                case 87: //w
                case 37: //up arrow
                    this._moveForward = true;
                    break;
                case 83: //s
                case 40: //down arrow
                    this._moveBackward = true;
                    break;
                case 65: //a
                case 37: //left arrow
                    this._moveLeft = true;
                    break;
                case 68: //d
                case 39: //right arrow
                    this._moveRight = true;
                    break; 
            }
        },

        _keyUp : function(e) {
            this._moveForward = false;
            this._moveBackward = false;
            this._moveLeft = false;
            this._moveRight = false;
        }
    })

    function bindOnce(func, context) {
        if (!func.__bindfuc__) {
            func.__bindfuc__ = function() {
                return func.apply(context, arguments); 
            }
        }
        return func.__bindfuc__;
    }

    return FirstPersonControl;
});
define('qtek/plugin/InfinitePlane',['require','../Mesh','../DynamicGeometry','../math/Plane','../math/Vector3','../math/Matrix4','../math/Ray','../camera/Perspective','glmatrix'],function(require) {
    
    var Mesh = require('../Mesh');
    var DynamicGeometry = require('../DynamicGeometry');
    var Plane = require('../math/Plane');
    var Vector3 = require('../math/Vector3');
    var Matrix4 = require('../math/Matrix4');
    var Ray = require('../math/Ray');

    var PerspectiveCamera = require('../camera/Perspective');

    var glMatrix = require('glmatrix');
    var mat4 = glMatrix.mat4;
    var vec3 = glMatrix.vec3;
    var vec4 = glMatrix.vec4;

    var uvs = [[0, 0], [0, 1], [1, 1], [1, 0]];
    var tris = [0, 1, 2, 2, 3, 0];

    var InfinitePlane = Mesh.derive({
        
        camera : null,

        plane : null,

        gridSize : 1,

        maxGrid : 0,

        // TODO
        frustumCulling : false

    }, function() {
        if (!this.geometry) {
            this.geometry = new DynamicGeometry();
        }
        if (!this.plane) {
            this.plane = new Plane();
        }
    }, {

        updateGeometry : function() {

            var coords = this._unProjectGrid();
            if (!coords) {
                return;
            }
            var positions = this.geometry.attributes.position.value;
            var normals = this.geometry.attributes.normal.value;
            var texcoords = this.geometry.attributes.texcoord0.value;
            var faces = this.geometry.faces;
            var nVertices = 0;
            var normal = vec3.clone(this.plane.normal._array);

            // if (this.gridSize > 0) {
                // TODO

            // } else {
            for (var i = 0; i < 6; i++) {
                var idx = tris[i];
                positions[nVertices] = coords[idx]._array;
                normals[nVertices] = normal;
                texcoords[nVertices] = uvs[idx];
                nVertices++;
            }
            faces[0] = [0, 1, 2];
            faces[1] = [3, 4, 5];
            this.geometry.dirty();
            // }
        },

        // http://fileadmin.cs.lth.se/graphics/theses/projects/projgrid/
        _unProjectGrid : (function() {
            
            var planeViewSpace = new Plane();
            var lines = [
                0, 1, 0, 2, 1, 3, 2, 3,
                4, 5, 4, 6, 5, 7, 6, 7,
                0, 4, 1, 5, 2, 6, 3, 7
            ];

            var start = new Vector3();
            var end = new Vector3();

            var points = [];

            // 1----2
            // |    |
            // 0----3
            var coords = [];
            for (var i = 0; i < 4; i++) {
                coords[i] = new Vector3(0, 0);
            }

            var ray = new Ray();

            return function() {
                planeViewSpace.copy(this.plane);
                planeViewSpace.applyTransform(this.camera.viewMatrix);

                var frustumVertices = this.camera.frustum.vertices;

                var nPoints = 0;
                // Intersect with lines of frustum
                for (var i = 0; i < 12; i++) {
                    start._array = frustumVertices[lines[i * 2]];
                    end._array = frustumVertices[lines[i * 2 + 1]];

                    var point = planeViewSpace.intersectLine(start, end, points[nPoints]);
                    if (point) {
                        if (!points[nPoints]) {
                            points[nPoints] = point;
                        }
                        nPoints++;
                    }
                }
                if (nPoints == 0) {
                    return;
                }
                for (var i = 0; i < nPoints; i++) {
                    points[i].applyProjection(this.camera.projectionMatrix);
                }
                var minX = points[0]._array[0];
                var minY = points[0]._array[1];
                var maxX = points[0]._array[0];
                var maxY = points[0]._array[1];
                for (var i = 1; i < nPoints; i++) {
                    maxX = Math.max(maxX, points[i]._array[0]);
                    maxY = Math.max(maxY, points[i]._array[1]);
                    minX = Math.min(minX, points[i]._array[0]);
                    minY = Math.min(minY, points[i]._array[1]);
                }
                if (minX == maxX || minY == maxY) {
                    return;
                }
                coords[0]._array[0] = minX;
                coords[0]._array[1] = minY;
                coords[1]._array[0] = minX;
                coords[1]._array[1] = maxY;
                coords[2]._array[0] = maxX;
                coords[2]._array[1] = maxY;
                coords[3]._array[0] = maxX;
                coords[3]._array[1] = minY;

                for (var i = 0; i < 4; i++) {
                    this.camera.castRay(coords[i], ray);
                    ray.intersectPlane(this.plane, coords[i])
                }

                return coords;
            };
        })()
    });

    return InfinitePlane;
});
define('qtek/plugin/OrbitControl',['require','../core/Base','../math/Vector3','../math/Matrix4','../math/Quaternion'],function(require) {

    var Base = require("../core/Base");
    var Vector3 = require("../math/Vector3");
    var Matrix4 = require("../math/Matrix4");
    var Quaternion = require("../math/Quaternion");
    
    var tmpMatrix = new Matrix4();

    var OrbitControl = Base.derive(function() {
        return {
            
            target : null,
            domElement : null,

            sensitivity : 1,

            origin : new Vector3(),

            up : new Vector3(0, 1, 0),

            minDistance : 0,
            maxDistance : Infinity,

            minPolarAngle : 0, // [0, Math.PI/2]
            maxPolarAngle : Math.PI, // [Math.PI/2, Math.PI]

            // Rotate around origin
            _offsetPitch : 0,
            _offsetRoll : 0,

            // Pan the origin
            _panX : 0,
            _panY : 0,

            // Offset of mouse move
            _offsetX : 0,
            _offsetY : 0,

            // Zoom with mouse wheel
            _forward : 0,

            _op : -1  //0 : ROTATE, 1 : PAN
        }
    }, function() {
        if (this.domElement) {
            this.enable();
        }
    }, {

        enable : function() {
            this.domElement.addEventListener("mousedown", bindOnce(this._mouseDown, this), false);
            this.domElement.addEventListener("mousewheel", bindOnce(this._mouseWheel, this), false);
            this.domElement.addEventListener("DOMMouseScroll", bindOnce(this._mouseWheel, this), false);
        },

        disable : function() {
            this.domElement.removeEventListener("mousedown", bindOnce(this._mouseDown, this));
            this.domElement.removeEventListener("mousewheel", bindOnce(this._mouseWheel, this));
            this.domElement.removeEventListener("DOMMouseScroll", bindOnce(this._mouseWheel, this));
            this._mouseUp();
        },

        _mouseWheel : function(e) {
            e.preventDefault();
            var delta = e.wheelDelta // Webkit 
                        || -e.detail; // Firefox

            this._forward += delta * this.sensitivity;
        },

        _mouseDown : function(e) {
            document.addEventListener("mousemove", bindOnce(this._mouseMove, this), false);
            document.addEventListener("mouseup", bindOnce(this._mouseUp, this), false);
            document.addEventListener("mouseout", bindOnce(this._mouseOut, this), false);

            this._offsetX = e.pageX;
            this._offsetY = e.pageY;

            // Rotate
            if (e.button === 0) {
                this._op = 0;
            } else if (e.button === 1) {
                this._op = 1;
            }
        },

        _mouseMove : function(e) {
            var dx = e.pageX - this._offsetX;
            var dy = e.pageY - this._offsetY;

            if (this._op === 0) {
                this._offsetPitch += dx * this.sensitivity / 100;
                this._offsetRoll += dy * this.sensitivity / 100;
            } else if (this._op === 1) {
                var len = this.origin.distance(this.target.position);
                if (this.target.fov) {
                    var divider = Math.sin(this.target.fov * Math.PI / 360) / 200;
                } else {
                    var divider = 1 / 200;
                }
                this._panX += dx * this.sensitivity * len * divider;
                this._panY += dy * this.sensitivity * len * divider;
            }

            this._offsetX = e.pageX;
            this._offsetY = e.pageY;
        },

        _mouseUp : function() {

            document.removeEventListener("mousemove", bindOnce(this._mouseMove, this));
            document.removeEventListener("mouseup", bindOnce(this._mouseUp, this));
            document.removeEventListener("mouseout", bindOnce(this._mouseOut, this));

            this._op = -1;
        },

        _mouseOut : function() {
            this._mouseUp();
        },

        update : function(delataTime) {
            var target = this.target;
            var zAxis = target.localTransform.forward.normalize();
            var yAxis = target.localTransform.up.normalize();
            if (this._op === 0) {
                // Rotate
                target.rotateAround(this.origin, this.up, -this._offsetPitch);
                tmpMatrix.copy(target.localTransform);
                var xAxis = target.localTransform.right;
                target.rotateAround(this.origin, xAxis, -this._offsetRoll);
                var zAxis = target.localTransform.forward.normalize();
                var yAxis = target.localTransform.up.normalize();
                var phi = Math.acos(this.up.dot(zAxis));
                var isUp = this.up.dot(yAxis) >= 0;
                if (
                    !(isUp && phi >= this.minPolarAngle && phi <= this.maxPolarAngle)
                ) {
                    // Rool back
                    target.localTransform.copy(tmpMatrix);
                    target.decomposeLocalTransform();
                }
                this._offsetRoll = this._offsetPitch = 0;
            } else if (this._op === 1) {
                // Pan
                var xAxis = target.localTransform.right.normalize().scale(-this._panX);
                var yAxis = target.localTransform.up.normalize().scale(this._panY);
                target.position.add(xAxis).add(yAxis);
                this.origin.add(xAxis).add(yAxis);
                this._panX = this._panY = 0;
            } 
            if (this._forward !== 0) {
                // Zoom
                var distance = target.position.distance(this.origin);
                var nextDistance = distance + this._forward * distance / 5000;
                if (nextDistance < this.maxDistance && nextDistance > this.minDistance) {
                    target.position.scaleAndAdd(zAxis, this._forward * distance / 5000);
                }
                this._forward = 0;
            }

        }
    });

    function bindOnce(func, context) {
        if (!func.__bindfuc__) {
            func.__bindfuc__ = function() {
                return func.apply(context, arguments); 
            }
        }
        return func.__bindfuc__;
    }

    return OrbitControl;
} );
define('qtek/plugin/Skybox',['require','../Mesh','../geometry/Cube','../Shader','../Material','../shader/library'],function(require) {

    var Mesh = require('../Mesh');
    var CubeGeometry = require('../geometry/Cube');
    var Shader = require('../Shader');
    var Material = require('../Material');
    var shaderLibrary = require('../shader/library');

    var skyboxShader;

    var Skybox = Mesh.derive(function() {

        if (!skyboxShader) {
            skyboxShader = new Shader({
                vertex : Shader.source("buildin.skybox.vertex"), 
                fragment : Shader.source("buildin.skybox.fragment")
            });
        }
        var material = new Material({
            shader : skyboxShader,
            depthMask : false
        });
        
        return {
            scene : null,

            geometry : new CubeGeometry(),
            material : material,
            culling : false,

            _beforeRenderScene : function(renderer, scene, camera) {
                this.position.copy(camera.getWorldPosition());
                this.update();
                renderer.renderQueue([this], camera);
            }
        }
    }, function() {
        var scene = this.scene;
        if (scene) {
            this.attachScene(scene);
        }
    }, {
        attachScene : function(scene) {
            if (this.scene) {
                this.detachScene();
            }
            this.scene = scene;
            scene.on("beforerender", this._beforeRenderScene, this);
        },
        
        detachScene : function() {
            if (this.scene) {
                this.scene.off("beforerender", this._beforeRenderScene, this);  
            }
            this.scene = null;
        },

        dispose : function() {
            this.detachScene();
        }
    });

    return Skybox;
});
define('qtek/plugin/Skydome',['require','../Mesh','../geometry/Sphere','../Shader','../Material','../shader/library'],function(require) {

    var Mesh = require('../Mesh');
    var SphereGeometry = require('../geometry/Sphere');
    var Shader = require('../Shader');
    var Material = require('../Material');
    var shaderLibrary = require('../shader/library');

    var skydomeShader;

    var Skydome = Mesh.derive(function() {

        if (!skydomeShader) {
            skydomeShader = new Shader({
                vertex : Shader.source("buildin.basic.vertex"),
                fragment : Shader.source("buildin.basic.fragment")
            })
            skydomeShader.enableTexture("diffuseMap");
        }

        var material = new Material({
            shader : skydomeShader,
            depthMask : false
        });
        
        return {
            scene : null,

            geometry : new SphereGeometry({
                widthSegments : 30,
                heightSegments : 30,
                // thetaLength : Math.PI / 2
            }),
            material : material,
            culling : false,

            _beforeRenderScene : function(renderer, scene, camera) {
                this.position.copy(camera.getWorldPosition());
                this.update();
                renderer.renderQueue([this], camera);
            }
        }
    }, function() {
        var scene = this.scene;
        if (scene) {
            this.attachScene(scene);
        }
    }, {
        attachScene : function(scene) {
            if (this.scene) {
                this.detachScene();
            }
            this.scene = scene;
            scene.on("beforerender", this._beforeRenderScene, this);
        },
        
        detachScene : function() {
            if (this.scene) {
                this.scene.off("beforerender", this._beforeRenderScene, this);  
            }
            this.scene = null;
        },

        dispose : function() {
            this.detachScene();
        }
    });

    return Skydome;
});
define('qtek/prePass/EnvironmentMap',['require','../core/Base','../math/Vector3','../camera/Perspective','../core/glenum','../FrameBuffer','../texture/TextureCube'],function (require) {

    var Base = require('../core/Base');
    var Vector3 = require('../math/Vector3');
    var PerspectiveCamera = require('../camera/Perspective');
    var glenum = require("../core/glenum");
    var FrameBuffer = require("../FrameBuffer");
    var TextureCube = require("../texture/TextureCube");

    var targets = ['px', 'nx', 'py', 'ny', 'pz', 'nz'];
    var targetMap = {
        'px' : glenum.TEXTURE_CUBE_MAP_POSITIVE_X,
        'py' : glenum.TEXTURE_CUBE_MAP_POSITIVE_Y,
        'pz' : glenum.TEXTURE_CUBE_MAP_POSITIVE_Z,
        'nx' : glenum.TEXTURE_CUBE_MAP_NEGATIVE_X,
        'ny' : glenum.TEXTURE_CUBE_MAP_NEGATIVE_Y,
        'nz' : glenum.TEXTURE_CUBE_MAP_NEGATIVE_Z,
    }

    var EnvironmentMapPass = Base.derive(function() {
        var ret = {
            position : new Vector3(),
            far : 1000,
            near : 0.1,
            texture : null,
            frameBuffer : new FrameBuffer()
        }
        ret._cameras = {
            'px' : new PerspectiveCamera({fov : 90}),
            'nx' : new PerspectiveCamera({fov : 90}),
            'py' : new PerspectiveCamera({fov : 90}),
            'ny' : new PerspectiveCamera({fov : 90}),
            'pz' : new PerspectiveCamera({fov : 90}),
            'nz' : new PerspectiveCamera({fov : 90}),
        }
        ret._cameras.px.lookAt(Vector3.POSITIVE_X, Vector3.NEGATIVE_Y);
        ret._cameras.nx.lookAt(Vector3.NEGATIVE_X, Vector3.NEGATIVE_Y);
        ret._cameras.py.lookAt(Vector3.POSITIVE_Y, Vector3.POSITIVE_Z);
        ret._cameras.ny.lookAt(Vector3.NEGATIVE_Y, Vector3.NEGATIVE_Z);
        ret._cameras.pz.lookAt(Vector3.POSITIVE_Z, Vector3.NEGATIVE_Y);
        ret._cameras.nz.lookAt(Vector3.NEGATIVE_Z, Vector3.NEGATIVE_Y);

        return ret;
    }, {
        render : function(renderer, scene, notUpdateScene) {
            var _gl = renderer.gl;
            if (!notUpdateScene) {
                scene.update(true);
            }
            // Tweak fov
            // http://the-witness.net/news/2012/02/seamless-cube-map-filtering/
            var n = this.texture.width;
            var fov = 2 * Math.atan(n / (n - 0.5)) / Math.PI * 180;
            for (var i = 0; i < 6; i++) {
                var target = targets[i];
                var camera = this._cameras[target];
                Vector3.copy(camera.position, this.position);
                camera.far = this.far;
                camera.near = this.near;
                camera.fov = fov;

                this.frameBuffer.attach(_gl, this.texture, _gl.COLOR_ATTACHMENT0, targetMap[target]);
                this.frameBuffer.bind(renderer);
                renderer.render(scene, camera, true);
                this.frameBuffer.unbind(renderer);
            }
        },
        dispose : function(_gl) {
            this.frameBuffer.dispose(_gl);
        }
    });

    return EnvironmentMapPass;
});
define('qtek/prePass/Reflection',['require','../core/Base','../math/Vector4'],function(require) {

    var Base = require("../core/Base");
    var Vector4 = require("../math/Vector4");

    var ReflectionPass = Base.derive(function() {
        // Vector4
    }, {
        render : function(renderer, scene, camera) {

        }
    });

    return ReflectionPass;
});
define('qtek/prePass/ShadowMap',['require','../core/Base','../core/glenum','../math/Vector3','../math/BoundingBox','../math/Frustum','../math/Matrix4','../Renderer','../Shader','../Light','../Mesh','../light/Spot','../light/Directional','../light/Point','../shader/library','../Material','../FrameBuffer','../texture/Texture2D','../texture/TextureCube','../camera/Perspective','../camera/Orthographic','../compositor/Pass','../compositor/texturePool','glmatrix'],function(require) {

    var Base = require("../core/Base");
    var glenum = require("../core/glenum");
    var Vector3 = require("../math/Vector3");
    var BoundingBox = require("../math/BoundingBox");
    var Frustum = require("../math/Frustum");
    var Matrix4 = require("../math/Matrix4");
    var Renderer = require('../Renderer');
    var Shader = require("../Shader");
    var Light = require("../Light");
    var Mesh = require("../Mesh");
    var SpotLight = require("../light/Spot");
    var DirectionalLight = require("../light/Directional");
    var PointLight = require("../light/Point");
    var shaderLibrary = require("../shader/library");
    var Material = require("../Material");
    var FrameBuffer = require("../FrameBuffer");
    var Texture2D = require("../texture/Texture2D");
    var TextureCube = require("../texture/TextureCube");
    var PerspectiveCamera = require("../camera/Perspective");
    var OrthoCamera = require("../camera/Orthographic");

    var Pass = require("../compositor/Pass");
    var texturePool = require("../compositor/texturePool");

    var glMatrix = require("glmatrix");
    var mat4 = glMatrix.mat4;
    var vec3 = glMatrix.vec3;

    var frameBuffer = new FrameBuffer();

    var targets = ['px', 'nx', 'py', 'ny', 'pz', 'nz'];
    var targetMap = {
        'px' : glenum.TEXTURE_CUBE_MAP_POSITIVE_X,
        'py' : glenum.TEXTURE_CUBE_MAP_POSITIVE_Y,
        'pz' : glenum.TEXTURE_CUBE_MAP_POSITIVE_Z,
        'nx' : glenum.TEXTURE_CUBE_MAP_NEGATIVE_X,
        'ny' : glenum.TEXTURE_CUBE_MAP_NEGATIVE_Y,
        'nz' : glenum.TEXTURE_CUBE_MAP_NEGATIVE_Z,
    }

    var ShadowMapPass = Base.derive(function() {
        return {
            
            softShadow : ShadowMapPass.PCF,
            shadowBlur : 1.0,

            shadowCascade  : 1,
            cascadeSplitLogFactor : 0.2,

            _textures : {},
            _shadowMapNumber : {
                'POINT_LIGHT' : 0,
                'DIRECTIONAL_LIGHT' : 0,
                'SPOT_LIGHT' : 0
            },

            _meshMaterials : {},
            _depthMaterials : {},
            _depthShaders : {},
            _distanceMaterials : {},

            _opaqueCasters : [],
            _receivers : [],
            _lightsCastShadow : [],

            _lightCameras : {}
        }
    }, function() {
        // Gaussian filter pass for VSM
        this._gaussianPassH = new Pass({
            fragment : Shader.source('buildin.compositor.gaussian_blur_h')
        });
        this._gaussianPassV = new Pass({
            fragment : Shader.source('buildin.compositor.gaussian_blur_v')
        });
        this._gaussianPassH.setUniform("blurSize", this.shadowBlur);
        this._gaussianPassV.setUniform("blurSize", this.shadowBlur);

        this._outputDepthPass = new Pass({
            fragment : Shader.source('buildin.sm.debug_depth')
        });
    }, {

        render : function(renderer, scene, sceneCamera) {
            this.trigger('beforerender', this, renderer, scene, sceneCamera);
            this._renderShadowPass(renderer, scene, sceneCamera);
            this.trigger('afterrender', this, renderer, scene, sceneCamera);
        },

        renderDebug : function(renderer, size) {
            var prevClear = renderer.clear;
            renderer.clear = glenum.DEPTH_BUFFER_BIT;
            var viewport = renderer.viewport;
            var x = 0, y = 0;
            var width = size || viewport.width / 4;
            var height = width;
            if (this.softShadow === ShadowMapPass.VSM) {
                this._outputDepthPass.material.shader.define("fragment", "USE_VSM");
            } else {
                this._outputDepthPass.material.shader.unDefine("fragment", "USE_VSM");
            }
            for (var name in this._textures) {
                renderer.setViewport(x, y, width, height);
                this._outputDepthPass.setUniform('depthMap', this._textures[name]);
                this._outputDepthPass.render(renderer);
                x += width;
            }
            renderer.setViewport(viewport);
            renderer.clear = prevClear;
        },

        _bindDepthMaterial : function(casters, bias, slopeScale) {
            for (var i = 0; i < casters.length; i++) {
                var mesh = casters[i];
                var isShadowTransparent = mesh.material.shadowTransparentMap instanceof Texture2D;
                var transparentMap = mesh.material.shadowTransparentMap;
                var nJoints = mesh.joints && mesh.joints.length;
                if (isShadowTransparent) {
                    var matHashKey = nJoints + '-' + transparentMap.__GUID__;
                    var shaderHashKey = nJoints + 's';
                } else {
                    var matHashKey = nJoints;
                    var shaderHashKey = nJoints;
                }
                var depthMaterial = this._depthMaterials[matHashKey];
                var depthShader = this._depthShaders[shaderHashKey];

                if (mesh.material !== depthMaterial) {  // Not binded yet
                    if (!depthShader) {
                        depthShader = new Shader({
                            vertex : Shader.source("buildin.sm.depth.vertex"),
                            fragment : Shader.source("buildin.sm.depth.fragment")
                        });
                        if (nJoints > 0) {
                            depthShader.define('vertex', 'SKINNING');
                            depthShader.define('vertex', 'JOINT_NUMBER', nJoints);   
                        }
                        if (isShadowTransparent) {
                            depthShader.define('both', 'SHADOW_TRANSPARENT');
                        }
                        this._depthShaders[shaderHashKey] = depthShader;
                    }
                    if (!depthMaterial) {
                        // Skinned mesh
                        depthMaterial = new Material({
                            shader : depthShader
                        });
                        this._depthMaterials[matHashKey] = depthMaterial;
                    }

                    this._meshMaterials[mesh.__GUID__] = mesh.material;
                    mesh.material = depthMaterial;

                    if (this.softShadow === ShadowMapPass.VSM) {
                        depthShader.define("fragment", "USE_VSM");
                    } else {
                        depthShader.unDefine("fragment", "USE_VSM");
                    }

                    depthMaterial.setUniform('bias', bias);
                    depthMaterial.setUniform('slopeScale', slopeScale);
                    if (isShadowTransparent) {
                        depthMaterial.set('shadowTransparentMap', transparentMap);
                    }
                }
            }
        },

        _bindDistanceMaterial : function(casters, light) {
            for (var i = 0; i < casters.length; i++) {
                var mesh = casters[i];
                var nJoints = mesh.joints && mesh.joints.length;
                var distanceMaterial = this._distanceMaterials[nJoints];
                if (mesh.material !== distanceMaterial) {
                    if (!distanceMaterial) {
                        // Skinned mesh
                        distanceMaterial = new Material({
                            shader : new Shader({
                                vertex : Shader.source("buildin.sm.distance.vertex"),
                                fragment : Shader.source("buildin.sm.distance.fragment")
                            })
                        });
                        if (nJoints > 0) {
                            distanceMaterial.shader.define('vertex', 'SKINNING');
                            distanceMaterial.shader.define('vertex', 'JOINT_NUMBER', nJoints);   
                        }
                        this._distanceMaterials[nJoints] = distanceMaterial;
                    }

                    this._meshMaterials[mesh.__GUID__] = mesh.material;
                    mesh.material = distanceMaterial;

                    if (this.softShadow === ShadowMapPass.VSM) {
                        distanceMaterial.shader.define("fragment", "USE_VSM");
                    } else {
                        distanceMaterial.shader.unDefine("fragment", "USE_VSM");
                    }
                    distanceMaterial.set("lightPosition", light.position._array);
                    distanceMaterial.set("range", light.range * 5);
                }
            }
        },

        _restoreMaterial : function(casters) {
            for (var i = 0; i < casters.length; i++) {
                var mesh = casters[i];
                mesh.material = this._meshMaterials[mesh.__GUID__];
            }
        },

        _updateCaster : function(mesh) {
            if (mesh.castShadow) {
                this._opaqueCasters.push(mesh);
            }
            if (mesh.receiveShadow) {
                this._receivers.push(mesh);
                mesh.material.__shadowUniformUpdated = false;
                mesh.material.shader.__shadowDefineUpdated = false;
                mesh.material.set('shadowEnabled', 1);
            } else {
                mesh.material.set('shadowEnabled', 0);
            }
            if (this.softShadow === ShadowMapPass.VSM) {
                mesh.material.shader.define('fragment', 'USE_VSM');
            } else {
                mesh.material.shader.unDefine('fragment', 'USE_VSM');
            }
        },

        _update : function(scene) {
            for (var i = 0; i < scene.opaqueQueue.length; i++) {
                this._updateCaster(scene.opaqueQueue[i]);
            }
            for (var i = 0; i < scene.transparentQueue.length; i++) {
                // TODO Transparent object receive shadow will be very slow
                // in stealth demo, still not find the reason
                this._updateCaster(scene.transparentQueue[i]);
            }
            for (var i = 0; i < scene.lights.length; i++) {
                var light = scene.lights[i];
                if (light.castShadow) {
                    this._lightsCastShadow.push(light)
                }
            }
        },

        _renderShadowPass : function(renderer, scene, sceneCamera) {
            var self = this;

            // reset
            for (var name in this._shadowMapNumber) {
                this._shadowMapNumber[name] = 0;
            }
            this._lightsCastShadow.length = 0;
            this._opaqueCasters.length = 0;
            this._receivers.length = 0;

            var _gl = renderer.gl;

            scene.update();

            this._update(scene);

            if (!this._lightsCastShadow.length) {
                return;
            }

            _gl.enable(_gl.DEPTH_TEST);
            _gl.depthMask(true);
            _gl.disable(_gl.BLEND);

            _gl.clearColor(0.0, 0.0, 0.0, 0.0);

            var cursor = 0;

            // Shadow uniforms
            var spotLightShadowMaps = [];
            var spotLightMatrices = [];
            var directionalLightShadowMaps = [];
            var directionalLightMatrices = [];
            var shadowCascadeClips = [];
            var pointLightShadowMaps = [];
            var pointLightRanges = [];

            // Create textures for shadow map
            for (var i = 0; i < this._lightsCastShadow.length; i++) {
                var light = this._lightsCastShadow[i];
                if (light instanceof DirectionalLight) {
                    this._renderDirectionalLightShadow
                    (
                        renderer,
                        light,
                        scene,
                        sceneCamera,
                        this._opaqueCasters,
                        shadowCascadeClips,
                        directionalLightMatrices,
                        directionalLightShadowMaps
                    );
                } else if (light instanceof SpotLight) {
                    this._renderSpotLightShadow
                    (
                        renderer,
                        light,
                        this._opaqueCasters, 
                        spotLightMatrices,
                        spotLightShadowMaps
                    );
                } else if (light instanceof PointLight) {
                    this._renderPointLightShadow
                    (
                        renderer,
                        light,
                        this._opaqueCasters,
                        pointLightRanges,
                        pointLightShadowMaps
                    )
                }

                this._shadowMapNumber[light.type]++;
            };
            this._restoreMaterial(this._opaqueCasters);

            if (this.shadowCascade > 1 && this._shadowMapNumber.DIRECTIONAL_LIGHT > 1) {
                console.warn('There is only one directional light can cast shadow when using cascaded shadow map');
            }

            var shadowCascadeClipsNear = shadowCascadeClips.slice();
            var shadowCascadeClipsFar = shadowCascadeClips.slice();
            shadowCascadeClipsNear.pop();
            shadowCascadeClipsFar.shift();

            for (var i = 0; i < this._receivers.length; i++) {
                var mesh = this._receivers[i];
                var material = mesh.material;
                if (material.__shadowUniformUpdated) {
                    continue;
                }
                var shader = material.shader;

                if (!shader.__shadowDefineUpdated) {
                    var shaderNeedsUpdate = false;
                    for (var lightType in this._shadowMapNumber) {
                        var number = this._shadowMapNumber[lightType];
                        var key = lightType + "_SHADOWMAP_NUMBER";

                        if (shader.fragmentDefines[key] !== number && number > 0) {
                            shader.fragmentDefines[key] = number;
                            shaderNeedsUpdate = true;
                        }
                    }
                    if (shaderNeedsUpdate) {
                        shader.dirty();
                    }
                    if (this.shadowCascade > 1) {
                        shader.define('fragment', 'SHADOW_CASCADE', this.shadowCascade);
                    } else {
                        shader.unDefine('fragment', 'SHADOW_CASCADE');
                    }
                    shader.__shadowDefineUpdated = true;
                }

                if (spotLightShadowMaps.length > 0) {
                    material.setUniform("spotLightShadowMaps", spotLightShadowMaps);
                    material.setUniform("spotLightMatrices", spotLightMatrices);   
                }
                if (directionalLightShadowMaps.length > 0) {
                    material.setUniform("directionalLightShadowMaps", directionalLightShadowMaps);
                    if (this.shadowCascade > 1) {
                        material.setUniform('shadowCascadeClipsNear', shadowCascadeClipsNear);
                        material.setUniform('shadowCascadeClipsFar', shadowCascadeClipsFar);
                    }
                    material.setUniform("directionalLightMatrices", directionalLightMatrices);   
                }
                if (pointLightShadowMaps.length > 0) {
                    material.setUniform("pointLightShadowMaps", pointLightShadowMaps);
                    material.setUniform("pointLightRanges", pointLightRanges);   
                }
                material.__shadowUniformUpdated = true;
            }
        },

        _renderDirectionalLightShadow : (function() {

            var splitFrustum = new Frustum();
            var splitProjMatrix = new Matrix4();
            var cropBBox = new BoundingBox();
            var cropMatrix = new Matrix4();
            var lightViewProjMatrix = new Matrix4();
            var lightProjMatrix = new Matrix4();

            var prevDepth = 0;
            var deltaDepth = 0;
            return function(renderer, light, scene, sceneCamera, casters, shadowCascadeClips, directionalLightMatrices, directionalLightShadowMaps) {

                var shadowBias = light.shadowBias;
                this._bindDepthMaterial(casters, shadowBias, light.shadowSlopeScale);

                casters.sort(Renderer.opaqueSortFunc);

                // Adjust scene camera
                var originalFar = sceneCamera.far;

                // Considering moving speed since the bounding box is from last frame
                // verlet integration ?
                var depth = -sceneCamera.sceneBoundingBoxLastFrame.min.z;
                deltaDepth = Math.max(depth - prevDepth, 0);
                prevDepth = depth;
                depth += deltaDepth;
                // TODO: add a bias
                if (depth > sceneCamera.near) {
                    sceneCamera.far = Math.min(sceneCamera.far, depth);   
                }
                sceneCamera.updateProjectionMatrix();
                sceneCamera.frustum.setFromProjection(sceneCamera.projectionMatrix);
                var lightCamera = this._getDirectionalLightCamera(light, scene, sceneCamera);

                var lvpMat4Arr = lightViewProjMatrix._array;
                mat4.copy(lvpMat4Arr, lightCamera.worldTransform._array);
                mat4.invert(lvpMat4Arr, lvpMat4Arr);
                mat4.multiply(lvpMat4Arr, lightCamera.projectionMatrix._array, lvpMat4Arr);
                mat4.multiply(lvpMat4Arr, lvpMat4Arr, sceneCamera.worldTransform._array);

                lightProjMatrix.copy(lightCamera.projectionMatrix);

                var clipPlanes = [];
                var near = sceneCamera.near;
                var far = sceneCamera.far;
                var rad = sceneCamera.fov / 180 * Math.PI;
                var aspect = sceneCamera.aspect;

                var scaleZ = (near + originalFar) / (near - originalFar);
                var offsetZ = 2 * near * originalFar / (near - originalFar);
                for (var i = 0; i <= this.shadowCascade; i++) {
                    var clog = near * Math.pow(far / near, i / this.shadowCascade);
                    var cuni = near + (far - near) * i / this.shadowCascade;
                    var c = clog * this.cascadeSplitLogFactor + cuni * (1 - this.cascadeSplitLogFactor);
                    clipPlanes.push(c);
                    shadowCascadeClips.push(-(-c * scaleZ + offsetZ) / -c);
                }
                for (var i = 0; i < this.shadowCascade; i++) {
                    var texture = this._getTexture(light.__GUID__ + '_' + i, light);

                    // Get the splitted frustum
                    var nearPlane = clipPlanes[i];
                    var farPlane = clipPlanes[i+1];
                    mat4.perspective(splitProjMatrix._array, rad, aspect, nearPlane, farPlane);
                    splitFrustum.setFromProjection(splitProjMatrix);
                    splitFrustum.getTransformedBoundingBox(cropBBox, lightViewProjMatrix);
                    var _min = cropBBox.min._array;
                    var _max = cropBBox.max._array;
                    cropMatrix.ortho(_min[0], _max[0], _min[1], _max[1], 1, -1);
                    lightCamera.projectionMatrix.multiplyLeft(cropMatrix);

                    var _gl = renderer.gl;

                    frameBuffer.attach(_gl, texture);
                    frameBuffer.bind(renderer);

                    _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);

                    // Set bias seperately for each cascade
                    // TODO Simply divide 1.5 ?
                    for (var key in this._depthMaterials) {
                        this._depthMaterials[key].set('shadowBias', shadowBias);
                    }

                    renderer.renderQueue(casters, lightCamera);

                    frameBuffer.unbind(renderer);

                    // Filter for VSM
                    if (this.softShadow === ShadowMapPass.VSM) {
                        this._gaussianFilter(renderer, texture, texture.width);
                    }

                    var matrix = new Matrix4();
                    matrix.copy(lightCamera.worldTransform)
                        .invert()
                        .multiplyLeft(lightCamera.projectionMatrix);

                    directionalLightShadowMaps.push(texture);
                    directionalLightMatrices.push(matrix._array);

                    lightCamera.projectionMatrix.copy(lightProjMatrix);
                }

                // set back
                sceneCamera.far = originalFar;
            }
        })(),

        _renderSpotLightShadow : function(renderer, light, casters, spotLightMatrices, spotLightShadowMaps) {

            this._bindDepthMaterial(casters, light.shadowBias, light.shadowSlopeScale);
            casters.sort(Renderer.opaqueSortFunc);

            var texture = this._getTexture(light.__GUID__, light);
            var camera = this._getSpotLightCamera(light);
            var _gl = renderer.gl;

            frameBuffer.attach(_gl, texture);
            frameBuffer.bind(renderer);

            _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);

            renderer.renderQueue(casters, camera);

            frameBuffer.unbind(renderer);

            // Filter for VSM
            if (this.softShadow === ShadowMapPass.VSM) {
                this._gaussianFilter(renderer, texture, texture.width);
            }

            var matrix = new Matrix4();
            matrix.copy(camera.worldTransform)
                .invert()
                .multiplyLeft(camera.projectionMatrix);

            spotLightShadowMaps.push(texture);
            spotLightMatrices.push(matrix._array);
        },

        _renderPointLightShadow : function(renderer, light, casters, pointLightRanges, pointLightShadowMaps) {
            var texture = this._getTexture(light.__GUID__, light);
            var _gl = renderer.gl;
            pointLightShadowMaps.push(texture);
            pointLightRanges.push(light.range * 5);

            this._bindDistanceMaterial(casters, light);
            for (var i = 0; i < 6; i++) {
                var target = targets[i];
                var camera = this._getPointLightCamera(light, target);

                frameBuffer.attach(renderer.gl, texture, _gl.COLOR_ATTACHMENT0, targetMap[target]);
                frameBuffer.bind(renderer);

                _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);

                renderer.renderQueue(casters, camera);

                frameBuffer.unbind(renderer);
            }
        },

        _gaussianFilter : function(renderer, texture, size) {
            var parameter = {
                width : size,
                height : size,
                type : glenum.FLOAT
            };
            var _gl = renderer.gl;
            var tmpTexture = texturePool.get(parameter);
            
            frameBuffer.attach(_gl, tmpTexture);
            frameBuffer.bind(renderer);
            this._gaussianPassH.setUniform("texture", texture);
            this._gaussianPassH.setUniform("textureWidth", size);
            this._gaussianPassH.render(renderer);
            frameBuffer.unbind(renderer);

            frameBuffer.attach(_gl, texture);
            frameBuffer.bind(renderer);
            this._gaussianPassV.setUniform("texture", tmpTexture);
            this._gaussianPassV.setUniform("textureHeight", size);
            this._gaussianPassV.render(renderer);
            frameBuffer.unbind(renderer);

            texturePool.put(tmpTexture);
        },

        _getTexture : function(key, light) {
            var texture = this._textures[key];
            var resolution = light.shadowResolution || 512;
            if (!texture) {
                if (light instanceof PointLight) {
                    texture = new TextureCube();
                } else {
                    texture = new Texture2D();
                }
                texture.width = resolution;
                texture.height = resolution;
                if (this.softShadow === ShadowMapPass.VSM) {
                    texture.type = glenum.FLOAT;
                    texture.anisotropic = 4;
                } else {
                    texture.minFilter = glenum.NEAREST;
                    texture.magFilter = glenum.NEAREST;
                    texture.useMipmap = false;
                }
                this._textures[key] = texture;
            }

            return texture;
        },

        _getPointLightCamera : function(light, target) {
            if (!this._lightCameras.point) {
                this._lightCameras.point = {
                    px : new PerspectiveCamera(),
                    nx : new PerspectiveCamera(),
                    py : new PerspectiveCamera(),
                    ny : new PerspectiveCamera(),
                    pz : new PerspectiveCamera(),
                    nz : new PerspectiveCamera()
                };
            }
            var camera = this._lightCameras.point[target];

            camera.far = light.range;
            camera.fov = 90;
            camera.position.set(0, 0, 0);
            switch (target) {
                case 'px':
                    camera.lookAt(Vector3.POSITIVE_X, Vector3.NEGATIVE_Y);
                    break;
                case 'nx':
                    camera.lookAt(Vector3.NEGATIVE_X, Vector3.NEGATIVE_Y);
                    break;
                case 'py':
                    camera.lookAt(Vector3.POSITIVE_Y, Vector3.POSITIVE_Z);
                    break;
                case 'ny':
                    camera.lookAt(Vector3.NEGATIVE_Y, Vector3.NEGATIVE_Z);
                    break;
                case 'pz':
                    camera.lookAt(Vector3.POSITIVE_Z, Vector3.NEGATIVE_Y);
                    break;
                case 'nz':
                    camera.lookAt(Vector3.NEGATIVE_Z, Vector3.NEGATIVE_Y);
                    break;
            }
            camera.position.copy(light.position);
            camera.update();

            return camera;
        },

        _getDirectionalLightCamera : (function() {
            var lightViewMatrix = new Matrix4();
            var lightViewBBox = new BoundingBox();
            // Camera of directional light will be adjusted
            // to contain the view frustum and scene bounding box as tightly as possible
            return function(light, scene, sceneCamera) {
                if (!this._lightCameras.directional) {
                    this._lightCameras.directional = new OrthoCamera();
                }
                var camera = this._lightCameras.directional;

                // Move to the center of frustum(in world space)
                camera.position
                    .copy(sceneCamera.frustum.boundingBox.min)
                    .add(sceneCamera.frustum.boundingBox.max)
                    .scale(0.5)
                    .transformMat4(sceneCamera.worldTransform);
                camera.rotation.copy(light.rotation);
                camera.scale.copy(light.scale);
                camera.updateLocalTransform();
                camera.updateWorldTransform();

                // Transform to light view space
                lightViewMatrix
                    .copy(camera.worldTransform)
                    .invert()
                    .multiply(sceneCamera.worldTransform);
                
                sceneCamera.frustum.getTransformedBoundingBox(lightViewBBox, lightViewMatrix);
                var min = lightViewBBox.min._array;
                var max = lightViewBBox.max._array;

                // Move camera to adjust the near to 0
                // TODO : some scene object cast shadow in view will also be culled
                // add a bias?
                camera.position.scaleAndAdd(camera.worldTransform.forward, max[2] + 10);
                camera.near = 0;
                camera.far = -min[2] + max[2] + 10;
                camera.left = min[0];
                camera.right = max[0];
                camera.top = max[1];
                camera.bottom = min[1];
                camera.update(true);

                return camera;
            }
        })(),

        _getSpotLightCamera : function(light) {
            if (!this._lightCameras.spot) {
                this._lightCameras.spot = new PerspectiveCamera();
            }
            var camera = this._lightCameras.spot;
            // Update properties
            camera.fov = light.penumbraAngle * 2;
            camera.far = light.range;
            camera.worldTransform.copy(light.worldTransform);
            camera.updateProjectionMatrix();
            mat4.invert(camera.viewMatrix._array, camera.worldTransform._array);

            return camera
        },

        dispose : function(_gl) {
            for (var guid in this._depthMaterials) {
                var mat = this._depthMaterials[guid];
                mat.dispose();
            }
            for (var guid in this._distanceMaterials) {
                var mat = this._distanceMaterials[guid];
                mat.dispose();
            }

            for (var name in this._textures) {
                this._textures[name].dispose(_gl);
            }

            this._depthMaterials = {};
            this._distanceMaterials = {};
            this._textures = {};
            this._lightCameras = {};
            this._shadowMapNumber = {
                'POINT_LIGHT' : 0,
                'DIRECTIONAL_LIGHT' : 0,
                'SPOT_LIGHT' : 0
            };
            this._meshMaterials = {};

            for (var i = 0; i < this._receivers.length; i++) {
                var mesh = this._receivers[i];
                var material = mesh.material;
                var shader = material.shader;
                shader.unDefine('fragment', 'POINT_LIGHT_SHADOW_NUMBER');
                shader.unDefine('fragment', 'DIRECTIONAL_LIGHT_SHADOW_NUMBER');
                shader.unDefine('fragment', 'AMBIENT_LIGHT_SHADOW_NUMBER');
                material.set('shadowEnabled', 0);
            }

            this._opaqueCasters = [];
            this._receivers = [];
            this._lightsCastShadow = [];
        }
    });

    ShadowMapPass.VSM = 1;
    ShadowMapPass.PCF = 2;
    
    return ShadowMapPass;
});
define('qtek/util/dds',['require','../Texture','../texture/Texture2D','../texture/TextureCube'],function(require) {

    var Texture = require('../Texture');
    var Texture2D = require('../texture/Texture2D');
    var TextureCube = require('../texture/TextureCube');

    // http://msdn.microsoft.com/en-us/library/windows/desktop/bb943991(v=vs.85).aspx
    // https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js
    var DDS_MAGIC = 0x20534444;

    var DDSD_CAPS = 0x1,
        DDSD_HEIGHT = 0x2,
        DDSD_WIDTH = 0x4,
        DDSD_PITCH = 0x8,
        DDSD_PIXELFORMAT = 0x1000,
        DDSD_MIPMAPCOUNT = 0x20000,
        DDSD_LINEARSIZE = 0x80000,
        DDSD_DEPTH = 0x800000;

    var DDSCAPS_COMPLEX = 0x8,
        DDSCAPS_MIPMAP = 0x400000,
        DDSCAPS_TEXTURE = 0x1000;

    var DDSCAPS2_CUBEMAP = 0x200,
        DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,
        DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,
        DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,
        DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,
        DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,
        DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,
        DDSCAPS2_VOLUME = 0x200000;

    var DDPF_ALPHAPIXELS = 0x1,
        DDPF_ALPHA = 0x2,
        DDPF_FOURCC = 0x4,
        DDPF_RGB = 0x40,
        DDPF_YUV = 0x200,
        DDPF_LUMINANCE = 0x20000;

    function fourCCToInt32(value) {
        return value.charCodeAt(0) +
            (value.charCodeAt(1) << 8) +
            (value.charCodeAt(2) << 16) +
            (value.charCodeAt(3) << 24);
    }

    function int32ToFourCC(value) {
        return String.fromCharCode(
            value & 0xff,
            (value >> 8) & 0xff,
            (value >> 16) & 0xff,
            (value >> 24) & 0xff
        );
    }

    var headerLengthInt = 31; // The header length in 32 bit ints

    var FOURCC_DXT1 = fourCCToInt32("DXT1");
    var FOURCC_DXT3 = fourCCToInt32("DXT3");
    var FOURCC_DXT5 = fourCCToInt32("DXT5");
     // Offsets into the header array
    var off_magic = 0;

    var off_size = 1;
    var off_flags = 2;
    var off_height = 3;
    var off_width = 4;

    var off_mipmapCount = 7;

    var off_pfFlags = 20;
    var off_pfFourCC = 21;

    var off_caps = 27;
    var off_caps2 = 28;
    var off_caps3 = 29;
    var off_caps4 = 30;

    var ret = {
        parse : function(arrayBuffer, out) {
            var header = new Int32Array(arrayBuffer, 0, headerLengthInt);
            if (header[off_magic] !== DDS_MAGIC) {
                return null;
            }
            if (!header(off_pfFlags) & DDPF_FOURCC) {
                return null;
            }

            var fourCC = header(off_pfFourCC);
            var width = header[off_width];
            var height = header[off_height];
            var isCubeMap = header[off_caps2] & DDSCAPS2_CUBEMAP;
            var hasMipmap = header[off_flags] & DDSD_MIPMAPCOUNT;
            var blockBytes, internalFormat;
            switch(fourCC) {
                case FOURCC_DXT1:
                    blockBytes = 8;
                    internalFormat = Texture.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    break;
                case FOURCC_DXT3:
                    blockBytes = 16;
                    internalFormat = Texture.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    break;
                case FOURCC_DXT5:
                    blockBytes = 16;
                    internalFormat = Texture.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                    break;
                default:
                    return null;
            }
            var dataOffset = header[off_size] + 4;
            // TODO: Suppose all face are existed
            var faceNumber = isCubeMap ? 6 : 1;
            var mipmapCount = 1;
            if (hasMipmap) {
                mipmapCount = Math.max(1, header[off_mipmapCount]);
            }

            var textures = [];
            for (var f = 0; f < faceNumber; f++) {
                var _width = width;
                var _height = height;
                textures[f] = new Texture2D({
                    width : _width,
                    height : _height,
                    format : internalFormat
                });
                var mipmaps = [];
                for (var i = 0; i < mipmapCount; i++) {
                    var dataLength = Math.max(4, _width) / 4 * Math.max(4, _height) / 4 * blockBytes;
                    var byteArray = new Uint8Array(arrayBuffer, dataOffset, dataLength);

                    dataOffset += dataLength;
                    _width *= 0.5;
                    _height *= 0.5;
                    mipmaps[i] = byteArray;
                }
                textures[f].pixels = mipmaps[0];
                if (hasMipmap) {
                    textures[f].mipmaps = mipmaps;
                }
            }
            // TODO
            // return isCubeMap ? textures : textures[0];
            if (out) {
                out.width = textures[0].width;
                out.height = textures[0].height;
                out.format = textures[0].format;
                out.pixels = textures[0].pixels;
                out.mipmaps = textures[0].mipmaps;
            } else {
                return textures[0];
            }
        }
    }
});
define('qtek/util/hdr',['require','../Texture','../texture/Texture2D'],function(require) {

    var Texture = require('../Texture');
    var Texture2D = require('../texture/Texture2D');
    var toChar = String.fromCharCode;

    var MINELEN = 8;
    var MAXELEN = 0x7fff;
    function rgbe2float(rgbe, buffer, offset, exposure) {
        if (rgbe[3] > 0) {
            var f = Math.pow(2.0, rgbe[3] - 128 - 8 + exposure);
            buffer[offset + 0] = rgbe[0] * f;
            buffer[offset + 1] = rgbe[1] * f;
            buffer[offset + 2] = rgbe[2] * f;
        } else {
            buffer[offset + 0] = 0;
            buffer[offset + 1] = 0;
            buffer[offset + 2] = 0;
        }
        buffer[offset + 3] = 1.0;
        return buffer;
    }

    function uint82string(array, offset, size) {
        var str = '';
        for (var i = offset; i < size; i++) {
            str += toChar(array[i]);
        }
        return str;
    }

    function copyrgbe(s, t) {
        t[0] = s[0];
        t[1] = s[1];
        t[2] = s[2];
        t[3] = s[3];
    }

    // TODO : check
    function oldReadColors(scan, buffer, offset, xmax) {
        var rshift = 0, x = 0, len = xmax;
        while (len > 0) {
            scan[x][0] = buffer[offset++];
            scan[x][1] = buffer[offset++];
            scan[x][2] = buffer[offset++];
            scan[x][3] = buffer[offset++];
            if (scan[x][0] === 1 && scan[x][1] === 1 && scan[x][2] === 1) {
                // exp is count of repeated pixels
                for (var i = (scan[x][3] << rshift) >>> 0; i > 0; i--) {
                    copy(scan[x-1], scan[x]);
                    x++;
                    len--;
                }
                rshift += 8;
            } else {
                x++;
                len--;
                rshift = 0;
            }
        }
        return offset;
    }

    function readColors(scan, buffer, offset, xmax) {
        if ((xmax < MINELEN) | (xmax > MAXELEN)) {
            return oldReadColors(scan, buffer, offset, xmax);
        }
        var i = buffer[offset++];
        if (i != 2) {
            return oldReadColors(scan, buffer, offset - 1, xmax);
        }
        scan[0][1] = buffer[offset++];
        scan[0][2] = buffer[offset++];

        i = buffer[offset++];
        if ((((scan[0][2] << 8) >>> 0) | i) >>> 0 !== xmax) {
            return null;
        }
        for (var i = 0; i < 4; i++) {
            for (var x = 0; x < xmax;) {
                var code = buffer[offset++];
                if (code > 128) {
                    code = (code & 127) >>> 0;
                    var val = buffer[offset++];
                    while (code--) {
                        scan[x++][i] = val;
                    }
                } else {
                    while (code--) {
                        scan[x++][i] = buffer[offset++];
                    }
                }
            }
        }
        return offset;
    }


    var ret = {
        // http://www.graphics.cornell.edu/~bjw/rgbe.html
        // Blender source
        // http://radsite.lbl.gov/radiance/refer/Notes/picture_format.html
        parseRGBE : function(arrayBuffer, texture, exposure) {
            if (exposure === undefined) {
                exposure = 0;
            }
            var data = new Uint8Array(arrayBuffer);
            var size = data.length;
            if (uint82string(data, 0, 2) !== '#?') {
                return;
            }
            // find empty line, next line is resolution info
            for (var i = 2; i < size; i++) {
                if (toChar(data[i]) === '\n' && toChar(data[i+1]) === '\n') {
                    break;
                }
            }
            if (i >= size) { // not found
                return;
            }
            // find resolution info line
            i += 2;
            var str = ''
            for (; i < size; i++) {
                var _char = toChar(data[i]);
                if (_char === '\n') {
                    break;
                }
                str += _char;
            }
            // -Y M +X N
            var tmp = str.split(' ');
            var height = parseInt(tmp[1]);
            var width = parseInt(tmp[3]);
            if (!width || !height) {
                return;
            }

            // read and decode actual data
            var offset = i+1;
            var scanline = [];
            // memzero
            for (var x = 0; x < width; x++) {
                scanline[x] = [];
                for (var j = 0; j < 4; j++) {
                    scanline[x][j] = 0;
                }
            }
            var pixels = new Float32Array(width * height * 4);
            var offset2 = 0;
            for (var y = 0; y < height; y++) {
                var offset = readColors(scanline, data, offset, width);
                if (!offset) {
                    return null;
                }
                for (var x = 0; x < width; x++) {
                    rgbe2float(scanline[x], pixels, offset2, exposure);
                    offset2 += 4;
                }
            }

            if (!texture) {
                texture = new Texture2D();
            }
            texture.width = width;
            texture.height = height;
            texture.pixels = pixels;
            texture.type = Texture.FLOAT;
            return texture;
        },

        parseRGBEFromPNG : function(png) {

        }
    }
    return ret;
});
/**
 *
 * @export{object} mesh
 */
define('qtek/util/mesh',['require','../Geometry','../DynamicGeometry','../StaticGeometry','../Mesh','../Node','../Material','../Shader','glmatrix','../math/BoundingBox'],function(require) {
    
    var Geometry = require("../Geometry");
    var DynamicGeometry = require("../DynamicGeometry");
    var StaticGeometry = require("../StaticGeometry");
    var Mesh = require("../Mesh");
    var Node = require("../Node");
    var Material = require("../Material");
    var Shader = require("../Shader");
    var glMatrix = require("glmatrix");
    var BoundingBox = require('../math/BoundingBox');
    var mat4 = glMatrix.mat4;
    var vec3 = glMatrix.vec3;

    var arraySlice = Array.prototype.slice;

    var meshUtil = {
        /**
         * Merge multiple meshes to one.
         * Note that these meshes must have the same material
         */
        merge : function(meshes, applyWorldTransform) {

            if (! meshes.length) {
                return;
            }

            var templateMesh = meshes[0];
            var templateGeo = templateMesh.geometry;
            var material = templateMesh.material;
            var isStatic = templateGeo instanceof StaticGeometry;

            var geometry = isStatic ? new StaticGeometry() : new DynamicGeometry();
            geometry.boundingBox = new BoundingBox();
            var faces = geometry.faces;

            var attributeNames = templateGeo.getEnabledAttributes();
            // TODO
            if (!isStatic) {
                attributeNames = Object.keys(attributeNames);
            }

            for (var i = 0; i < attributeNames.length; i++) {
                var name = attributeNames[i];
                var attr = templateGeo.attributes[name];
                // Extend custom attributes
                if (! geometry.attributes[name]) {
                    geometry.attributes[name] = attr.clone(false)
                }
            }

            var inverseTransposeMatrix = mat4.create();
            // Initialize the array data and merge bounding box
            if (isStatic) {
                var nVertex = 0;
                var nFace = 0;
                for (var k = 0; k < meshes.length; k++) {
                    var currentGeo = meshes[k].geometry;
                    if (currentGeo.boundingBox) {
                        currentGeo.boundingBox.applyTransform(applyWorldTransform ? meshes[k].worldTransform : meshes[k].localTransform);
                        geometry.boundingBox.union(currentGeo.boundingBox);
                    }
                    nVertex += currentGeo.getVertexNumber();
                    nFace += currentGeo.getFaceNumber();
                }
                for (var n = 0; n < attributeNames.length; n++) {
                    var name = attributeNames[n];
                    var attrib = geometry.attributes[name];
                    attrib.init(nVertex);
                }
                // TODO Uint32Array
                geometry.faces = new Uint16Array(nFace * 3);
            }

            var vertexOffset = 0;
            var faceOffset = 0;
            var useFaces = templateGeo.isUseFace();
            
            for (var mm = 0; mm < meshes.length; mm++) {
                var mesh = meshes[mm];  
                var currentGeo = mesh.geometry;

                var nVertex = currentGeo.getVertexNumber();

                var matrix = applyWorldTransform ? mesh.worldTransform._array : mesh.localTransform._array;
                mat4.invert(inverseTransposeMatrix, matrix);
                mat4.transpose(inverseTransposeMatrix, inverseTransposeMatrix);

                for (var nn = 0; nn < attributeNames.length; nn++) {
                    var name = attributeNames[nn];
                    var currentAttr = currentGeo.attributes[name];
                    var targetAttr = geometry.attributes[name];
                    // Skip the unused attributes;
                    if (!currentAttr.value.length) {
                        continue;
                    }
                    if (isStatic) {
                        var len = currentAttr.value.length;
                        var size = currentAttr.size;
                        var offset = vertexOffset * size;
                        var count = len / size;
                        for (var i = 0; i < len; i++) {
                            targetAttr.value[offset + i] = currentAttr.value[i];
                        }
                        // Transform position, normal and tangent
                        if (name === 'position') {
                            vec3.forEach(targetAttr.value, size, offset, count, vec3.transformMat4, matrix);
                        } else if (name === 'normal' || name === 'tangent') {
                            vec3.forEach(targetAttr.value, size, offset, count, vec3.transformMat4, inverseTransposeMatrix);
                        }
                    } else {
                        for (var i = 0; i < nVertex; i++) {
                            // Transform position, normal and tangent
                            if (name === "position") {
                                var newValue = vec3.create();
                                vec3.transformMat4(newValue, currentAttr.value[i], matrix);
                                targetAttr.value.push(newValue);
                            }
                            else if (name === "normal" || name === 'tangent') {
                                var newValue = vec3.create();
                                vec3.transformMat4(newValue, currentAttr.value[i], inverseTransposeMatrix);
                                targetAttr.value.push(newValue);
                            } else {
                                targetAttr.value.push(currentAttr.value[i]);
                            }
                        }
                    }
                }

                if (useFaces) {
                    var len = currentGeo.faces.length;
                    if (isStatic) {
                        for (var i = 0; i < len; i++) {
                            geometry.faces[i + faceOffset] = currentGeo.faces[i] + vertexOffset;
                        }
                        faceOffset += len;
                    } else {
                        for (var i = 0; i < len; i++) {
                            var newFace = [];
                            var face = currentGeo.faces[i];
                            newFace[0] = face[0] + vertexOffset;
                            newFace[1] = face[1] + vertexOffset;
                            newFace[2] = face[2] + vertexOffset;

                            faces.push(newFace);
                        }   
                    }
                }

                vertexOffset += nVertex;
            }

            return new Mesh({
                material : material,
                geometry : geometry
            });
        },

        splitByJoints : function(mesh, maxJointNumber, inPlace) {
            var geometry = mesh.geometry;
            var skeleton = mesh.skeleton;
            var material = mesh.material;
            var shader = material.shader;
            var joints = mesh.joints;
            if (!geometry || !skeleton || !joints.length) {
                return;
            }
            if (joints.length < maxJointNumber) {
                return mesh;
            }
            var isStatic = geometry instanceof StaticGeometry;

            var shaders = {};

            var faces = geometry.faces;
            
            var meshNumber = Math.ceil(joints.length / maxJointNumber);
            var faceLen = geometry.getFaceNumber();
            var rest = faceLen;
            var isFaceAdded = [];
            var jointValues = geometry.attributes.joint.value;
            for (var i = 0; i < faceLen; i++) {
                isFaceAdded[i] = false;
            }
            var addedJointIdxPerFace = [];

            var buckets = [];
            while(rest > 0) {
                var bucketFaces = [];
                var bucketJointReverseMap = [];
                var bucketJoints = [];
                var subJointNumber = 0;
                for (var i = 0; i < joints.length; i++) {
                    bucketJointReverseMap[i] = -1;
                }
                for (var f = 0; f < faceLen; f++) {
                    if (isFaceAdded[f]) {
                        continue;
                    }
                    var canAddToBucket = true;
                    var addedNumber = 0;
                    for (var i = 0; i < 3; i++) {
                        
                        var idx = isStatic ? faces[f * 3 + i] : faces[f][i];
                        
                        for (var j = 0; j < 4; j++) {
                            if (isStatic) {
                                var jointIdx = jointValues[idx * 4 + j];
                            } else {
                                var jointIdx = jointValues[idx][j];
                            }
                            if (jointIdx >= 0) {
                                if (bucketJointReverseMap[jointIdx] === -1) {
                                    if (subJointNumber < maxJointNumber) {
                                        bucketJointReverseMap[jointIdx] = subJointNumber;
                                        bucketJoints[subJointNumber++] = jointIdx;
                                        addedJointIdxPerFace[addedNumber++] = jointIdx;
                                    } else {
                                        canAddToBucket = false;
                                    }
                                }
                            }
                        }
                    }
                    if (!canAddToBucket) {
                        // Reverse operation
                        for (var i = 0; i < addedNumber; i++) {
                            bucketJointReverseMap[addedJointIdxPerFace[i]] = -1;
                            bucketJoints.pop();
                            subJointNumber--;
                        }
                    } else {
                        if (isStatic) {
                            bucketFaces.push(faces.subarray(f * 3, (f + 1) * 3));
                        } else {
                            bucketFaces.push(faces[f]);
                        }
                        isFaceAdded[f] = true;
                        rest--;
                    }
                }
                buckets.push({
                    faces : bucketFaces,
                    joints : bucketJoints.map(function(idx){return joints[idx];}),
                    jointReverseMap : bucketJointReverseMap
                });
            }

            var root = new Node({
                name : mesh.name
            });
            var attribNames = geometry.getEnabledAttributes();            
            // TODO
            if (!isStatic) {
                attribNames = Object.keys(attribNames);
            }

            attribNames.splice(attribNames.indexOf('joint'), 1);
            // Map from old vertex index to new vertex index
            var newIndices = [];
            for (var b = 0; b < buckets.length; b++) {
                var bucket = buckets[b];
                var jointReverseMap = bucket.jointReverseMap;
                var subJointNumber = bucket.joints.length;
                var subShader = shaders[subJointNumber];
                if (!subShader) {
                    subShader = shader.clone();
                    subShader.define('vertex', 'JOINT_NUMBER', subJointNumber);
                    shaders[subJointNumber] = subShader;
                }
                var subMat = new Material({
                    name : [material.name, b].join('-'),
                    shader : subShader,
                    transparent : material.transparent,
                    depthTest : material.depthTest,
                    depthMask : material.depthMask,
                    blend : material.blend
                });
                for (var name in material.uniforms) {
                    var uniform = material.uniforms[name];
                    subMat.set(name, uniform.value);
                }
                if (isStatic) {
                    var subGeo = new StaticGeometry();
                } else {
                    var subGeo = new DynamicGeometry();
                }
                var subMesh = new Mesh({
                    name : [mesh.name, i].join('-'),
                    material : subMat,
                    geometry : subGeo,
                    skeleton : skeleton,
                    joints : bucket.joints.slice()
                });
                var nVertex = 0;
                var nVertex2 = geometry.getVertexNumber();
                for (var i = 0; i < nVertex2; i++) {
                    newIndices[i] = -1;
                }
                // Count sub geo number
                for (var f = 0; f < bucket.faces.length; f++) {
                    var face = bucket.faces[f];
                    for (var i = 0; i < 3; i++) {
                        var idx = face[i];
                        if (newIndices[idx] === -1) {
                            newIndices[idx] = nVertex;
                            nVertex++;
                        }
                    }
                }
                if (isStatic) {
                    for (var a = 0; a < attribNames.length; a++) {
                        var attribName = attribNames[a];
                        var subAttrib = subGeo.attributes[attribName];
                        subAttrib.init(nVertex);
                    }
                    subGeo.attributes.joint.value = new Float32Array(nVertex * 4);
                    subGeo.faces = new Uint16Array(bucket.faces.length * 3);
                }

                var faceOffset = 0;
                nVertex = 0;
                for (var i = 0; i < nVertex2; i++) {
                    newIndices[i] = -1;
                }

                for (var f = 0; f < bucket.faces.length; f++) {
                    if (!isStatic) {
                        var newFace = [];
                    }
                    var face = bucket.faces[f];
                    for (var i = 0; i < 3; i++) {
                        
                        var idx = face[i];

                        if (newIndices[idx] === -1) {
                            newIndices[idx] = nVertex;
                            for (var a = 0; a < attribNames.length; a++) {
                                var attribName = attribNames[a];
                                var attrib = geometry.attributes[attribName];
                                var subAttrib = subGeo.attributes[attribName];
                                var size = attrib.size;

                                if (isStatic) {
                                    for (var j = 0; j < size; j++) {
                                        subAttrib.value[nVertex * size + j] = attrib.value[idx * size + j];
                                    }
                                } else {
                                    if (attrib.size === 1) {
                                        subAttrib.value[nVertex] = attrib.value[idx];
                                    } else {
                                        subAttrib.value[nVertex] = arraySlice.call(attrib.value[idx]);
                                    }   
                                }
                            }
                            if (isStatic) {
                                for (var j = 0; j < 4; j++) {
                                    var jointIdx = geometry.attributes.joint.value[idx * 4 + j];
                                    var offset = nVertex * 4 + j
                                    if (jointIdx >= 0) {
                                        subGeo.attributes.joint.value[offset] = jointReverseMap[jointIdx];
                                    } else {
                                        subGeo.attributes.joint.value[offset] = -1;
                                    }
                                }
                            } else {
                                var newJoints = subGeo.attributes.joint.value[nVertex] = [-1, -1, -1, -1];
                                // joints
                                for (var j = 0; j < 4; j++) {
                                    var jointIdx = geometry.attributes.joint.value[idx][j];
                                    if (jointIdx >= 0) {
                                        newJoints[j] = jointReverseMap[jointIdx];
                                    }
                                }
                            }
                            nVertex++;
                        }
                        if (isStatic) {
                            subGeo.faces[faceOffset++] = newIndices[idx];
                        } else {
                            newFace.push(newIndices[idx]);
                        }
                    }
                    if (!isStatic) {
                        subGeo.faces.push(newFace);
                    }
                }

                root.add(subMesh);
            }
            var children = mesh.children();
            for (var i = 0; i < children.length; i++) {
                root.add(children[i]);
            }
            root.position.copy(mesh.position);
            root.rotation.copy(mesh.rotation);
            root.scale.copy(mesh.scale);

            material.dispose();
            if (inPlace) {
                if (mesh.parent) {
                    var parent = mesh.parent;
                    parent.remove(mesh);
                    parent.add(root);
                }
            }
            return root;
        }
    }

    return meshUtil;
});
define('qtek/util/texture',['require','../Texture','../texture/Texture2D','../texture/TextureCube','../core/request','../prePass/EnvironmentMap','../plugin/Skydome','../Scene','./dds','./hdr'],function(require) {

    var Texture = require('../Texture');
    var Texture2D = require('../texture/Texture2D');
    var TextureCube = require('../texture/TextureCube');
    var request = require('../core/request');
    var EnvironmentMapPass = require('../prePass/EnvironmentMap');
    var Skydome = require('../plugin/Skydome');
    var Scene = require('../Scene');

    var dds = require('./dds');
    var hdr = require('./hdr');

    var environmentMapPass = new EnvironmentMapPass();

    var textureUtil = {
        loadTexture : function(path, onsuccess, onerror) {
            var texture;
            if (typeof(path) === 'string') {
                if (path.match(/.hdr$/)) {
                    texture = new Texture2D({
                        width : 0,
                        height : 0
                    });
                    textureUtil._fetchTexture(
                        path,
                        function (data) {
                            hdr.parseRGBE(data, texture);
                            texture.dirty();
                            onsuccess && onsuccess(texture);
                        },
                        onerror
                    );
                    return texture;
                } else if (path.match(/.dds$/)) {
                    texture = new Texture2D({
                        width : 0,
                        height : 0
                    });
                    textureUtil._fetchTexture(
                        path,
                        function (data) {
                            dds.parse(data, texture);
                            texture.dirty();
                            onsuccess && onsuccess(texture);
                        },
                        onerror
                    );
                } else {
                    texture = new Texture2D();
                    texture.load(path);
                    texture.success(onsuccess);
                    texture.error(onerror);
                }
            } else if (typeof(path) == 'object' && typeof(path.px) !== 'undefined') {
                var texture = new TextureCube();
                texture.load(path);
                texture.success(onsuccess);
                texture.error(onerror);
            }
            return texture;
        },

        loadPanorama : function(path, cubeMap, renderer, onsuccess, onerror) {
            var self = this;
            textureUtil.loadTexture(path, function(texture) {
                // PENDING 
                texture.flipY = false;
                self.panoramaToCubeMap(texture, cubeMap, renderer);
                texture.dispose(renderer.gl);
                onsuccess && onsuccess(cubeMap);
            }, onerror);
        },

        panoramaToCubeMap : function(panoramaMap, cubeMap, renderer) {
            var skydome = new Skydome({
                scene : new Scene
            });
            skydome.material.set('diffuseMap', panoramaMap);
            environmentMapPass.texture = cubeMap;
            environmentMapPass.render(renderer, skydome.scene);
            environmentMapPass.texture = null;
            return cubeMap;
        },

        _fetchTexture : function(path, onsuccess, onerror) {
            request.get({
                url : path,
                responseType : 'arraybuffer',
                onload : onsuccess,
                onerror : onerror
            });
        },

        createChessboard : function(size, unitSize, color1, color2) {
            size = size || 512;
            unitSize = unitSize || 64;
            color1 = color1 || 'black';
            color2 = color2 || 'white';

            var repeat = Math.ceil(size / unitSize);

            var canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            var ctx = canvas.getContext('2d');
            ctx.fillStyle = color2;
            ctx.fillRect(0, 0, size, size);

            ctx.fillStyle = color1;
            for (var i = 0; i < repeat; i++) {
                for (var j = 0; j < repeat; j++) {
                    var isFill = j % 2 ? (i % 2) : (i % 2 - 1);
                    if (isFill) {
                        ctx.fillRect(i * unitSize, j * unitSize, unitSize, unitSize);
                    }
                }
            }

            var texture = new Texture2D({
                image : canvas,
                anisotropic : 8
            });

            return texture;
        },

        createBlank : function(color) {
            var canvas = document.createElement('canvas');
            canvas.width = 1;
            canvas.height = 1;
            var ctx = canvas.getContext('2d');
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, 1, 1);

            var texture = new Texture2D({
                image : canvas
            });

            return texture;
        }
    }

    return textureUtil;
});
/** @namespace qtek */
/** @namespace qtek.math */
/** @namespace qtek.animation */
/** @namespace qtek.async */
/** @namespace qtek.camera */
/** @namespace qtek.compositor */
/** @namespace qtek.core */
/** @namespace qtek.geometry */
/** @namespace qtek.helper */
/** @namespace qtek.light */
/** @namespace qtek.loader */
/** @namespace qtek.particleSystem */
/** @namespace qtek.picking */
/** @namespace qtek.plugin */
/** @namespace qtek.prePass */
/** @namespace qtek.shader */
/** @namespace qtek.texture */
/** @namespace qtek.util */
define('qtek/qtek',['require','qtek/Camera','qtek/DynamicGeometry','qtek/FrameBuffer','qtek/Geometry','qtek/Joint','qtek/Layer','qtek/Light','qtek/Material','qtek/Mesh','qtek/Node','qtek/Renderable','qtek/Renderer','qtek/Scene','qtek/Shader','qtek/Skeleton','qtek/Stage','qtek/StaticGeometry','qtek/Texture','qtek/animation/Animation','qtek/animation/Blend1DClip','qtek/animation/Blend2DClip','qtek/animation/Clip','qtek/animation/SamplerClip','qtek/animation/SkinningClip','qtek/animation/TransformClip','qtek/animation/easing','qtek/async/Task','qtek/async/TaskGroup','qtek/camera/Orthographic','qtek/camera/Perspective','qtek/compositor/Compositor','qtek/compositor/Graph','qtek/compositor/Node','qtek/compositor/Pass','qtek/compositor/SceneNode','qtek/compositor/TextureNode','qtek/compositor/texturePool','qtek/core/Base','qtek/core/Cache','qtek/core/Event','qtek/core/LRU','qtek/core/LinkedList','qtek/core/glenum','qtek/core/glinfo','qtek/core/mixin/derive','qtek/core/mixin/notifier','qtek/core/request','qtek/core/util','qtek/deferred/Renderer','qtek/deferred/StandardMaterial','qtek/geometry/Capsule','qtek/geometry/Cone','qtek/geometry/Cube','qtek/geometry/Cylinder','qtek/geometry/Plane','qtek/geometry/Sphere','qtek/light/Ambient','qtek/light/Directional','qtek/light/Point','qtek/light/Spot','qtek/loader/FX','qtek/loader/GLTF','qtek/loader/ThreeModel','qtek/math/BoundingBox','qtek/math/Frustum','qtek/math/Matrix2','qtek/math/Matrix2d','qtek/math/Matrix3','qtek/math/Matrix4','qtek/math/Plane','qtek/math/Quaternion','qtek/math/Ray','qtek/math/Value','qtek/math/Vector2','qtek/math/Vector3','qtek/math/Vector4','qtek/particleSystem/Emitter','qtek/particleSystem/ForceField','qtek/particleSystem/Particle','qtek/particleSystem/ParticleSystem','qtek/picking/Pixel','qtek/plugin/FirstPersonControl','qtek/plugin/InfinitePlane','qtek/plugin/OrbitControl','qtek/plugin/Skybox','qtek/plugin/Skydome','qtek/prePass/EnvironmentMap','qtek/prePass/Reflection','qtek/prePass/ShadowMap','qtek/shader/library','qtek/texture/Texture2D','qtek/texture/TextureCube','qtek/util/dds','qtek/util/delaunay','qtek/util/hdr','qtek/util/mesh','qtek/util/texture','glmatrix'], function(require){
	
	var exportsObject =  {
	"Camera": require('qtek/Camera'),
	"DynamicGeometry": require('qtek/DynamicGeometry'),
	"FrameBuffer": require('qtek/FrameBuffer'),
	"Geometry": require('qtek/Geometry'),
	"Joint": require('qtek/Joint'),
	"Layer": require('qtek/Layer'),
	"Light": require('qtek/Light'),
	"Material": require('qtek/Material'),
	"Mesh": require('qtek/Mesh'),
	"Node": require('qtek/Node'),
	"Renderable": require('qtek/Renderable'),
	"Renderer": require('qtek/Renderer'),
	"Scene": require('qtek/Scene'),
	"Shader": require('qtek/Shader'),
	"Skeleton": require('qtek/Skeleton'),
	"Stage": require('qtek/Stage'),
	"StaticGeometry": require('qtek/StaticGeometry'),
	"Texture": require('qtek/Texture'),
	"animation": {
		"Animation": require('qtek/animation/Animation'),
		"Blend1DClip": require('qtek/animation/Blend1DClip'),
		"Blend2DClip": require('qtek/animation/Blend2DClip'),
		"Clip": require('qtek/animation/Clip'),
		"SamplerClip": require('qtek/animation/SamplerClip'),
		"SkinningClip": require('qtek/animation/SkinningClip'),
		"TransformClip": require('qtek/animation/TransformClip'),
		"easing": require('qtek/animation/easing')
	},
	"async": {
		"Task": require('qtek/async/Task'),
		"TaskGroup": require('qtek/async/TaskGroup')
	},
	"camera": {
		"Orthographic": require('qtek/camera/Orthographic'),
		"Perspective": require('qtek/camera/Perspective')
	},
	"compositor": {
		"Compositor": require('qtek/compositor/Compositor'),
		"Graph": require('qtek/compositor/Graph'),
		"Node": require('qtek/compositor/Node'),
		"Pass": require('qtek/compositor/Pass'),
		"SceneNode": require('qtek/compositor/SceneNode'),
		"TextureNode": require('qtek/compositor/TextureNode'),
		"texturePool": require('qtek/compositor/texturePool')
	},
	"core": {
		"Base": require('qtek/core/Base'),
		"Cache": require('qtek/core/Cache'),
		"Event": require('qtek/core/Event'),
		"LRU": require('qtek/core/LRU'),
		"LinkedList": require('qtek/core/LinkedList'),
		"glenum": require('qtek/core/glenum'),
		"glinfo": require('qtek/core/glinfo'),
		"mixin": {
			"derive": require('qtek/core/mixin/derive'),
			"notifier": require('qtek/core/mixin/notifier')
		},
		"request": require('qtek/core/request'),
		"util": require('qtek/core/util')
	},
	"deferred": {
		"Renderer": require('qtek/deferred/Renderer'),
		"StandardMaterial": require('qtek/deferred/StandardMaterial')
	},
	"geometry": {
		"Capsule": require('qtek/geometry/Capsule'),
		"Cone": require('qtek/geometry/Cone'),
		"Cube": require('qtek/geometry/Cube'),
		"Cylinder": require('qtek/geometry/Cylinder'),
		"Plane": require('qtek/geometry/Plane'),
		"Sphere": require('qtek/geometry/Sphere')
	},
	"light": {
		"Ambient": require('qtek/light/Ambient'),
		"Directional": require('qtek/light/Directional'),
		"Point": require('qtek/light/Point'),
		"Spot": require('qtek/light/Spot')
	},
	"loader": {
		"FX": require('qtek/loader/FX'),
		"GLTF": require('qtek/loader/GLTF'),
		"ThreeModel": require('qtek/loader/ThreeModel')
	},
	"math": {
		"BoundingBox": require('qtek/math/BoundingBox'),
		"Frustum": require('qtek/math/Frustum'),
		"Matrix2": require('qtek/math/Matrix2'),
		"Matrix2d": require('qtek/math/Matrix2d'),
		"Matrix3": require('qtek/math/Matrix3'),
		"Matrix4": require('qtek/math/Matrix4'),
		"Plane": require('qtek/math/Plane'),
		"Quaternion": require('qtek/math/Quaternion'),
		"Ray": require('qtek/math/Ray'),
		"Value": require('qtek/math/Value'),
		"Vector2": require('qtek/math/Vector2'),
		"Vector3": require('qtek/math/Vector3'),
		"Vector4": require('qtek/math/Vector4')
	},
	"particleSystem": {
		"Emitter": require('qtek/particleSystem/Emitter'),
		"ForceField": require('qtek/particleSystem/ForceField'),
		"Particle": require('qtek/particleSystem/Particle'),
		"ParticleSystem": require('qtek/particleSystem/ParticleSystem')
	},
	"picking": {
		"Pixel": require('qtek/picking/Pixel')
	},
	"plugin": {
		"FirstPersonControl": require('qtek/plugin/FirstPersonControl'),
		"InfinitePlane": require('qtek/plugin/InfinitePlane'),
		"OrbitControl": require('qtek/plugin/OrbitControl'),
		"Skybox": require('qtek/plugin/Skybox'),
		"Skydome": require('qtek/plugin/Skydome')
	},
	"prePass": {
		"EnvironmentMap": require('qtek/prePass/EnvironmentMap'),
		"Reflection": require('qtek/prePass/Reflection'),
		"ShadowMap": require('qtek/prePass/ShadowMap')
	},
	"shader": {
		"library": require('qtek/shader/library')
	},
	"texture": {
		"Texture2D": require('qtek/texture/Texture2D'),
		"TextureCube": require('qtek/texture/TextureCube')
	},
	"util": {
		"dds": require('qtek/util/dds'),
		"delaunay": require('qtek/util/delaunay'),
		"hdr": require('qtek/util/hdr'),
		"mesh": require('qtek/util/mesh'),
		"texture": require('qtek/util/texture')
	}
};

    var glMatrix = require('glmatrix');
    exportsObject.glMatrix = glMatrix;
    
    return exportsObject;
});
define('qtek', ['qtek/qtek'], function (main) { return main; });

var qtek = require("qtek");

for(var name in qtek){
	_exports[name] = qtek[name];
}

});
define('worldcup-high/cubeGeo',['require','qtek'],function(require) {
    
    var qtek = require('qtek');

    var data = {"position":[0.6500003933906555,0.9999995827674866,0.6499999761581421,0.6500000953674316,1,-0.6499999761581421,-0.6499999165534973,1,0.6499999761581421,0.6499999165534973,-1,-0.6499999761581421,0.6499994993209839,-1,0.6499999761581421,-0.6500002145767212,-1,-0.6499999761581421,-1,-0.6499997973442078,-0.6499999761581421,-1,-0.6499996185302734,0.6499999761581421,-0.9999998211860657,0.650000274181366,-0.6499999761581421,0.6500002145767212,0.6499996185302734,1,-0.6499999761581421,0.6499999165534973,1,0.6499996185302734,-0.650000274181366,1,1,0.6499999165534973,-0.6499999761581421,1,0.6499996185302734,0.6499999761581421,1,-0.6500000953674316,-0.6499999761581421,0.8250002264976501,0.9531087875366211,-0.6499999761581421,0.8218590021133423,0.9296633005142212,-0.8218588829040527,0.9531090259552002,0.8249999284744263,-0.6499999761581421,0.9531087875366211,0.6499999761581421,-0.824999988079071,0.9296634197235107,0.821858823299408,-0.8218588829040527,0.8249999284744263,0.6499999761581421,-0.9531089067459106,0.6499999761581421,0.6499999761581421,-1,0.6499999761581421,0.824999988079071,-0.9531089067459106,0.8218590021133423,0.821858823299408,-0.9296633005142212,0.6500000953674316,0.9531089067459106,-0.824999988079071,0.6499999761581421,-0.6499999165534973,-1,0.824999988079071,-0.6499999165534973,-0.9531089067459106,0.821858823299408,-0.8218588829040527,-0.9296633005142212,0.9531089067459106,-0.6499999761581421,-0.824999988079071,0.9531087875366211,-0.8250001072883606,-0.6499999761581421,0.9296633005142212,-0.8218588829040527,-0.8218588829040527,0.8249999284744263,-0.9531090259552002,-0.6499999761581421,0.6499999165534973,-0.9531087875366211,-0.824999988079071,0.8218588829040527,-0.9296633005142212,-0.8218588829040527,0.6499999761581421,-0.8249999284744263,-0.9531089067459106,-0.6499999761581421,-0.6499999165534973,-1,-0.6500000953674316,-0.8249999284744263,-0.9531089067459106,-0.8218590021133423,-0.821858823299408,-0.9296633005142212,-0.6500002145767212,-0.9531089067459106,-0.824999988079071,-0.8250001072883606,-0.9531087279319763,-0.6499999761581421,-0.8218590021133423,-0.9296633005142212,-0.8218588829040527,-0.9531089067459106,-0.8249998092651367,-0.6499999761581421,-0.9531089067459106,-0.6499999165534973,-0.824999988079071,-0.9296634197235107,-0.8218587040901184,-0.8218588829040527,-0.8250001072883606,-0.6499999165534973,-0.9531089067459106,-0.9531086087226868,0.8250002264976501,-0.6499999761581421,-0.9296631217002869,0.8218591213226318,-0.8218588829040527,-0.8249995708465576,0.9531090259552002,-0.6499999761581421,-0.6499996781349182,1,-0.6499999761581421,-0.6499996781349182,0.9531090259552002,-0.824999988079071,-0.8218585252761841,0.9296634793281555,-0.8218588829040527,-0.6499997973442078,0.8250002264976501,-0.9531089067459106,-0.6499996781349182,0.650000274181366,-1,-0.8249998092651367,0.650000274181366,-0.9531089067459106,-0.8218587040901184,0.8218591213226318,-0.9296633005142212,-0.9531087279319763,0.650000274181366,-0.824999988079071,0.9531092047691345,0.8249995112419128,0.6499999761581421,0.9296637177467346,0.8218584060668945,0.8218588829040527,0.8250002861022949,0.9531083703041077,0.6499999761581421,0.6500005125999451,0.9531083703041077,0.824999988079071,0.8218593001365662,0.929662823677063,0.8218588829040527,0.650000274181366,0.8249995112419128,0.9531089067459106,0.8250002264976501,0.6499996185302734,0.9531089067459106,0.8218591809272766,0.8218584060668945,0.9296633005142212,0.9531092047691345,0.6499996185302734,0.824999988079071,0.6499994993209839,-0.8250004053115845,0.9531089067459106,0.8218584060668945,-0.8218593001365662,0.9296633005142212,0.6499993801116943,-0.9531093835830688,0.824999988079071,0.8249995708465576,-0.9531093835830688,0.6499999761581421,0.8218584060668945,-0.9296637773513794,0.8218588829040527,0.9531084895133972,-0.825000524520874,0.6499999761581421,0.9999995827674866,-0.6500005125999451,0.6499999761581421,0.9531083703041077,-0.6500005125999451,0.824999988079071,0.929662823677063,-0.8218594193458557,0.8218588829040527,0.8249995708465576,-0.6500005125999451,0.9531089067459106,-0.6500002145767212,-0.6499997973442078,1,-0.8250002264976501,-0.6499996781349182,0.9531089067459106,-0.8218591213226318,-0.8218587040901184,0.9296633005142212,-0.9531092047691345,-0.6499996781349182,0.824999988079071,-0.9531093239784241,-0.8249995708465576,0.6499999761581421,-0.9296637177467346,-0.8218585848808289,0.8218588829040527,-0.8250004053115845,-0.9531086087226868,0.6499999761581421,-0.650000274181366,-0.9999998211860657,0.6499999761581421,-0.6500002145767212,-0.9531087279319763,0.824999988079071,-0.8218593001365662,-0.9296631217002869,0.8218588829040527,-0.6500002145767212,-0.8249998092651367,0.9531089067459106,-0.8249999284744263,0.9531090259552002,0.6499999761581421,-0.821858823299408,0.9296633005142212,0.8218588829040527,-0.9531087875366211,0.8250001072883606,0.6499999761581421,-0.9296633005142212,0.8218588829040527,0.8218588829040527,-1,0.6499999761581421,0.6499999761581421,-0.9531089067459106,0.6499999761581421,0.824999988079071,-0.824999988079071,0.6499999165534973,0.9531089067459106,-0.6499999761581421,0.8249999284744263,0.9531089067459106,-0.821858823299408,0.821858823299408,0.9296633005142212,-0.6499999165534973,0.9531089067459106,0.824999988079071],"normal":[0.11450540274381638,0.9867854714393616,0.11450540274381638,0.11450540274381638,0.9867854714393616,-0.11450540274381638,-0.11450540274381638,0.9867854714393616,0.11450540274381638,0.11450540274381638,-0.9867854714393616,-0.11450540274381638,0.11450540274381638,-0.9867854714393616,0.11450540274381638,-0.11450540274381638,-0.9867854714393616,-0.11450540274381638,-0.9867854714393616,-0.11450540274381638,-0.11450540274381638,-0.9867854714393616,-0.11450540274381638,0.11450540274381638,-0.9867854714393616,0.11450540274381638,-0.11450540274381638,0.11450540274381638,0.11450540274381638,0.9867854714393616,-0.11450540274381638,0.11450540274381638,0.9867854714393616,0.11450540274381638,-0.11450540274381638,0.9867854714393616,0.9867854714393616,0.11450540274381638,-0.11450540274381638,0.9867854714393616,0.11450540274381638,0.11450540274381638,0.9867854714393616,-0.11450540274381638,-0.11450540274381638,0.4823755919933319,0.8723105788230896,-0.07950066775083542,0.4120608866214752,0.8126469254493713,-0.4120608866214752,0.8723105788230896,0.4823755919933319,-0.07950066775083542,0.8723105788230896,0.07950066775083542,-0.4823755919933319,0.8126469254493713,0.4120608866214752,-0.4120608866214752,0.4823755919933319,0.07950066775083542,-0.8723105788230896,0.11450540274381638,0.11450540274381638,-0.9867854714393616,0.07950066775083542,0.4823755919933319,-0.8723105788230896,0.4120608866214752,0.4120608866214752,-0.8126469254493713,0.07950066775083542,0.8723105788230896,-0.4823755919933319,0.11450540274381638,-0.11450540274381638,-0.9867854714393616,0.4823755919933319,-0.07950066775083542,-0.8723105788230896,0.4120608866214752,-0.4120608866214752,-0.8126469254493713,0.8723105788230896,-0.07950066775083542,-0.4823755919933319,0.8723105788230896,-0.4823755919933319,-0.07950066775083542,0.8126469254493713,-0.4120608866214752,-0.4120608866214752,0.4823755919933319,-0.8723105788230896,-0.07950066775083542,0.07950066775083542,-0.8723105788230896,-0.4823755919933319,0.4120608866214752,-0.8126469254493713,-0.4120608866214752,0.07950066775083542,-0.4823755919933319,-0.8723105788230896,-0.11450540274381638,-0.11450540274381638,-0.9867854714393616,-0.07950066775083542,-0.4823755919933319,-0.8723105788230896,-0.4120608866214752,-0.4120608866214752,-0.8126469254493713,-0.07950066775083542,-0.8723105788230896,-0.4823755919933319,-0.4823755919933319,-0.8723105788230896,-0.07950066775083542,-0.4120608866214752,-0.8126469254493713,-0.4120608866214752,-0.8723105788230896,-0.4823755919933319,-0.07950066775083542,-0.8723105788230896,-0.07950066775083542,-0.4823755919933319,-0.8126469254493713,-0.4120608866214752,-0.4120608866214752,-0.4823755919933319,-0.07950066775083542,-0.8723105788230896,-0.8723105788230896,0.4823755919933319,-0.07950066775083542,-0.8126469254493713,0.4120608866214752,-0.4120608866214752,-0.4823755919933319,0.8723105788230896,-0.07950066775083542,-0.11450540274381638,0.9867854714393616,-0.11450540274381638,-0.07950066775083542,0.8723105788230896,-0.4823755919933319,-0.4120608866214752,0.8126469254493713,-0.4120608866214752,-0.07950066775083542,0.4823755919933319,-0.8723105788230896,-0.11450540274381638,0.11450540274381638,-0.9867854714393616,-0.4823755919933319,0.07950066775083542,-0.8723105788230896,-0.4120608866214752,0.4120608866214752,-0.8126469254493713,-0.8723105788230896,0.07950066775083542,-0.4823755919933319,0.8723105788230896,0.4823755919933319,0.07950066775083542,0.8126469254493713,0.4120608866214752,0.4120608866214752,0.4823755919933319,0.8723105788230896,0.07950066775083542,0.07950066775083542,0.8723105788230896,0.4823755919933319,0.4120608866214752,0.8126469254493713,0.4120608866214752,0.07950066775083542,0.4823755919933319,0.8723105788230896,0.4823755919933319,0.07950066775083542,0.8723105788230896,0.4120608866214752,0.4120608866214752,0.8126469254493713,0.8723105788230896,0.07950066775083542,0.4823755919933319,0.07950066775083542,-0.4823755919933319,0.8723105788230896,0.4120608866214752,-0.4120608866214752,0.8126469254493713,0.07950066775083542,-0.8723105788230896,0.4823755919933319,0.4823755919933319,-0.8723105788230896,0.07950066775083542,0.4120608866214752,-0.8126469254493713,0.4120608866214752,0.8723105788230896,-0.4823755919933319,0.07950066775083542,0.9867854714393616,-0.11450540274381638,0.11450540274381638,0.8723105788230896,-0.07950066775083542,0.4823755919933319,0.8126469254493713,-0.4120608866214752,0.4120608866214752,0.4823755919933319,-0.07950066775083542,0.8723105788230896,-0.11450540274381638,-0.11450540274381638,0.9867854714393616,-0.4823755919933319,-0.07950066775083542,0.8723105788230896,-0.4120608866214752,-0.4120608866214752,0.8126469254493713,-0.8723105788230896,-0.07950066775083542,0.4823755919933319,-0.8723105788230896,-0.4823755919933319,0.07950066775083542,-0.8126469254493713,-0.4120608866214752,0.4120608866214752,-0.4823755919933319,-0.8723105788230896,0.07950066775083542,-0.11450540274381638,-0.9867854714393616,0.11450540274381638,-0.07950066775083542,-0.8723105788230896,0.4823755919933319,-0.4120608866214752,-0.8126469254493713,0.4120608866214752,-0.07950066775083542,-0.4823755919933319,0.8723105788230896,-0.4823755919933319,0.8723105788230896,0.07950066775083542,-0.4120608866214752,0.8126469254493713,0.4120608866214752,-0.8723105788230896,0.4823755919933319,0.07950066775083542,-0.8126469254493713,0.4120608866214752,0.4120608866214752,-0.9867854714393616,0.11450540274381638,0.11450540274381638,-0.8723105788230896,0.07950066775083542,0.4823755919933319,-0.4823755919933319,0.07950066775083542,0.8723105788230896,-0.07950066775083542,0.4823755919933319,0.8723105788230896,-0.4120608866214752,0.4120608866214752,0.8126469254493713,-0.07950066775083542,0.8723105788230896,0.4823755919933319],"faces":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,1,15,16,15,17,16,12,18,19,18,20,19,21,22,23,22,24,23,16,19,23,25,26,27,26,28,27,14,29,30,29,31,30,3,32,33,32,34,33,27,30,33,35,36,37,36,38,37,5,39,40,39,41,40,6,42,43,42,44,43,37,40,43,8,45,46,45,47,46,48,49,50,49,51,50,52,53,54,53,55,54,46,50,54,13,56,57,56,58,57,0,59,60,59,61,60,9,62,63,62,64,63,57,60,63,11,65,66,65,67,66,4,68,69,68,70,69,71,72,73,72,74,73,66,69,73,75,76,77,76,78,77,7,79,80,79,81,80,82,83,84,83,85,84,77,80,84,2,86,87,86,88,89,90,91,89,91,92,89,10,93,94,93,95,94,87,89,94,12,14,18,18,28,20,20,26,21,21,52,22,22,51,24,24,49,1,1,0,15,15,58,17,17,56,12,3,5,32,32,38,34,34,36,25,14,71,29,29,70,31,31,68,3,6,8,42,42,55,44,44,53,35,5,82,39,39,81,41,41,79,6,8,90,45,45,88,47,47,86,48,9,11,62,62,74,64,64,72,13,0,2,59,59,95,61,61,93,9,11,75,65,65,85,67,67,83,4,75,10,76,76,92,78,78,91,7,21,25,52,1,48,2,4,82,5,7,90,8,10,75,11,13,71,14,24,1,16,17,19,16,17,12,19,20,23,19,20,21,23,24,16,23,34,25,27,28,30,27,28,14,30,31,33,30,31,3,33,34,27,33,44,35,37,38,40,37,38,5,40,41,43,40,41,6,43,44,37,43,55,8,46,47,50,46,47,48,50,51,54,50,51,52,54,55,46,54,64,13,57,58,60,57,58,0,60,61,63,60,61,9,63,64,57,63,74,11,66,67,69,66,67,4,69,70,73,69,70,71,73,74,66,73,85,75,77,78,80,77,78,7,80,81,84,80,81,82,84,85,77,84,95,2,87,87,86,89,88,90,89,92,94,89,92,10,94,95,87,94,14,28,18,28,26,20,26,25,21,52,51,22,51,49,24,49,48,1,0,58,15,58,56,17,56,13,12,5,38,32,38,36,34,36,35,25,71,70,29,70,68,31,68,4,3,8,55,42,55,53,44,53,52,35,82,81,39,81,79,41,79,7,6,90,88,45,88,86,47,86,2,48,11,74,62,74,72,64,72,71,13,2,95,59,95,93,61,93,10,9,75,85,65,85,83,67,83,82,4,10,92,76,92,91,78,91,90,7,25,35,52]};

    var cubeGeo;

    return {
        get: function() {
            if (!cubeGeo) {
                cubeGeo = new qtek.StaticGeometry();
                cubeGeo.attributes.position.value = new Float32Array(data.position);
                cubeGeo.attributes.normal.value = new Float32Array(data.normal);
                cubeGeo.faces = new Uint16Array(data.faces);
            }
            return cubeGeo;
        }
    }
});
var OIMO={REVISION:"DEV.1.1.1a",SHAPE_SPHERE:1,SHAPE_BOX:2,WORLD_SCALE:100,INV_SCALE:0.01};OIMO.TO_RAD=Math.PI/180;OIMO.nextID=0;var OIMO_ARRAY_TYPE;OIMO_ARRAY_TYPE||(OIMO_ARRAY_TYPE="undefined"!==typeof Float32Array?Float32Array:Array);OIMO.World=function(a,c,b){this.timeStep=a||1/60;this.numIterations=b||8;this.rigidBodies=null;this.numRigidBodies=0;this.unusedContacts=this.contacts=null;this.numContactPoints=this.numContacts=0;this.joints=null;this.numIslands=this.numJoints=0;switch(c||2){case 1:this.broadPhase=new OIMO.BruteForceBroadPhase;break;default:this.broadPhase=new OIMO.SAPBroadPhase;break;case 3:this.broadPhase=new OIMO.DBVTBroadPhase}this.gravity=new OIMO.Vec3(0,-9.80665,0);this.performance=new OIMO.Performance;this.detectors=
[];for(a=this.detectors.length=3;a--;)this.detectors[a]=[],this.detectors[a].length=3;this.detectors[OIMO.SHAPE_SPHERE][OIMO.SHAPE_SPHERE]=new OIMO.SphereSphereCollisionDetector;this.detectors[OIMO.SHAPE_SPHERE][OIMO.SHAPE_BOX]=new OIMO.SphereBoxCollisionDetector(!1);this.detectors[OIMO.SHAPE_BOX][OIMO.SHAPE_SPHERE]=new OIMO.SphereBoxCollisionDetector(!0);this.detectors[OIMO.SHAPE_BOX][OIMO.SHAPE_BOX]=new OIMO.BoxBoxCollisionDetector;this.randX=65535;this.randA=98765;this.randB=123456789;this.maxIslandRigidBodies=
64;this.islandRigidBodies=[];this.islandRigidBodies.length=this.maxIslandRigidBodies;this.islandStack=[];this.islandStack.length=this.maxIslandRigidBodies;this.maxIslandConstraints=128;this.islandConstraints=[];this.islandConstraints.length=this.maxIslandConstraints;this.enableRandomizer=!0};
OIMO.World.prototype={constructor:OIMO.World,clear:function(){for(this.randX=65535;null!==this.joints;)this.removeJoint(this.joints);for(;null!==this.contacts;)this.removeContact(this.contacts);for(;null!==this.rigidBodies;)this.removeRigidBody(this.rigidBodies);OIMO.nextID=0},addRigidBody:function(a){if(a.parent)throw Error("It is not possible to be added to more than one world one of the rigid body");a.parent=this;a.awake();for(var c=a.shapes;null!==c;c=c.next)this.addShape(c);null!==this.rigidBodies&&
((this.rigidBodies.prev=a).next=this.rigidBodies);this.rigidBodies=a;this.numRigidBodies++},removeRigidBody:function(a){if(a.parent===this){a.awake();for(var c=a.jointLink;null!=c;){var b=c.joint,c=c.next;this.removeJoint(b)}for(c=a.shapes;null!==c;c=c.next)this.removeShape(c);c=a.prev;b=a.next;null!==c&&(c.next=b);null!==b&&(b.prev=c);this.rigidBodies===a&&(this.rigidBodies=b);a.prev=null;a.next=null;a.parent=null;this.numRigidBodies--}},getByName:function(a){for(var c=null,b=this.rigidBodies;null!==
b;)""!==b.name&&b.name===a&&(c=b),b=b.next;for(b=this.joints;null!==b;)""!==b.name&&b.name===a&&(c=b),b=b.next;return c},addShape:function(a){if(!a.parent||!a.parent.parent)throw Error("It is not possible to be added alone to shape world");a.proxy=this.broadPhase.createProxy(a);a.updateProxy();this.broadPhase.addProxy(a.proxy)},removeShape:function(a){this.broadPhase.removeProxy(a.proxy);a.proxy=null},addJoint:function(a){if(a.parent)throw Error("It is not possible to be added to more than one world one of the joint");
null!=this.joints&&((this.joints.prev=a).next=this.joints);this.joints=a;a.parent=this;this.numJoints++;a.awake();a.attach()},removeJoint:function(a){var c=a.prev,b=a.next;null!==c&&(c.next=b);null!==b&&(b.prev=c);this.joints==a&&(this.joints=b);a.prev=null;a.next=null;this.numJoints--;a.awake();a.detach();a.parent=null},step:function(){for(var a=Date.now(),c=this.rigidBodies;null!==c;)c.addedToIsland=!1,c.sleeping&&(c.linearVelocity.testZero()||c.position.testDiff(c.sleepPosition)||c.orientation.testDiff(c.sleepOrientation))&&
c.awake(),c=c.next;this.updateContacts();this.solveIslands();c=Date.now();c-1E3>this.performance.time_prev&&(this.performance.time_prev=c,this.performance.fpsint=this.performance.fps,this.performance.fps=0);this.performance.fps++;this.performance.totalTime=c-a;this.performance.updatingTime=this.performance.totalTime-(this.performance.broadPhaseTime+this.performance.narrowPhaseTime+this.performance.solvingTime)},updateContacts:function(){var a=Date.now();this.broadPhase.detectPairs();for(var c=this.broadPhase.pairs,
b=this.broadPhase.numPairs;b--;){var d=c[b],e,f;d.shape1.id<d.shape2.id?(e=d.shape1,f=d.shape2):(e=d.shape2,f=d.shape1);var g;g=e.numContacts<f.numContacts?e.contactLink:f.contactLink;for(var h=!1;g;){d=g.contact;if(d.shape1==e&&d.shape2==f){h=d.persisting=!0;break}g=g.next}h||this.addContact(e,f)}c=Date.now();this.performance.broadPhaseTime=c-a;this.numContactPoints=0;for(d=this.contacts;null!==d;){if(!d.persisting&&(a=d.shape1.aabb,b=d.shape2.aabb,a.minX>b.maxX||a.maxX<b.minX||a.minY>b.maxY||a.maxY<
b.minY||a.minZ>b.maxZ||a.maxZ<b.minZ)){a=d.next;this.removeContact(d);d=a;continue}a=d.body1;b=d.body2;(a.isDynamic&&!a.sleeping||b.isDynamic&&!b.sleeping)&&d.updateManifold();this.numContactPoints+=d.manifold.numPoints;d.persisting=!1;d.constraint.addedToIsland=!1;d=d.next}d=Date.now();this.performance.narrowPhaseTime=d-c},addContact:function(a,c){var b;null!==this.unusedContacts?(b=this.unusedContacts,this.unusedContacts=this.unusedContacts.next):b=new OIMO.Contact;b.attach(a,c);b.detector=this.detectors[a.type][c.type];
this.contacts&&((this.contacts.prev=b).next=this.contacts);this.contacts=b;this.numContacts++},removeContact:function(a){var c=a.prev,b=a.next;b&&(b.prev=c);c&&(c.next=b);this.contacts==a&&(this.contacts=b);a.prev=null;a.next=null;a.detach();a.next=this.unusedContacts;this.unusedContacts=a;this.numContacts--},calSleep:function(a){return!a.allowSleep||0.04<a.linearVelocity.len()||0.25<a.angularVelocity.len()?!1:!0},solveIslands:function(){var a=1/this.timeStep,c,b,d;for(b=this.joints;null!==b;b=b.next)b.addedToIsland=
!1;this.maxIslandRigidBodies<this.numRigidBodies&&(this.maxIslandRigidBodies=2*this.numRigidBodies,this.islandRigidBodies=[],this.islandStack=[],this.islandRigidBodies.length=this.maxIslandRigidBodies,this.islandStack.length=this.maxIslandRigidBodies);b=this.numJoints+this.numContacts;this.maxIslandConstraints<b&&(this.maxIslandConstraints=2*b,this.islandConstraints=[],this.islandConstraints.length=this.maxIslandConstraints);b=Date.now();this.numIslands=0;for(var e=this.rigidBodies;null!==e;e=e.next)if(!(e.addedToIsland||
e.isStatic||e.sleeping)){if(e.isLonely())e.isDynamic&&e.linearVelocity.addTime(this.gravity,this.timeStep),this.calSleep(e)?(e.sleepTime+=this.timeStep,0.5<e.sleepTime?e.sleep():e.updatePosition(this.timeStep)):(e.sleepTime=0,e.updatePosition(this.timeStep));else{var f=0,g=0,h=1;this.islandStack[0]=e;e.addedToIsland=!0;do if(c=this.islandStack[--h],this.islandStack[h]=null,c.sleeping=!1,this.islandRigidBodies[f++]=c,!c.isStatic){for(var k=c.contactLink;null!==k;k=k.next){var l=k.contact;d=l.constraint;
!d.addedToIsland&&l.touching&&(this.islandConstraints[g++]=d,d.addedToIsland=!0,d=k.body,d.addedToIsland||(this.islandStack[h++]=d,d.addedToIsland=!0))}for(c=c.jointLink;null!==c;c=c.next)d=c.joint,d.addedToIsland||(this.islandConstraints[g++]=d,d.addedToIsland=!0,d=c.body,!d.addedToIsland&&d.isDynamic&&(this.islandStack[h++]=d,d.addedToIsland=!0))}while(0!=h);d=(new OIMO.Vec3).addTime(this.gravity,this.timeStep);for(h=f;h--;)c=this.islandRigidBodies[h],c.isDynamic&&c.linearVelocity.addEqual(d);if(this.enableRandomizer)for(h=
g;h--;)0!==h&&(c=(this.randX=this.randX*this.randA+this.randB&2147483647)/2147483648*h|0,d=this.islandConstraints[h],this.islandConstraints[h]=this.islandConstraints[c],this.islandConstraints[c]=d);for(h=g;h--;)this.islandConstraints[h].preSolve(this.timeStep,a);for(c=this.numIterations;c--;)for(h=g;h--;)this.islandConstraints[h].solve();for(h=g;h--;)this.islandConstraints[h].postSolve(),this.islandConstraints[h]=null;g=10;for(h=f;h--;)c=this.islandRigidBodies[h],this.calSleep(c)?(c.sleepTime+=this.timeStep,
c.sleepTime<g&&(g=c.sleepTime)):g=c.sleepTime=0;if(0.5<g)for(h=f;h--;)this.islandRigidBodies[h].sleep(),this.islandRigidBodies[h]=null;else for(h=f;h--;)this.islandRigidBodies[h].updatePosition(this.timeStep),this.islandRigidBodies[h]=null}this.numIslands++}a=Date.now();this.performance.solvingTime=a-b}};OIMO.RigidBody=function(a,c,b,d,e,f,g){d=d||0;e=e||0;f=f||0;g=g||0;a=a||0;c=c||0;b=b||0;this.name="";this.BODY_DYNAMIC=1;this.BODY_STATIC=2;this.MAX_SHAPES=64;this.next=this.prev=null;this.type=0;this.isStatic=this.isDynamic=!1;this.position=null;this.inverseMass=this.mass=NaN;this.shapes=null;this.numShapes=0;this.contactLink=this.parent=null;this.numContacts=0;this.jointLink=null;this.numJoints=0;this.sleeping=this.addedToIsland=!1;this.massInfo=new OIMO.MassInfo;this.position=new OIMO.Vec3(a,c,
b);b=e*e+f*f+g*g;0<b&&(b=1/Math.sqrt(b),e*=b,f*=b,g*=b);b=Math.sin(0.5*d);d=Math.cos(0.5*d);this.orientation=new OIMO.Quat(d,b*e,b*f,b*g);this.linearVelocity=new OIMO.Vec3;this.angularVelocity=new OIMO.Vec3;this.sleepPosition=new OIMO.Vec3;this.sleepOrientation=new OIMO.Quat;this.rotation=new OIMO.Mat33;this.inverseInertia=new OIMO.Mat33;this.localInertia=new OIMO.Mat33;this.inverseLocalInertia=new OIMO.Mat33;this.matrix=new OIMO.Mat44;this.allowSleep=!0;this.sleepTime=0};
OIMO.RigidBody.prototype={constructor:OIMO.RigidBody,addShape:function(a){if(a.parent)throw Error("It is not possible that you add to the multi-rigid body the shape of one");null!=this.shapes&&((this.shapes.prev=a).next=this.shapes);this.shapes=a;a.parent=this;this.parent&&this.parent.addShape(a);this.numShapes++},removeShape:function(a){if(a.parent==this){var c=a.prev,b=a.next;null!=c&&(c.next=b);null!=b&&(b.prev=c);this.shapes==a&&(this.shapes=b);a.prev=null;a.next=null;a.parent=null;this.parent&&
this.parent.removeShape(a);this.numShapes--}},setupMass:function(a,c){var b=void 0!==c?c:!0,d=a||this.BODY_DYNAMIC;this.type=d;this.isDynamic=d==this.BODY_DYNAMIC;this.isStatic=d==this.BODY_STATIC;this.mass=0;this.localInertia.init(0,0,0,0,0,0,0,0,0);for(var e=this.localInertia.elements,f=new OIMO.Mat33,g=new OIMO.Vec3,h=this.shapes;null!=h;h=h.next){h.calculateMassInfo(this.massInfo);var k=this.massInfo.mass,l=h.relativePosition.x,n=h.relativePosition.y,p=h.relativePosition.z;g.addScale(h.relativePosition,
k);this.mass+=k;this.rotateInertia(h.relativeRotation,this.massInfo.inertia,f);this.localInertia.addEqual(f);e[0]+=k*(n*n+p*p);e[4]+=k*(l*l+p*p);e[8]+=k*(l*l+n*n);var m=k*l*n,n=k*n*p,k=k*p*l;e[1]-=m;e[3]-=m;e[2]-=n;e[6]-=n;e[5]-=k;e[7]-=k}this.inverseMass=1/this.mass;g.scaleEqual(this.inverseMass);if(b){this.position.addEqual(g);for(h=this.shapes;null!=h;h=h.next)h.relativePosition.subEqual(g);l=g.x;n=g.y;p=g.z;e[0]-=this.mass*(n*n+p*p);e[4]-=this.mass*(l*l+p*p);e[8]-=this.mass*(l*l+n*n);m=this.mass*
l*n;n=this.mass*n*p;k=this.mass*p*l;e[1]+=m;e[3]+=m;e[2]+=n;e[6]+=n;e[5]+=k;e[7]+=k}this.inverseLocalInertia.invert(this.localInertia);d==this.BODY_STATIC&&(this.inverseMass=0,this.inverseLocalInertia.init(0,0,0,0,0,0,0,0,0));this.syncShapes();this.awake()},awake:function(){if(this.allowSleep&&this.sleeping){this.sleeping=!1;this.sleepTime=0;for(var a=this.contactLink;null!=a;)a.body.sleepTime=0,a.body.sleeping=!1,a=a.next;for(a=this.jointLink;null!=a;)a.body.sleepTime=0,a.body.sleeping=!1,a=a.next;
for(a=this.shapes;null!=a;a=a.next)a.updateProxy()}},sleep:function(){if(this.allowSleep&&!this.sleeping){this.linearVelocity.init();this.angularVelocity.init();this.sleepPosition.copy(this.position);this.sleepOrientation.copy(this.orientation);this.sleepTime=0;this.sleeping=!0;for(var a=this.shapes;null!=a;a=a.next)a.updateProxy()}},isLonely:function(){return 0==this.numJoints&&0==this.numContacts},updatePosition:function(a){switch(this.type){case this.BODY_STATIC:this.linearVelocity.init();this.angularVelocity.init();
break;case this.BODY_DYNAMIC:this.position.addTime(this.linearVelocity,a);this.orientation.addTime(this.angularVelocity,a);break;default:throw Error("Invalid type.");}this.syncShapes()},rotateInertia:function(a,c,b){var d=a.elements,e=c.elements;c=d[0];a=d[3];var f=d[6],g=d[1],h=d[4],k=d[7],l=d[2],n=d[5],d=d[8],p=e[0],m=e[3],t=e[6],r=e[1],w=e[4],u=e[7],y=e[2],z=e[5],A=e[8],e=c*p+g*m+l*t,E=c*r+g*w+l*u,U=c*y+g*z+l*A,V=a*p+h*m+n*t,W=a*r+h*w+n*u,ga=a*y+h*z+n*A,p=f*p+k*m+d*t,r=f*r+k*w+d*u,y=f*y+k*z+d*
A;b=b.elements;b[0]=e*c+E*g+U*l;b[1]=e*a+E*h+U*n;b[2]=e*f+E*k+U*d;b[3]=V*c+W*g+ga*l;b[4]=V*a+W*h+ga*n;b[5]=V*f+W*k+ga*d;b[6]=p*c+r*g+y*l;b[7]=p*a+r*h+y*n;b[8]=p*f+r*k+y*d},syncShapes:function(){var a=this.orientation.s,c=this.orientation.x,b=this.orientation.y,d=this.orientation.z,e=2*c,f=2*b,g=2*d,h=c*e,k=b*f,d=d*g,l=c*f,b=b*g,c=c*g,e=a*e,f=a*f,a=a*g,g=this.rotation.elements;g[0]=1-k-d;g[1]=l-a;g[2]=c+f;g[3]=l+a;g[4]=1-h-d;g[5]=b-e;g[6]=c-f;g[7]=b+e;g[8]=1-h-k;this.rotateInertia(this.rotation,this.inverseLocalInertia,
this.inverseInertia);for(h=this.shapes;null!=h;h=h.next)h.position.mul(this.position,h.relativePosition,this.rotation),h.rotation.mul(h.relativeRotation,this.rotation),h.updateProxy()},applyImpulse:function(a,c){this.linearVelocity.addScale(c,this.inverseMass);var b=new OIMO.Vec3;b.sub(a,this.position).cross(b,c).mulMat(this.inverseInertia,b);this.angularVelocity.addEqual(b)},setPosition:function(a,c,b){this.position.init(a*OIMO.INV_SCALE,c*OIMO.INV_SCALE,b*OIMO.INV_SCALE);this.linearVelocity.init();
this.angularVelocity.init()},setOrientation:function(a,c,b){var d=OIMO.EulerToAxis(a,c,b);b=d[0];a=d[1];c=d[2];var d=d[3],e=a*a+c*c+d*d;0<e&&(e=1/Math.sqrt(e),a*=e,c*=e,d*=e);e=Math.sin(0.5*b);b=Math.cos(0.5*b);this.orientation=new OIMO.Quat(b,e*a,e*c,e*d);this.angularVelocity.init()},getMatrix:function(){var a=this.matrix.elements,c;this.sleeping?a[15]=1:(c=this.rotation.elements,a[0]=c[0],a[1]=c[3],a[2]=c[6],a[3]=0,a[4]=c[1],a[5]=c[4],a[6]=c[7],a[7]=0,a[8]=c[2],a[9]=c[5],a[10]=c[8],a[11]=0,c=this.position,
a[12]=c.x*OIMO.WORLD_SCALE,a[13]=c.y*OIMO.WORLD_SCALE,a[14]=c.z*OIMO.WORLD_SCALE,a[15]=0);return a}};OIMO.Body=function(a){a=a||{};if(a.world){this.name=a.name||"";for(var c=a.move||!1,b=a.noSleep||!1,d=a.pos||[0,0,0],d=d.map(function(a){return a*OIMO.INV_SCALE}),e=a.size||[1,1,1],e=e.map(function(a){return a*OIMO.INV_SCALE}),f=a.rot||[0,0,0],f=f.map(function(a){return a*OIMO.TO_RAD}),g=[],h=0;h<f.length/3;h++){var k=OIMO.EulerToAxis(f[h+0],f[h+1],f[h+2]);g.push(k[0]);g.push(k[1]);g.push(k[2]);g.push(k[3])}f=a.sc||new OIMO.ShapeConfig;a.config&&(f.density=a.config[0]||1,f.friction=a.config[1]||0.4,
f.restitution=a.config[2]||0.2,f.belongsTo=a.config[3]||1,f.collidesWith=a.config[4]||4294967295);a.massPos&&(a.massPos=a.massPos.map(function(a){return a*OIMO.INV_SCALE}),f.relativePosition.init(a.massPos[0],a.massPos[1],a.massPos[2]));a.massRot&&(a.massRot=a.massRot.map(function(a){return a*OIMO.TO_RAD}),f.relativeRotation=OIMO.EulerToMatrix(a.massRot[0],a.massRot[1],a.massRot[2]));this.body=new OIMO.RigidBody(d[0],d[1],d[2],g[0],g[1],g[2],g[3]);var k=[],l=a.type||"box";"string"===typeof l&&(l=
[l]);for(var n,p,h=0;h<l.length;h++){n=3*h;p=4*h;switch(l[h]){case "sphere":k[h]=new OIMO.SphereShape(f,e[n+0]);break;case "cylinder":k[h]=new OIMO.BoxShape(f,e[n+0],e[n+1],e[n+2]);break;case "box":k[h]=new OIMO.BoxShape(f,e[n+0],e[n+1],e[n+2])}this.body.addShape(k[h]);0<h&&(k[h].relativePosition=new OIMO.Vec3(d[n+0],d[n+1],d[n+2]),g[p+0]&&(k[h].relativeRotation=[g[p+0],g[p+1],g[p+2],g[p+3]]))}c?(a.massPos||a.massRot?this.body.setupMass(1,!1):this.body.setupMass(1,!0),this.body.allowSleep=b?!1:!0):
this.body.setupMass(2);this.body.name=this.name;a.world.addRigidBody(this.body)}};OIMO.Link=function(a){a=a||{};if(a.world){this.name=a.name||"";var c=a.type||"jointHinge",b=a.axe1||[1,0,0],d=a.axe2||[1,0,0],e=a.pos1||[0,0,0],f=a.pos2||[0,0,0],e=e.map(function(a){return a*OIMO.INV_SCALE}),f=f.map(function(a){return a*OIMO.INV_SCALE}),g,h;"jointDistance"===c?(g=a.min||0,h=a.max||10,g*=OIMO.INV_SCALE,h*=OIMO.INV_SCALE):(g=a.min||57.29578,h=a.max||0,g*=OIMO.TO_RAD,h*=OIMO.TO_RAD);var k=a.limit||null,l=a.spring||null,n=new OIMO.JointConfig;n.allowCollision=a.collision||!1;n.localAxis1.init(b[0],
b[1],b[2]);n.localAxis2.init(d[0],d[1],d[2]);n.localAnchorPoint1.init(e[0],e[1],e[2]);n.localAnchorPoint2.init(f[0],f[1],f[2]);if("string"==typeof a.body1||a.body1 instanceof String)a.body1=a.world.getByName(a.body1);if("string"==typeof a.body2||a.body2 instanceof String)a.body2=a.world.getByName(a.body2);n.body1=a.body1;n.body2=a.body2;switch(c){case "jointDistance":this.joint=new OIMO.DistanceJoint(n,g,h);null!==l&&this.joint.limitMotor.setSpring(l[0],l[1]);break;case "jointHinge":this.joint=new OIMO.HingeJoint(n,
g,h);null!==l&&this.joint.limitMotor.setSpring(l[0],l[1]);break;case "jointPrisme":this.joint=new OIMO.PrismaticJoint(n,g,h);break;case "jointSlide":this.joint=new OIMO.SliderJoint(n,g,h);break;case "jointBall":this.joint=new OIMO.BallAndSocketJoint(n);break;case "jointWheel":this.joint=new OIMO.WheelJoint(n),null!==k&&this.joint.rotationalLimitMotor1.setLimit(k[0],k[1]),null!==l&&this.joint.rotationalLimitMotor1.setSpring(l[0],l[1])}this.joint.name=this.name;a.world.addJoint(this.joint)}};OIMO.Performance=function(){this.totalTime=this.updatingTime=this.solvingTime=this.narrowPhaseTime=this.broadPhaseTime=this.fps=this.fpsint=this.time_prev=0};OIMO.Mat44=function(a,c,b,d,e,f,g,h,k,l,n,p,m,t,r,w){var u=this.elements=new OIMO_ARRAY_TYPE(16);u[0]=void 0!==a?a:1;u[4]=c||0;u[8]=b||0;u[12]=d||0;u[1]=e||0;u[5]=void 0!==f?f:1;u[9]=g||0;u[13]=h||0;u[2]=k||0;u[6]=l||0;u[10]=void 0!==n?n:1;u[14]=p||0;u[3]=m||0;u[7]=t||0;u[11]=r||0;u[15]=void 0!==w?w:1};
OIMO.Mat44.prototype={constructor:OIMO.Mat44,set:function(a,c,b,d,e,f,g,h,k,l,n,p,m,t,r,w){var u=this.elements;u[0]=a;u[4]=c;u[8]=b;u[12]=d;u[1]=e;u[5]=f;u[9]=g;u[13]=h;u[2]=k;u[6]=l;u[10]=n;u[14]=p;u[3]=m;u[7]=t;u[11]=r;u[15]=w;return this}};OIMO.Mat33=function(a,c,b,d,e,f,g,h,k){this.elements=new OIMO_ARRAY_TYPE(9);this.init(void 0!==a?a:1,c||0,b||0,d||0,void 0!==e?e:1,f||0,g||0,h||0,void 0!==k?k:1)};
OIMO.Mat33.prototype={constructor:OIMO.Mat33,init:function(a,c,b,d,e,f,g,h,k){var l=this.elements;l[0]=a;l[1]=c;l[2]=b;l[3]=d;l[4]=e;l[5]=f;l[6]=g;l[7]=h;l[8]=k;return this},add:function(a,c){var b=this.elements,d=a.elements,e=c.elements;b[0]=d[0]+e[0];b[1]=d[1]+e[1];b[2]=d[2]+e[2];b[3]=d[3]+e[3];b[4]=d[4]+e[4];b[5]=d[5]+e[5];b[6]=d[6]+e[6];b[7]=d[7]+e[7];b[8]=d[8]+e[8];return this},addEqual:function(a){var c=this.elements;a=a.elements;c[0]+=a[0];c[1]+=a[1];c[2]+=a[2];c[3]+=a[3];c[4]+=a[4];c[5]+=
a[5];c[6]+=a[6];c[7]+=a[7];c[8]+=a[8];return this},sub:function(a,c){var b=this.elements,d=a.elements,e=c.elements;b[0]=d[0]-e[0];b[1]=d[1]-e[1];b[2]=d[2]-e[2];b[3]=d[3]-e[3];b[4]=d[4]-e[4];b[5]=d[5]-e[5];b[6]=d[6]-e[6];b[7]=d[7]-e[7];b[8]=d[8]-e[8];return this},subEqual:function(a){var c=this.elements;a=a.elements;c[0]-=a[0];c[1]-=a[1];c[2]-=a[2];c[3]-=a[3];c[4]-=a[4];c[5]-=a[5];c[6]-=a[6];c[7]-=a[7];c[8]-=a[8];return this},scale:function(a,c){var b=this.elements,d=a.elements;b[0]=d[0]*c;b[1]=d[1]*
c;b[2]=d[2]*c;b[3]=d[3]*c;b[4]=d[4]*c;b[5]=d[5]*c;b[6]=d[6]*c;b[7]=d[7]*c;b[8]=d[8]*c;return this},scaleEqual:function(a){var c=this.elements;c[0]*=a;c[1]*=a;c[2]*=a;c[3]*=a;c[4]*=a;c[5]*=a;c[6]*=a;c[7]*=a;c[8]*=a;return this},mul:function(a,c){var b=this.elements,d=a.elements,e=c.elements,f=d[0],g=d[3],h=d[6],k=d[1],l=d[4],n=d[7],p=d[2],m=d[5],d=d[8],t=e[0],r=e[3],w=e[6],u=e[1],y=e[4],z=e[7],A=e[2],E=e[5],e=e[8];b[0]=f*t+k*r+p*w;b[1]=f*u+k*y+p*z;b[2]=f*A+k*E+p*e;b[3]=g*t+l*r+m*w;b[4]=g*u+l*y+m*z;
b[5]=g*A+l*E+m*e;b[6]=h*t+n*r+d*w;b[7]=h*u+n*y+d*z;b[8]=h*A+n*E+d*e;return this},mulScale:function(a,c,b,d,e){var f=this.elements;a=a.elements;e?(f[0]=c*a[0],f[1]=c*a[1],f[2]=c*a[2],f[3]=b*a[3],f[4]=b*a[4],f[5]=b*a[5],f[6]=d*a[6],f[7]=d*a[7],f[8]=d*a[8]):(f[0]=a[0]*c,f[1]=a[1]*b,f[2]=a[2]*d,f[3]=a[3]*c,f[4]=a[4]*b,f[5]=a[5]*d,f[6]=a[6]*c,f[7]=a[7]*b,f[8]=a[8]*d);return this},mulRotate:function(a,c,b,d,e,f){f=f||!1;var g=Math.sin(c),h=Math.cos(c),k=1-h;c=b*b*k+h;var l=b*d*k-e*g,n=b*e*k+d*g,p=d*b*k+
e*g,m=d*d*k+h,t=d*e*k-b*g,r=e*b*k-d*g;b=e*d*k+b*g;e=e*e*k+h;var w=a.elements;a=w[0];d=w[3];var g=w[6],h=w[1],k=w[4],u=w[7],y=w[2],z=w[5],w=w[8],A=this.elements;f?(A[0]=c*a+l*d+n*g,A[1]=c*h+l*k+n*u,A[2]=c*y+l*z+n*w,A[3]=p*a+m*d+t*g,A[4]=p*h+m*k+t*u,A[5]=p*y+m*z+t*w,A[6]=r*a+b*d+e*g,A[7]=r*h+b*k+e*u,A[8]=r*y+b*z+e*w):(A[0]=a*c+h*p+y*r,A[1]=a*l+h*m+y*b,A[2]=a*n+h*t+y*e,A[3]=d*c+k*p+z*r,A[4]=d*l+k*m+z*b,A[5]=d*n+k*t+z*e,A[6]=g*c+u*p+w*r,A[7]=g*l+u*m+w*b,A[8]=g*n+u*t+w*e);return this},transpose:function(a){var c=
this.elements;a=a.elements;c[0]=a[0];c[1]=a[3];c[2]=a[6];c[3]=a[1];c[4]=a[4];c[5]=a[7];c[6]=a[2];c[7]=a[5];c[8]=a[8];return this},setQuat:function(a){var c=2*a.x,b=2*a.y,d=2*a.z,e=a.x*c,f=a.y*b,g=a.z*d,h=a.x*b,k=a.y*d,l=a.x*d,c=a.s*c,b=a.s*b;a=a.s*d;d=this.elements;d[0]=1-f-g;d[1]=h-a;d[2]=l+b;d[3]=h+a;d[4]=1-e-g;d[5]=k-c;d[6]=l-b;d[7]=k+c;d[8]=1-e-f;return this},invert:function(a){var c=this.elements,b=a.elements;a=b[0];var d=b[3],e=b[6],f=b[1],g=b[4],h=b[7],k=b[2],l=b[5],b=b[8],n=a*(g*b-h*l)+d*
(h*k-f*b)+e*(f*l-g*k);0!=n&&(n=1/n);c[0]=n*(g*b-l*h);c[1]=n*(k*h-f*b);c[2]=n*(f*l-k*g);c[3]=n*(l*e-d*b);c[4]=n*(a*b-k*e);c[5]=n*(k*d-a*l);c[6]=n*(d*h-g*e);c[7]=n*(f*e-a*h);c[8]=n*(a*g-f*d);return this},copy:function(a){var c=this.elements;a=a.elements;c[0]=a[0];c[1]=a[1];c[2]=a[2];c[3]=a[3];c[4]=a[4];c[5]=a[5];c[6]=a[6];c[7]=a[7];c[8]=a[8];return this},toEuler:function(){var a=this.elements,c=a[0],b=a[3],d=a[6],e=a[4],f=a[7],g=a[5],a=a[8],h=new OIMO.Vec3;new OIMO.Quat;h.y=Math.asin(Math.min(Math.max(d,
-1),1));0.99999>Math.abs(d)?(h.x=Math.atan2(-f,a),h.z=Math.atan2(-b,c)):(h.x=Math.atan2(g,e),h.z=0);return h},clone:function(){var a=this.elements;return new OIMO.Mat33(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8])},toString:function(){var a=this.elements;return"Mat33|"+a[0].toFixed(4)+", "+a[1].toFixed(4)+", "+a[2].toFixed(4)+"|\n     |"+a[3].toFixed(4)+", "+a[4].toFixed(4)+", "+a[5].toFixed(4)+"|\n     |"+a[6].toFixed(4)+", "+a[7].toFixed(4)+", "+a[8].toFixed(4)+"|"}};OIMO.Quat=function(a,c,b,d){this.s=void 0!==a?a:1;this.x=c||0;this.y=b||0;this.z=d||0};
OIMO.Quat.prototype={constructor:OIMO.Quat,init:function(a,c,b,d){this.s=void 0!==a?a:1;this.x=c||0;this.y=b||0;this.z=d||0;return this},add:function(a,c){this.s=a.s+c.s;this.x=a.x+c.x;this.y=a.y+c.y;this.z=a.z+c.z;return this},addTime:function(a,c){var b=this.s,d=this.x,e=this.y,f=this.z;c*=0.5;var g=(-a.x*d-a.y*e-a.z*f)*c,h=(a.x*b+a.y*f-a.z*e)*c,k=(-a.x*f+a.y*b+a.z*d)*c,l=(a.x*e-a.y*d+a.z*b)*c,b=b+g,d=d+h,e=e+k,f=f+l,g=1/Math.sqrt(b*b+d*d+e*e+f*f);this.s=b*g;this.x=d*g;this.y=e*g;this.z=f*g;return this},
sub:function(a,c){this.s=a.s-c.s;this.x=a.x-c.x;this.y=a.y-c.y;this.z=a.z-c.z;return this},scale:function(a,c){this.s=a.s*c;this.x=a.x*c;this.y=a.y*c;this.z=a.z*c;return this},mul:function(a,c){var b=a.s*c.x+a.x*c.s+a.y*c.z-a.z*c.y,d=a.s*c.y-a.x*c.z+a.y*c.s+a.z*c.x,e=a.s*c.z+a.x*c.y-a.y*c.x+a.z*c.s;this.s=a.s*c.s-a.x*c.x-a.y*c.y-a.z*c.z;this.x=b;this.y=d;this.z=e;return this},arc:function(a,c){var b=a.x,d=a.y,e=a.z,f=c.x,g=c.y,h=c.z,k=b*f+d*g+e*h;if(-1==k)return f=d*b-e*e,g=-e*d-b*b,h=b*e+d*d,k=1/
Math.sqrt(f*f+g*g+h*h),this.s=0,this.x=f*k,this.y=g*k,this.z=h*k,this;var l=d*h-e*g,e=e*f-b*h,b=b*g-d*f;this.s=Math.sqrt(0.5*(1+k));k=0.5/this.s;this.x=l*k;this.y=e*k;this.z=b*k;return this},normalize:function(a){var c=Math.sqrt(a.s*a.s+a.x*a.x+a.y*a.y+a.z*a.z);0<c&&(c=1/c);this.s=a.s*c;this.x=a.x*c;this.y=a.y*c;this.z=a.z*c;return this},invert:function(a){this.s=a.s;this.x=-a.x;this.y=-a.y;this.z=-a.z;return this},length:function(){return Math.sqrt(this.s*this.s+this.x*this.x+this.y*this.y+this.z*
this.z)},copy:function(a){this.s=a.s;this.x=a.x;this.y=a.y;this.z=a.z;return this},testDiff:function(a){return this.s!==a.s||this.x!==a.x||this.y!==a.y||this.z!==a.z?!0:!1},clone:function(a){return new OIMO.Quat(this.s,this.x,this.y,this.z)},toString:function(){return"Quat["+this.s.toFixed(4)+", ("+this.x.toFixed(4)+", "+this.y.toFixed(4)+", "+this.z.toFixed(4)+")]"}};OIMO.Vec3=function(a,c,b){this.x=a||0;this.y=c||0;this.z=b||0};
OIMO.Vec3.prototype={constructor:OIMO.Vec3,init:function(a,c,b){this.x=a||0;this.y=c||0;this.z=b||0;return this},set:function(a,c,b){this.x=a;this.y=c;this.z=b;return this},add:function(a,c){this.x=a.x+c.x;this.y=a.y+c.y;this.z=a.z+c.z;return this},addEqual:function(a){this.x+=a.x;this.y+=a.y;this.z+=a.z;return this},addTime:function(a,c){this.x+=a.x*c;this.y+=a.y*c;this.z+=a.z*c;return this},sub:function(a,c){this.x=a.x-c.x;this.y=a.y-c.y;this.z=a.z-c.z;return this},subEqual:function(a){this.x-=
a.x;this.y-=a.y;this.z-=a.z;return this},addScale:function(a,c){this.x+=a.x*c;this.y+=a.y*c;this.z+=a.z*c;return this},scale:function(a,c){this.x=a.x*c;this.y=a.y*c;this.z=a.z*c;return this},scaleEqual:function(a){this.x*=a;this.y*=a;this.z*=a;return this},dot:function(a){return this.x*a.x+this.y*a.y+this.z*a.z},cross:function(a,c){var b=a.z*c.x-a.x*c.z,d=a.x*c.y-a.y*c.x;this.x=a.y*c.z-a.z*c.y;this.y=b;this.z=d;return this},mul:function(a,c,b){b=b.elements;this.x=a.x+c.x*b[0]+c.y*b[1]+c.z*b[2];this.y=
a.y+c.x*b[3]+c.y*b[4]+c.z*b[5];this.z=a.z+c.x*b[6]+c.y*b[7]+c.z*b[8];return this},mulMat:function(a,c){var b=a.elements,d=b[3]*c.x+b[4]*c.y+b[5]*c.z,e=b[6]*c.x+b[7]*c.y+b[8]*c.z;this.x=b[0]*c.x+b[1]*c.y+b[2]*c.z;this.y=d;this.z=e;return this},normalize:function(a){var c=Math.sqrt(a.x*a.x+a.y*a.y+a.z*a.z);0<c&&(c=1/c);this.x=a.x*c;this.y=a.y*c;this.z=a.z*c;return this},invert:function(a){this.x=-a.x;this.y=-a.y;this.z=-a.z;return this},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+
this.z*this.z)},len:function(){return this.x*this.x+this.y*this.y+this.z*this.z},copy:function(a){this.x=a.x;this.y=a.y;this.z=a.z;return this},testZero:function(){return 0!==this.x||0!==this.y||0!==this.z?!0:!1},testDiff:function(a){return this.x!==a.x||this.y!==a.y||this.z!==a.z?!0:!1},clone:function(){return new OIMO.Vec3(this.x,this.y,this.z)},toString:function(){return"Vec3["+this.x.toFixed(4)+", "+this.y.toFixed(4)+", "+this.z.toFixed(4)+"]"}};OIMO.EulerToAxis=function(a,c,b){var d=Math.cos(0.5*c);c=Math.sin(0.5*c);var e=Math.cos(0.5*b),f=Math.sin(0.5*b),g=Math.cos(0.5*a),h=Math.sin(0.5*a),k=d*e,l=c*f;a=k*h+l*g;b=c*e*g+d*f*h;d=d*f*g-c*e*h;c=2*Math.acos(k*g-l*h);e=a*a+b*b+d*d;0.001>e?(a=1,b=d=0):(e=Math.sqrt(e),a/=e,b/=e,d/=e);return[c,a,b,d]};
OIMO.EulerToMatrix=function(a,c,b){var d=Math.cos(c);c=Math.sin(c);var e=Math.cos(b);b=Math.sin(b);var f=Math.cos(a);a=Math.sin(a);var g=new OIMO.Mat33,h=g.elements;h[0]=d*e;h[1]=c*a-d*b*f;h[2]=d*b*a+c*f;h[3]=b;h[4]=e*f;h[5]=-e*a;h[6]=-c*e;h[7]=c*b*f+d*a;h[8]=-c*b*a+d*f;return g};
OIMO.MatrixToEuler=function(a){var c=a.elements,b;0.998<c[3]?(b=Math.atan2(c[2],c[8]),c=Math.PI/2,a=0):-0.998>c[3]?(b=Math.atan2(c[2],c[8]),c=-Math.PI/2,a=0):(b=Math.atan2(-c[6],c[0]),a=Math.atan2(-c[5],c[4]),c=Math.asin(c[3]));return[a,b,c]};OIMO.Distance3d=function(a,c){var b=c[0]-a[0],d=c[1]-a[1],e=c[2]-a[2];return Math.sqrt(b*b+d*d+e*e)};OIMO.Constraint=function(){this.body2=this.body1=this.parent=null;this.addedToIsland=!1};OIMO.Constraint.prototype={constructor:OIMO.Constraint,preSolve:function(a,c){throw Error("Inheritance error.");},solve:function(){throw Error("Inheritance error.");},postSolve:function(){throw Error("Inheritance error.");}};OIMO.Joint=function(a){OIMO.Constraint.call(this);this.name="";this.JOINT_DISTANCE=1;this.JOINT_BALL_AND_SOCKET=2;this.JOINT_HINGE=3;this.JOINT_WHEEL=4;this.JOINT_SLIDER=5;this.JOINT_PRISMATIC=6;this.type=0;this.next=this.prev=null;this.body1=a.body1;this.body2=a.body2;this.localAnchorPoint1=(new OIMO.Vec3).copy(a.localAnchorPoint1);this.localAnchorPoint2=(new OIMO.Vec3).copy(a.localAnchorPoint2);this.relativeAnchorPoint1=new OIMO.Vec3;this.relativeAnchorPoint2=new OIMO.Vec3;this.anchorPoint1=new OIMO.Vec3;
this.anchorPoint2=new OIMO.Vec3;this.allowCollision=a.allowCollision;this.b1Link=new OIMO.JointLink(this);this.b2Link=new OIMO.JointLink(this);this.matrix=new OIMO.Mat44};OIMO.Joint.prototype=Object.create(OIMO.Constraint.prototype);
OIMO.Joint.prototype.updateAnchorPoints=function(){var a=this.body1.position,c=this.body2.position,b=this.body1.rotation.elements,d=this.body2.rotation.elements,e=this.localAnchorPoint1.x,f=this.localAnchorPoint1.y,g=this.localAnchorPoint1.z,h=this.localAnchorPoint2.x,k=this.localAnchorPoint2.y,l=this.localAnchorPoint2.z,n=e*b[0]+f*b[1]+g*b[2],p=e*b[3]+f*b[4]+g*b[5],f=e*b[6]+f*b[7]+g*b[8],e=h*d[0]+k*d[1]+l*d[2],b=h*d[3]+k*d[4]+l*d[5],d=h*d[6]+k*d[7]+l*d[8];this.relativeAnchorPoint1.x=n;this.relativeAnchorPoint1.y=
p;this.relativeAnchorPoint1.z=f;this.relativeAnchorPoint2.x=e;this.relativeAnchorPoint2.y=b;this.relativeAnchorPoint2.z=d;p+=a.y;h=f+a.z;k=e+c.x;l=b+c.y;c=d+c.z;this.anchorPoint1.x=n+a.x;this.anchorPoint1.y=p;this.anchorPoint1.z=h;this.anchorPoint2.x=k;this.anchorPoint2.y=l;this.anchorPoint2.z=c};
OIMO.Joint.prototype.attach=function(){this.b1Link.body=this.body2;this.b2Link.body=this.body1;null!=this.body1.jointLink?(this.b1Link.next=this.body1.jointLink).prev=this.b1Link:this.b1Link.next=null;this.body1.jointLink=this.b1Link;this.body1.numJoints++;null!=this.body2.jointLink?(this.b2Link.next=this.body2.jointLink).prev=this.b2Link:this.b2Link.next=null;this.body2.jointLink=this.b2Link;this.body2.numJoints++};
OIMO.Joint.prototype.detach=function(){var a=this.b1Link.prev,c=this.b1Link.next;null!=a&&(a.next=c);null!=c&&(c.prev=a);this.body1.jointLink==this.b1Link&&(this.body1.jointLink=c);this.b1Link.prev=null;this.b1Link.next=null;this.b1Link.body=null;this.body1.numJoints--;a=this.b2Link.prev;c=this.b2Link.next;null!=a&&(a.next=c);null!=c&&(c.prev=a);this.body2.jointLink==this.b2Link&&(this.body2.jointLink=c);this.b2Link.prev=null;this.b2Link.next=null;this.b2Link.body=null;this.body2.numJoints--;this.b1Link.body=
null;this.b2Link.body=null};OIMO.Joint.prototype.awake=function(){this.body1.awake();this.body2.awake()};OIMO.Joint.prototype.preSolve=function(a,c){};OIMO.Joint.prototype.solve=function(){};OIMO.Joint.prototype.postSolve=function(){};
OIMO.Joint.prototype.getMatrix=function(){var a=this.matrix.elements,c=this.anchorPoint1,b=this.anchorPoint2;a[0]=c.x*OIMO.WORLD_SCALE;a[1]=c.y*OIMO.WORLD_SCALE;a[2]=c.z*OIMO.WORLD_SCALE;a[3]=0;a[4]=b.x*OIMO.WORLD_SCALE;a[5]=b.y*OIMO.WORLD_SCALE;a[6]=b.z*OIMO.WORLD_SCALE;a[7]=0;return a};OIMO.JointConfig=function(){this.body2=this.body1=null;this.localAnchorPoint1=new OIMO.Vec3;this.localAnchorPoint2=new OIMO.Vec3;this.localAxis1=new OIMO.Vec3;this.localAxis2=new OIMO.Vec3;this.allowCollision=!1};OIMO.JointLink=function(a){this.body=this.next=this.prev=null;this.joint=a};OIMO.LimitMotor=function(a,c){this.axis=a;this.angle=0;this.lowerLimit=c?0:1;this.dampingRatio=this.frequency=this.maxMotorForce=this.motorSpeed=this.upperLimit=0};OIMO.LimitMotor.prototype={constructor:OIMO.LimitMotor,setLimit:function(a,c){this.lowerLimit=a;this.upperLimit=c},setMotor:function(a,c){this.motorSpeed=a;this.maxMotorForce=c},setSpring:function(a,c){this.frequency=a;this.dampingRatio=c}};OIMO.BallAndSocketJoint=function(a){OIMO.Joint.call(this,a);this.type=this.JOINT_BALL_AND_SOCKET;this.lc=new OIMO.LinearConstraint(this)};OIMO.BallAndSocketJoint.prototype=Object.create(OIMO.Joint.prototype);OIMO.BallAndSocketJoint.prototype.preSolve=function(a,c){this.updateAnchorPoints();this.lc.preSolve(a,c)};OIMO.BallAndSocketJoint.prototype.solve=function(){this.lc.solve()};OIMO.BallAndSocketJoint.prototype.postSolve=function(){};OIMO.DistanceJoint=function(a,c,b){OIMO.Joint.call(this,a);this.type=this.JOINT_DISTANCE;this.normal=new OIMO.Vec3;this.limitMotor=new OIMO.LimitMotor(this.normal,!0);this.limitMotor.lowerLimit=c;this.limitMotor.upperLimit=b;this.t=new OIMO.TranslationalConstraint(this,this.limitMotor)};OIMO.DistanceJoint.prototype=Object.create(OIMO.Joint.prototype);
OIMO.DistanceJoint.prototype.preSolve=function(a,c){this.updateAnchorPoints();var b=this.anchorPoint2.x-this.anchorPoint1.x,d=this.anchorPoint2.y-this.anchorPoint1.y,e=this.anchorPoint2.z-this.anchorPoint1.z,f=Math.sqrt(b*b+d*d+e*e);0<f&&(f=1/f);this.normal.init(b*f,d*f,e*f);this.t.preSolve(a,c)};OIMO.DistanceJoint.prototype.solve=function(){this.t.solve()};OIMO.DistanceJoint.prototype.postSolve=function(){};OIMO.HingeJoint=function(a,c,b){OIMO.Joint.call(this,a);this.localAxis1=(new OIMO.Vec3).normalize(a.localAxis1);this.localAxis2=(new OIMO.Vec3).normalize(a.localAxis2);this.localAxis1X=this.localAxis1.x;this.localAxis1Y=this.localAxis1.y;this.localAxis1Z=this.localAxis1.z;this.localAngAxis1X=this.localAxis1Y*this.localAxis1X-this.localAxis1Z*this.localAxis1Z;this.localAngAxis1Y=-this.localAxis1Z*this.localAxis1Y-this.localAxis1X*this.localAxis1X;this.localAngAxis1Z=this.localAxis1X*this.localAxis1Z+
this.localAxis1Y*this.localAxis1Y;a=1/Math.sqrt(this.localAngAxis1X*this.localAngAxis1X+this.localAngAxis1Y*this.localAngAxis1Y+this.localAngAxis1Z*this.localAngAxis1Z);this.localAngAxis1X*=a;this.localAngAxis1Y*=a;this.localAngAxis1Z*=a;this.localAxis2X=this.localAxis2.x;this.localAxis2Y=this.localAxis2.y;this.localAxis2Z=this.localAxis2.z;a=(new OIMO.Mat33).setQuat((new OIMO.Quat).arc(this.localAxis1,this.localAxis2)).elements;this.localAngAxis2X=this.localAngAxis1X*a[0]+this.localAngAxis1Y*a[1]+
this.localAngAxis1Z*a[2];this.localAngAxis2Y=this.localAngAxis1X*a[3]+this.localAngAxis1Y*a[4]+this.localAngAxis1Z*a[5];this.localAngAxis2Z=this.localAngAxis1X*a[6]+this.localAngAxis1Y*a[7]+this.localAngAxis1Z*a[8];this.type=this.JOINT_HINGE;this.nor=new OIMO.Vec3;this.tan=new OIMO.Vec3;this.bin=new OIMO.Vec3;this.limitMotor=new OIMO.LimitMotor(this.nor,!1);this.limitMotor.lowerLimit=c;this.limitMotor.upperLimit=b;this.lc=new OIMO.LinearConstraint(this);this.r3=new OIMO.Rotational3Constraint(this,
this.limitMotor,new OIMO.LimitMotor(this.tan,!0),new OIMO.LimitMotor(this.bin,!0))};OIMO.HingeJoint.prototype=Object.create(OIMO.Joint.prototype);
OIMO.HingeJoint.prototype.preSolve=function(a,c){var b,d,e;this.updateAnchorPoints();b=this.body1.rotation.elements;e=this.localAxis1X*b[0]+this.localAxis1Y*b[1]+this.localAxis1Z*b[2];var f=this.localAxis1X*b[3]+this.localAxis1Y*b[4]+this.localAxis1Z*b[5];d=this.localAxis1X*b[6]+this.localAxis1Y*b[7]+this.localAxis1Z*b[8];var g=this.localAngAxis1X*b[0]+this.localAngAxis1Y*b[1]+this.localAngAxis1Z*b[2],h=this.localAngAxis1X*b[3]+this.localAngAxis1Y*b[4]+this.localAngAxis1Z*b[5],k=this.localAngAxis1X*
b[6]+this.localAngAxis1Y*b[7]+this.localAngAxis1Z*b[8];b=this.body2.rotation.elements;var l=this.localAxis2X*b[0]+this.localAxis2Y*b[1]+this.localAxis2Z*b[2],n=this.localAxis2X*b[3]+this.localAxis2Y*b[4]+this.localAxis2Z*b[5],p=this.localAxis2X*b[6]+this.localAxis2Y*b[7]+this.localAxis2Z*b[8],m=this.localAngAxis2X*b[0]+this.localAngAxis2Y*b[1]+this.localAngAxis2Z*b[2],t=this.localAngAxis2X*b[3]+this.localAngAxis2Y*b[4]+this.localAngAxis2Z*b[5],r=this.localAngAxis2X*b[6]+this.localAngAxis2Y*b[7]+this.localAngAxis2Z*
b[8],w=e*this.body2.inverseMass+l*this.body1.inverseMass,u=f*this.body2.inverseMass+n*this.body1.inverseMass,y=d*this.body2.inverseMass+p*this.body1.inverseMass;b=Math.sqrt(w*w+u*u+y*y);0<b&&(b=1/b);var w=w*b,u=u*b,y=y*b,z=u*w-y*y,A=-y*u-w*w,E=w*y+u*u;b=1/Math.sqrt(z*z+A*A+E*E);var z=z*b,A=A*b,E=E*b,U=u*E-y*A,V=y*z-w*E,W=w*A-u*z;this.nor.init(w,u,y);this.tan.init(z,A,E);this.bin.init(U,V,W);this.limitMotor.angle=0>w*(h*r-k*t)+u*(k*m-g*r)+y*(g*t-h*m)?-this.acosClamp(g*m+h*t+k*r):this.acosClamp(g*m+
h*t+k*r);b=f*p-d*n;d=d*l-e*p;e=e*n-f*l;this.r3.limitMotor2.angle=z*b+A*d+E*e;this.r3.limitMotor3.angle=U*b+V*d+W*e;this.r3.preSolve(a,c);this.lc.preSolve(a,c)};OIMO.HingeJoint.prototype.solve=function(){this.r3.solve();this.lc.solve()};OIMO.HingeJoint.prototype.postSolve=function(){};OIMO.HingeJoint.prototype.acosClamp=function(a){return 1<a?0:-1>a?Math.PI:Math.acos(a)};OIMO.PrismaticJoint=function(a,c,b){OIMO.Joint.call(this,a);this.localAxis1=(new OIMO.Vec3).normalize(a.localAxis1);this.localAxis2=(new OIMO.Vec3).normalize(a.localAxis2);this.localAxis1X=this.localAxis1.x;this.localAxis1Y=this.localAxis1.y;this.localAxis1Z=this.localAxis1.z;this.localAxis2X=this.localAxis2.x;this.localAxis2Y=this.localAxis2.y;this.localAxis2Z=this.localAxis2.z;this.type=this.JOINT_PRISMATIC;this.nor=new OIMO.Vec3;this.tan=new OIMO.Vec3;this.bin=new OIMO.Vec3;this.ac=new OIMO.AngularConstraint(this,
(new OIMO.Quat).arc(this.localAxis1,this.localAxis2));this.limitMotor=new OIMO.LimitMotor(this.nor,!0);this.limitMotor.lowerLimit=c;this.limitMotor.upperLimit=b;this.t3=new OIMO.Translational3Constraint(this,this.limitMotor,new OIMO.LimitMotor(this.tan,!0),new OIMO.LimitMotor(this.bin,!0))};OIMO.PrismaticJoint.prototype=Object.create(OIMO.Joint.prototype);
OIMO.PrismaticJoint.prototype.preSolve=function(a,c){var b,d;this.updateAnchorPoints();b=this.body1.rotation.elements;var e=this.localAxis1X*b[0]+this.localAxis1Y*b[1]+this.localAxis1Z*b[2],f=this.localAxis1X*b[3]+this.localAxis1Y*b[4]+this.localAxis1Z*b[5],g=this.localAxis1X*b[6]+this.localAxis1Y*b[7]+this.localAxis1Z*b[8];b=this.body2.rotation.elements;e=e*this.body2.inverseMass+(this.localAxis2X*b[0]+this.localAxis2Y*b[1]+this.localAxis2Z*b[2])*this.body1.inverseMass;f=f*this.body2.inverseMass+
(this.localAxis2X*b[3]+this.localAxis2Y*b[4]+this.localAxis2Z*b[5])*this.body1.inverseMass;b=g*this.body2.inverseMass+(this.localAxis2X*b[6]+this.localAxis2Y*b[7]+this.localAxis2Z*b[8])*this.body1.inverseMass;d=Math.sqrt(e*e+f*f+b*b);0<d&&(d=1/d);e*=d;f*=d;b*=d;var g=f*e-b*b,h=-b*f-e*e,k=e*b+f*f;d=1/Math.sqrt(g*g+h*h+k*k);g*=d;h*=d;k*=d;d=f*k-b*h;var l=b*g-e*k,n=e*h-f*g;this.nor.init(e,f,b);this.tan.init(g,h,k);this.bin.init(d,l,n);this.ac.preSolve(a,c);this.t3.preSolve(a,c)};
OIMO.PrismaticJoint.prototype.solve=function(){this.ac.solve();this.t3.solve()};OIMO.PrismaticJoint.prototype.postSolve=function(){};OIMO.SliderJoint=function(a,c,b){OIMO.Joint.call(this,a);this.localAxis1=(new OIMO.Vec3).normalize(a.localAxis1);this.localAxis2=(new OIMO.Vec3).normalize(a.localAxis2);this.localAxis1X=this.localAxis1.x;this.localAxis1Y=this.localAxis1.y;this.localAxis1Z=this.localAxis1.z;this.localAngAxis1X=this.localAxis1Y*this.localAxis1X-this.localAxis1Z*this.localAxis1Z;this.localAngAxis1Y=-this.localAxis1Z*this.localAxis1Y-this.localAxis1X*this.localAxis1X;this.localAngAxis1Z=this.localAxis1X*this.localAxis1Z+
this.localAxis1Y*this.localAxis1Y;a=1/Math.sqrt(this.localAngAxis1X*this.localAngAxis1X+this.localAngAxis1Y*this.localAngAxis1Y+this.localAngAxis1Z*this.localAngAxis1Z);this.localAngAxis1X*=a;this.localAngAxis1Y*=a;this.localAngAxis1Z*=a;this.localAxis2X=this.localAxis2.x;this.localAxis2Y=this.localAxis2.y;this.localAxis2Z=this.localAxis2.z;a=(new OIMO.Mat33).setQuat((new OIMO.Quat).arc(this.localAxis1,this.localAxis2)).elements;this.localAngAxis2X=this.localAngAxis1X*a[0]+this.localAngAxis1Y*a[1]+
this.localAngAxis1Z*a[2];this.localAngAxis2Y=this.localAngAxis1X*a[3]+this.localAngAxis1Y*a[4]+this.localAngAxis1Z*a[5];this.localAngAxis2Z=this.localAngAxis1X*a[6]+this.localAngAxis1Y*a[7]+this.localAngAxis1Z*a[8];this.type=this.joint.Joint.JOINT_SLIDER;this.nor=new OIMO.Vec3;this.tan=new OIMO.Vec3;this.bin=new OIMO.Vec3;this.rotationalLimitMotor=new OIMO.LimitMotor(this.nor,!1);this.r3=new OIMO.Rotational3Constraint(this,this.rotationalLimitMotor,new OIMO.LimitMotor(this.tan,!0),new OIMO.LimitMotor(this.bin,
!0));this.translationalLimitMotor=new OIMO.LimitMotor(this.nor,!0);this.translationalLimitMotor.lowerLimit=c;this.translationalLimitMotor.upperLimit=b;this.t3=new OIMO.Translational3Constraint(this,this.translationalLimitMotor,new OIMO.LimitMotor(this.tan,!0),new OIMO.LimitMotor(this.bin,!0))};OIMO.SliderJoint.prototype=Object.create(OIMO.Joint.prototype);
OIMO.SliderJoint.prototype.preSolve=function(a,c){var b,d,e;this.updateAnchorPoints();b=this.body1.rotation.elements;e=this.localAxis1X*b[0]+this.localAxis1Y*b[1]+this.localAxis1Z*b[2];var f=this.localAxis1X*b[3]+this.localAxis1Y*b[4]+this.localAxis1Z*b[5];d=this.localAxis1X*b[6]+this.localAxis1Y*b[7]+this.localAxis1Z*b[8];var g=this.localAngAxis1X*b[0]+this.localAngAxis1Y*b[1]+this.localAngAxis1Z*b[2],h=this.localAngAxis1X*b[3]+this.localAngAxis1Y*b[4]+this.localAngAxis1Z*b[5],k=this.localAngAxis1X*
b[6]+this.localAngAxis1Y*b[7]+this.localAngAxis1Z*b[8];b=this.body2.rotation.elements;var l=this.localAxis2X*b[0]+this.localAxis2Y*b[1]+this.localAxis2Z*b[2],n=this.localAxis2X*b[3]+this.localAxis2Y*b[4]+this.localAxis2Z*b[5],p=this.localAxis2X*b[6]+this.localAxis2Y*b[7]+this.localAxis2Z*b[8],m=this.localAngAxis2X*b[0]+this.localAngAxis2Y*b[1]+this.localAngAxis2Z*b[2],t=this.localAngAxis2X*b[3]+this.localAngAxis2Y*b[4]+this.localAngAxis2Z*b[5],r=this.localAngAxis2X*b[6]+this.localAngAxis2Y*b[7]+this.localAngAxis2Z*
b[8],w=e*this.body2.inverseMass+l*this.body1.inverseMass,u=f*this.body2.inverseMass+n*this.body1.inverseMass,y=d*this.body2.inverseMass+p*this.body1.inverseMass;b=Math.sqrt(w*w+u*u+y*y);0<b&&(b=1/b);var w=w*b,u=u*b,y=y*b,z=u*w-y*y,A=-y*u-w*w,E=w*y+u*u;b=1/Math.sqrt(z*z+A*A+E*E);var z=z*b,A=A*b,E=E*b,U=u*E-y*A,V=y*z-w*E,W=w*A-u*z;this.nor.init(w,u,y);this.tan.init(z,A,E);this.bin.init(U,V,W);this.rotationalLimitMotor.angle=0>w*(h*r-k*t)+u*(k*m-g*r)+y*(g*t-h*m)?-this.acosClamp(g*m+h*t+k*r):this.acosClamp(g*
m+h*t+k*r);b=f*p-d*n;d=d*l-e*p;e=e*n-f*l;this.r3.limitMotor2.angle=z*b+A*d+E*e;this.r3.limitMotor3.angle=U*b+V*d+W*e;this.r3.preSolve(a,c);this.t3.preSolve(a,c)};OIMO.SliderJoint.prototype.solve=function(){this.r3.solve();this.t3.solve()};OIMO.SliderJoint.prototype.postSolve=function(){};OIMO.SliderJoint.prototype.acosClamp=function(a){return 1<a?0:-1>a?Math.PI:Math.acos(a)};OIMO.WheelJoint=function(a){OIMO.Joint.call(this,a);this.localAxis1=(new OIMO.Vec3).normalize(a.localAxis1);this.localAxis2=(new OIMO.Vec3).normalize(a.localAxis2);this.localAxis1X=this.localAxis1.x;this.localAxis1Y=this.localAxis1.y;this.localAxis1Z=this.localAxis1.z;this.localAxis2X=this.localAxis2.x;this.localAxis2Y=this.localAxis2.y;this.localAxis2Z=this.localAxis2.z;a=this.localAxis1X*this.localAxis2X+this.localAxis1Y*this.localAxis2Y+this.localAxis1Z*this.localAxis2Z;-1<a&&1>a?(this.localAngAxis1X=
this.localAxis2X-a*this.localAxis1X,this.localAngAxis1Y=this.localAxis2Y-a*this.localAxis1Y,this.localAngAxis1Z=this.localAxis2Z-a*this.localAxis1Z,this.localAngAxis2X=this.localAxis1X-a*this.localAxis2X,this.localAngAxis2Y=this.localAxis1Y-a*this.localAxis2Y,this.localAngAxis2Z=this.localAxis1Z-a*this.localAxis2Z,a=1/Math.sqrt(this.localAngAxis1X*this.localAngAxis1X+this.localAngAxis1Y*this.localAngAxis1Y+this.localAngAxis1Z*this.localAngAxis1Z),this.localAngAxis1X*=a,this.localAngAxis1Y*=a,this.localAngAxis1Z*=
a,a=1/Math.sqrt(this.localAngAxis2X*this.localAngAxis2X+this.localAngAxis2Y*this.localAngAxis2Y+this.localAngAxis2Z*this.localAngAxis2Z),this.localAngAxis2X*=a,this.localAngAxis2Y*=a,this.localAngAxis2Z*=a):(this.localAngAxis1X=this.localAxis1Y*this.localAxis1X-this.localAxis1Z*this.localAxis1Z,this.localAngAxis1Y=-this.localAxis1Z*this.localAxis1Y-this.localAxis1X*this.localAxis1X,this.localAngAxis1Z=this.localAxis1X*this.localAxis1Z+this.localAxis1Y*this.localAxis1Y,a=1/Math.sqrt(this.localAngAxis1X*
this.localAngAxis1X+this.localAngAxis1Y*this.localAngAxis1Y+this.localAngAxis1Z*this.localAngAxis1Z),this.localAngAxis1X*=a,this.localAngAxis1Y*=a,this.localAngAxis1Z*=a,a=(new OIMO.Mat33).setQuat((new OIMO.Quat).arc(this.localAxis1,this.localAxis2)).elements,this.localAngAxis2X=this.localAngAxis1X*a[0]+this.localAngAxis1Y*a[1]+this.localAngAxis1Z*a[2],this.localAngAxis2Y=this.localAngAxis1X*a[3]+this.localAngAxis1Y*a[4]+this.localAngAxis1Z*a[5],this.localAngAxis2Z=this.localAngAxis1X*a[6]+this.localAngAxis1Y*
a[7]+this.localAngAxis1Z*a[8]);this.type=this.JOINT_WHEEL;this.nor=new OIMO.Vec3;this.tan=new OIMO.Vec3;this.bin=new OIMO.Vec3;this.translationalLimitMotor=new OIMO.LimitMotor(this.tan,!0);this.translationalLimitMotor.frequency=8;this.translationalLimitMotor.dampingRatio=1;this.rotationalLimitMotor1=new OIMO.LimitMotor(this.tan,!1);this.rotationalLimitMotor2=new OIMO.LimitMotor(this.bin,!1);this.t3=new OIMO.Translational3Constraint(this,new OIMO.LimitMotor(this.nor,!0),this.translationalLimitMotor,
new OIMO.LimitMotor(this.bin,!0));this.t3.weight=1;this.r3=new OIMO.Rotational3Constraint(this,new OIMO.LimitMotor(this.nor,!0),this.rotationalLimitMotor1,this.rotationalLimitMotor2)};OIMO.WheelJoint.prototype=Object.create(OIMO.Joint.prototype);
OIMO.WheelJoint.prototype.preSolve=function(a,c){var b,d;this.updateAnchorPoints();b=this.body1.rotation.elements;var e=this.localAxis1X*b[0]+this.localAxis1Y*b[1]+this.localAxis1Z*b[2],f=this.localAxis1X*b[3]+this.localAxis1Y*b[4]+this.localAxis1Z*b[5],g=this.localAxis1X*b[6]+this.localAxis1Y*b[7]+this.localAxis1Z*b[8];d=this.localAngAxis1X*b[0]+this.localAngAxis1Y*b[1]+this.localAngAxis1Z*b[2];var h=this.localAngAxis1X*b[3]+this.localAngAxis1Y*b[4]+this.localAngAxis1Z*b[5],k=this.localAngAxis1X*
b[6]+this.localAngAxis1Y*b[7]+this.localAngAxis1Z*b[8];b=this.body2.rotation.elements;var l=this.localAxis2X*b[0]+this.localAxis2Y*b[1]+this.localAxis2Z*b[2],n=this.localAxis2X*b[3]+this.localAxis2Y*b[4]+this.localAxis2Z*b[5],p=this.localAxis2X*b[6]+this.localAxis2Y*b[7]+this.localAxis2Z*b[8],m=this.localAngAxis2X*b[0]+this.localAngAxis2Y*b[1]+this.localAngAxis2Z*b[2],t=this.localAngAxis2X*b[3]+this.localAngAxis2Y*b[4]+this.localAngAxis2Z*b[5];b=this.localAngAxis2X*b[6]+this.localAngAxis2Y*b[7]+this.localAngAxis2Z*
b[8];this.r3.limitMotor1.angle=e*l+f*n+g*p;this.rotationalLimitMotor1.angle=0>e*(h*p-k*n)+f*(k*l-d*p)+g*(d*n-h*l)?-this.acosClamp(d*l+h*n+k*p):this.acosClamp(d*l+h*n+k*p);this.rotationalLimitMotor2.angle=0>l*(t*g-b*f)+n*(b*e-m*g)+p*(m*f-t*e)?this.acosClamp(m*e+t*f+b*g):-this.acosClamp(m*e+t*f+b*g);h=n*g-p*f;k=p*e-l*g;m=l*f-n*e;d=Math.sqrt(h*h+k*k+m*m);0<d&&(d=1/d);h*=d;k*=d;m*=d;t=k*p-m*n;p=m*l-h*p;l=h*n-k*l;d=Math.sqrt(t*t+p*p+l*l);0<d&&(d=1/d);t*=d;p*=d;l*=d;n=f*m-g*k;g=g*h-e*m;e=e*k-f*h;d=Math.sqrt(n*
n+g*g+e*e);0<d&&(d=1/d);n*=d;g*=d;e*=d;this.nor.init(h,k,m);this.tan.init(t,p,l);this.bin.init(n,g,e);this.r3.preSolve(a,c);this.t3.preSolve(a,c)};OIMO.WheelJoint.prototype.solve=function(){this.r3.solve();this.t3.solve()};OIMO.WheelJoint.prototype.postSolve=function(){};OIMO.WheelJoint.prototype.acosClamp=function(a){return 1<a?0:-1>a?Math.PI:Math.acos(a)};OIMO.AngularConstraint=function(a,c){this.velz=this.vely=this.velx=this.az=this.ay=this.ax=this.d22=this.d21=this.d20=this.d12=this.d11=this.d10=this.d02=this.d01=this.d00=this.i2e22=this.i2e21=this.i2e20=this.i2e12=this.i2e11=this.i2e10=this.i2e02=this.i2e01=this.i2e00=this.i1e22=this.i1e21=this.i1e20=this.i1e12=this.i1e11=this.i1e10=this.i1e02=this.i1e01=this.i1e00=NaN;this.joint=a;this.targetOrientation=(new OIMO.Quat).invert(c);this.relativeOrientation=new OIMO.Quat;this.b1=a.body1;this.b2=a.body2;
this.a1=this.b1.angularVelocity;this.a2=this.b2.angularVelocity;this.i1=this.b1.inverseInertia;this.i2=this.b2.inverseInertia;this.impz=this.impy=this.impx=0};
OIMO.AngularConstraint.prototype={constructor:OIMO.AngularConstraint,preSolve:function(a,c){var b=this.i1.elements,d=this.i2.elements;this.i1e00=b[0];this.i1e01=b[1];this.i1e02=b[2];this.i1e10=b[3];this.i1e11=b[4];this.i1e12=b[5];this.i1e20=b[6];this.i1e21=b[7];this.i1e22=b[8];this.i2e00=d[0];this.i2e01=d[1];this.i2e02=d[2];this.i2e10=d[3];this.i2e11=d[4];this.i2e12=d[5];this.i2e20=d[6];this.i2e21=d[7];this.i2e22=d[8];var b=this.i1e00+this.i2e00,d=this.i1e01+this.i2e01,e=this.i1e02+this.i2e02,f=this.i1e10+
this.i2e10,g=this.i1e11+this.i2e11,h=this.i1e12+this.i2e12,k=this.i1e20+this.i2e20,l=this.i1e21+this.i2e21,n=this.i1e22+this.i2e22,p=1/(b*(g*n-l*h)+f*(l*e-d*n)+k*(d*h-g*e));this.d00=(g*n-h*l)*p;this.d01=(e*l-d*n)*p;this.d02=(d*h-e*g)*p;this.d10=(h*k-f*n)*p;this.d11=(b*n-e*k)*p;this.d12=(e*f-b*h)*p;this.d20=(f*l-g*k)*p;this.d21=(d*k-b*l)*p;this.d22=(b*g-d*f)*p;this.relativeOrientation.invert(this.b1.orientation);this.relativeOrientation.mul(this.targetOrientation,this.relativeOrientation);this.relativeOrientation.mul(this.b2.orientation,
this.relativeOrientation);p=2*this.relativeOrientation.s;this.velx=this.relativeOrientation.x*p;this.vely=this.relativeOrientation.y*p;this.velz=this.relativeOrientation.z*p;b=Math.sqrt(this.velx*this.velx+this.vely*this.vely+this.velz*this.velz);0.02<b?(b=(0.02-b)/b*c*0.05,this.velx*=b,this.vely*=b,this.velz*=b):this.velz=this.vely=this.velx=0;this.a1.x+=this.impx*this.i1e00+this.impy*this.i1e01+this.impz*this.i1e02;this.a1.y+=this.impx*this.i1e10+this.impy*this.i1e11+this.impz*this.i1e12;this.a1.z+=
this.impx*this.i1e20+this.impy*this.i1e21+this.impz*this.i1e22;this.a2.x-=this.impx*this.i2e00+this.impy*this.i2e01+this.impz*this.i2e02;this.a2.y-=this.impx*this.i2e10+this.impy*this.i2e11+this.impz*this.i2e12;this.a2.z-=this.impx*this.i2e20+this.impy*this.i2e21+this.impz*this.i2e22},solve:function(){var a=this.a2.x-this.a1.x-this.velx,c=this.a2.y-this.a1.y-this.vely,b=this.a2.z-this.a1.z-this.velz,d=a*this.d00+c*this.d01+b*this.d02,e=a*this.d10+c*this.d11+b*this.d12,a=a*this.d20+c*this.d21+b*this.d22;
this.impx+=d;this.impy+=e;this.impz+=a;this.a1.x+=d*this.i1e00+e*this.i1e01+a*this.i1e02;this.a1.y+=d*this.i1e10+e*this.i1e11+a*this.i1e12;this.a1.z+=d*this.i1e20+e*this.i1e21+a*this.i1e22;this.a2.x-=d*this.i2e00+e*this.i2e01+a*this.i2e02;this.a2.y-=d*this.i2e10+e*this.i2e11+a*this.i2e12;this.a2.z-=d*this.i2e20+e*this.i2e21+a*this.i2e22}};OIMO.LinearConstraint=function(a){this.velz=this.vely=this.velx=this.vel=this.az2z=this.az2y=this.az2x=this.ay2z=this.ay2y=this.ay2x=this.ax2z=this.ax2y=this.ax2x=this.az1z=this.az1y=this.az1x=this.ay1z=this.ay1y=this.ay1x=this.ax1z=this.ax1y=this.ax1x=this.r2z=this.r2y=this.r2x=this.r1z=this.r1y=this.r1x=this.d22=this.d21=this.d20=this.d12=this.d11=this.d10=this.d02=this.d01=this.d00=this.i2e22=this.i2e21=this.i2e20=this.i2e12=this.i2e11=this.i2e10=this.i2e02=this.i2e01=this.i2e00=this.i1e22=this.i1e21=
this.i1e20=this.i1e12=this.i1e11=this.i1e10=this.i1e02=this.i1e01=this.i1e00=this.m2=this.m1=NaN;this.joint=a;this.r1=a.relativeAnchorPoint1;this.r2=a.relativeAnchorPoint2;this.p1=a.anchorPoint1;this.p2=a.anchorPoint2;this.b1=a.body1;this.b2=a.body2;this.l1=this.b1.linearVelocity;this.l2=this.b2.linearVelocity;this.a1=this.b1.angularVelocity;this.a2=this.b2.angularVelocity;this.i1=this.b1.inverseInertia;this.i2=this.b2.inverseInertia;this.impz=this.impy=this.impx=0};
OIMO.LinearConstraint.prototype={constructor:OIMO.LinearConstraint,preSolve:function(a,c){this.r1x=this.r1.x;this.r1y=this.r1.y;this.r1z=this.r1.z;this.r2x=this.r2.x;this.r2y=this.r2.y;this.r2z=this.r2.z;this.m1=this.b1.inverseMass;this.m2=this.b2.inverseMass;var b=this.i1.elements,d=this.i2.elements;this.i1e00=b[0];this.i1e01=b[1];this.i1e02=b[2];this.i1e10=b[3];this.i1e11=b[4];this.i1e12=b[5];this.i1e20=b[6];this.i1e21=b[7];this.i1e22=b[8];this.i2e00=d[0];this.i2e01=d[1];this.i2e02=d[2];this.i2e10=
d[3];this.i2e11=d[4];this.i2e12=d[5];this.i2e20=d[6];this.i2e21=d[7];this.i2e22=d[8];this.ax1x=this.r1z*this.i1e01+-this.r1y*this.i1e02;this.ax1y=this.r1z*this.i1e11+-this.r1y*this.i1e12;this.ax1z=this.r1z*this.i1e21+-this.r1y*this.i1e22;this.ay1x=-this.r1z*this.i1e00+this.r1x*this.i1e02;this.ay1y=-this.r1z*this.i1e10+this.r1x*this.i1e12;this.ay1z=-this.r1z*this.i1e20+this.r1x*this.i1e22;this.az1x=this.r1y*this.i1e00+-this.r1x*this.i1e01;this.az1y=this.r1y*this.i1e10+-this.r1x*this.i1e11;this.az1z=
this.r1y*this.i1e20+-this.r1x*this.i1e21;this.ax2x=this.r2z*this.i2e01+-this.r2y*this.i2e02;this.ax2y=this.r2z*this.i2e11+-this.r2y*this.i2e12;this.ax2z=this.r2z*this.i2e21+-this.r2y*this.i2e22;this.ay2x=-this.r2z*this.i2e00+this.r2x*this.i2e02;this.ay2y=-this.r2z*this.i2e10+this.r2x*this.i2e12;this.ay2z=-this.r2z*this.i2e20+this.r2x*this.i2e22;this.az2x=this.r2y*this.i2e00+-this.r2x*this.i2e01;this.az2y=this.r2y*this.i2e10+-this.r2x*this.i2e11;this.az2z=this.r2y*this.i2e20+-this.r2x*this.i2e21;var b=
this.m1+this.m2,e,f,g=b,h,k,l,n=b,b=b+(this.i1e11*this.r1z*this.r1z-(this.i1e21+this.i1e12)*this.r1y*this.r1z+this.i1e22*this.r1y*this.r1y),d=0+((this.i1e20*this.r1y+this.i1e12*this.r1x)*this.r1z-this.i1e10*this.r1z*this.r1z-this.i1e22*this.r1x*this.r1y);e=0+((this.i1e10*this.r1y-this.i1e11*this.r1x)*this.r1z-this.i1e20*this.r1y*this.r1y+this.i1e21*this.r1x*this.r1y);f=0+((this.i1e02*this.r1y+this.i1e21*this.r1x)*this.r1z-this.i1e01*this.r1z*this.r1z-this.i1e22*this.r1x*this.r1y);g+=this.i1e00*this.r1z*
this.r1z-(this.i1e20+this.i1e02)*this.r1x*this.r1z+this.i1e22*this.r1x*this.r1x;h=0+((this.i1e01*this.r1x-this.i1e00*this.r1y)*this.r1z-this.i1e21*this.r1x*this.r1x+this.i1e20*this.r1x*this.r1y);k=0+((this.i1e01*this.r1y-this.i1e11*this.r1x)*this.r1z-this.i1e02*this.r1y*this.r1y+this.i1e12*this.r1x*this.r1y);l=0+((this.i1e10*this.r1x-this.i1e00*this.r1y)*this.r1z-this.i1e12*this.r1x*this.r1x+this.i1e02*this.r1x*this.r1y);n+=this.i1e00*this.r1y*this.r1y-(this.i1e10+this.i1e01)*this.r1x*this.r1y+this.i1e11*
this.r1x*this.r1x;b+=this.i2e11*this.r2z*this.r2z-(this.i2e21+this.i2e12)*this.r2y*this.r2z+this.i2e22*this.r2y*this.r2y;d+=(this.i2e20*this.r2y+this.i2e12*this.r2x)*this.r2z-this.i2e10*this.r2z*this.r2z-this.i2e22*this.r2x*this.r2y;e+=(this.i2e10*this.r2y-this.i2e11*this.r2x)*this.r2z-this.i2e20*this.r2y*this.r2y+this.i2e21*this.r2x*this.r2y;f+=(this.i2e02*this.r2y+this.i2e21*this.r2x)*this.r2z-this.i2e01*this.r2z*this.r2z-this.i2e22*this.r2x*this.r2y;g+=this.i2e00*this.r2z*this.r2z-(this.i2e20+
this.i2e02)*this.r2x*this.r2z+this.i2e22*this.r2x*this.r2x;h+=(this.i2e01*this.r2x-this.i2e00*this.r2y)*this.r2z-this.i2e21*this.r2x*this.r2x+this.i2e20*this.r2x*this.r2y;k+=(this.i2e01*this.r2y-this.i2e11*this.r2x)*this.r2z-this.i2e02*this.r2y*this.r2y+this.i2e12*this.r2x*this.r2y;l+=(this.i2e10*this.r2x-this.i2e00*this.r2y)*this.r2z-this.i2e12*this.r2x*this.r2x+this.i2e02*this.r2x*this.r2y;var n=n+(this.i2e00*this.r2y*this.r2y-(this.i2e10+this.i2e01)*this.r2x*this.r2y+this.i2e11*this.r2x*this.r2x),
p=1/(b*(g*n-l*h)+f*(l*e-d*n)+k*(d*h-g*e));this.d00=(g*n-h*l)*p;this.d01=(e*l-d*n)*p;this.d02=(d*h-e*g)*p;this.d10=(h*k-f*n)*p;this.d11=(b*n-e*k)*p;this.d12=(e*f-b*h)*p;this.d20=(f*l-g*k)*p;this.d21=(d*k-b*l)*p;this.d22=(b*g-d*f)*p;this.velx=this.p2.x-this.p1.x;this.vely=this.p2.y-this.p1.y;this.velz=this.p2.z-this.p1.z;b=Math.sqrt(this.velx*this.velx+this.vely*this.vely+this.velz*this.velz);0.005<b?(b=(0.005-b)/b*c*0.05,this.velx*=b,this.vely*=b,this.velz*=b):this.velz=this.vely=this.velx=0;this.impx*=
0.95;this.impy*=0.95;this.impz*=0.95;this.l1.x+=this.impx*this.m1;this.l1.y+=this.impy*this.m1;this.l1.z+=this.impz*this.m1;this.a1.x+=this.impx*this.ax1x+this.impy*this.ay1x+this.impz*this.az1x;this.a1.y+=this.impx*this.ax1y+this.impy*this.ay1y+this.impz*this.az1y;this.a1.z+=this.impx*this.ax1z+this.impy*this.ay1z+this.impz*this.az1z;this.l2.x-=this.impx*this.m2;this.l2.y-=this.impy*this.m2;this.l2.z-=this.impz*this.m2;this.a2.x-=this.impx*this.ax2x+this.impy*this.ay2x+this.impz*this.az2x;this.a2.y-=
this.impx*this.ax2y+this.impy*this.ay2y+this.impz*this.az2y;this.a2.z-=this.impx*this.ax2z+this.impy*this.ay2z+this.impz*this.az2z},solve:function(){var a=this.l2.x-this.l1.x+this.a2.y*this.r2z-this.a2.z*this.r2y-this.a1.y*this.r1z+this.a1.z*this.r1y-this.velx,c=this.l2.y-this.l1.y+this.a2.z*this.r2x-this.a2.x*this.r2z-this.a1.z*this.r1x+this.a1.x*this.r1z-this.vely,b=this.l2.z-this.l1.z+this.a2.x*this.r2y-this.a2.y*this.r2x-this.a1.x*this.r1y+this.a1.y*this.r1x-this.velz,d=a*this.d00+c*this.d01+
b*this.d02,e=a*this.d10+c*this.d11+b*this.d12,a=a*this.d20+c*this.d21+b*this.d22;this.impx+=d;this.impy+=e;this.impz+=a;this.l1.x+=d*this.m1;this.l1.y+=e*this.m1;this.l1.z+=a*this.m1;this.a1.x+=d*this.ax1x+e*this.ay1x+a*this.az1x;this.a1.y+=d*this.ax1y+e*this.ay1y+a*this.az1y;this.a1.z+=d*this.ax1z+e*this.ay1z+a*this.az1z;this.l2.x-=d*this.m2;this.l2.y-=e*this.m2;this.l2.z-=a*this.m2;this.a2.x-=d*this.ax2x+e*this.ay2x+a*this.az2x;this.a2.y-=d*this.ax2y+e*this.ay2y+a*this.az2y;this.a2.z-=d*this.ax2z+
e*this.ay2z+a*this.az2z}};OIMO.Rotational3Constraint=function(a,c,b,d){this.limitVelocity1=this.upperLimit1=this.lowerLimit1=this.a2z3=this.a2y3=this.a2x3=this.a1z3=this.a1y3=this.a1x3=this.a2z2=this.a2y2=this.a2x2=this.a1z2=this.a1y2=this.a1x2=this.a2z1=this.a2y1=this.a2x1=this.a1z1=this.a1y1=this.a1x1=this.az3=this.ay3=this.ax3=this.az2=this.ay2=this.ax2=this.az1=this.ay1=this.ax1=this.i2e22=this.i2e21=this.i2e20=this.i2e12=this.i2e11=this.i2e10=this.i2e02=this.i2e01=this.i2e00=this.i1e22=this.i1e21=this.i1e20=this.i1e12=
this.i1e11=this.i1e10=this.i1e02=this.i1e01=this.i1e00=this.cfm3=this.cfm2=this.cfm1=NaN;this.limitState1=0;this.enableMotor1=!1;this.limitVelocity2=this.upperLimit2=this.lowerLimit2=this.maxMotorImpulse1=this.maxMotorForce1=this.motorSpeed1=NaN;this.limitState2=0;this.enableMotor2=!1;this.limitVelocity3=this.upperLimit3=this.lowerLimit3=this.maxMotorImpulse2=this.maxMotorForce2=this.motorSpeed2=NaN;this.limitState3=0;this.enableMotor3=!1;this.d22=this.d21=this.d20=this.d12=this.d11=this.d10=this.d02=
this.d01=this.d00=this.dv22=this.dv11=this.dv00=this.kv22=this.kv11=this.kv00=this.k22=this.k21=this.k20=this.k12=this.k11=this.k10=this.k02=this.k01=this.k00=this.maxMotorImpulse3=this.maxMotorForce3=this.motorSpeed3=NaN;this.limitMotor1=c;this.limitMotor2=b;this.limitMotor3=d;this.b1=a.body1;this.b2=a.body2;this.a1=this.b1.angularVelocity;this.a2=this.b2.angularVelocity;this.i1=this.b1.inverseInertia;this.i2=this.b2.inverseInertia;this.motorImpulse3=this.limitImpulse3=this.motorImpulse2=this.limitImpulse2=
this.motorImpulse1=this.limitImpulse1=0};
OIMO.Rotational3Constraint.prototype={constructor:OIMO.Rotational3Constraint,preSolve:function(a,c){this.ax1=this.limitMotor1.axis.x;this.ay1=this.limitMotor1.axis.y;this.az1=this.limitMotor1.axis.z;this.ax2=this.limitMotor2.axis.x;this.ay2=this.limitMotor2.axis.y;this.az2=this.limitMotor2.axis.z;this.ax3=this.limitMotor3.axis.x;this.ay3=this.limitMotor3.axis.y;this.az3=this.limitMotor3.axis.z;this.lowerLimit1=this.limitMotor1.lowerLimit;this.upperLimit1=this.limitMotor1.upperLimit;this.motorSpeed1=
this.limitMotor1.motorSpeed;this.maxMotorForce1=this.limitMotor1.maxMotorForce;this.enableMotor1=0<this.maxMotorForce1;this.lowerLimit2=this.limitMotor2.lowerLimit;this.upperLimit2=this.limitMotor2.upperLimit;this.motorSpeed2=this.limitMotor2.motorSpeed;this.maxMotorForce2=this.limitMotor2.maxMotorForce;this.enableMotor2=0<this.maxMotorForce2;this.lowerLimit3=this.limitMotor3.lowerLimit;this.upperLimit3=this.limitMotor3.upperLimit;this.motorSpeed3=this.limitMotor3.motorSpeed;this.maxMotorForce3=this.limitMotor3.maxMotorForce;
this.enableMotor3=0<this.maxMotorForce3;var b=this.i1.elements,d=this.i2.elements;this.i1e00=b[0];this.i1e01=b[1];this.i1e02=b[2];this.i1e10=b[3];this.i1e11=b[4];this.i1e12=b[5];this.i1e20=b[6];this.i1e21=b[7];this.i1e22=b[8];this.i2e00=d[0];this.i2e01=d[1];this.i2e02=d[2];this.i2e10=d[3];this.i2e11=d[4];this.i2e12=d[5];this.i2e20=d[6];this.i2e21=d[7];this.i2e22=d[8];var e=this.limitMotor1.frequency,b=this.limitMotor2.frequency,d=this.limitMotor3.frequency,f=0<e,g=0<b,h=0<d,k=this.lowerLimit2<=this.upperLimit2,
l=this.lowerLimit3<=this.upperLimit3,n=this.limitMotor1.angle;this.lowerLimit1<=this.upperLimit1?(this.lowerLimit1==this.upperLimit1?(0!=this.limitState1&&(this.limitImpulse1=this.limitState1=0),this.limitVelocity1=this.lowerLimit1-n):n<this.lowerLimit1?(-1!=this.limitState1&&(this.limitState1=-1,this.limitImpulse1=0),this.limitVelocity1=this.lowerLimit1-n):n>this.upperLimit1?(1!=this.limitState1&&(this.limitState1=1,this.limitImpulse1=0),this.limitVelocity1=this.upperLimit1-n):(this.limitState1=
2,this.limitVelocity1=this.limitImpulse1=0),f||(this.limitVelocity1=0.02<this.limitVelocity1?this.limitVelocity1-0.02:-0.02>this.limitVelocity1?this.limitVelocity1+0.02:0)):(this.limitState1=2,this.limitImpulse1=0);n=this.limitMotor2.angle;k?(this.lowerLimit2==this.upperLimit2?(0!=this.limitState2&&(this.limitImpulse2=this.limitState2=0),this.limitVelocity2=this.lowerLimit2-n):n<this.lowerLimit2?(-1!=this.limitState2&&(this.limitState2=-1,this.limitImpulse2=0),this.limitVelocity2=this.lowerLimit2-
n):n>this.upperLimit2?(1!=this.limitState2&&(this.limitState2=1,this.limitImpulse2=0),this.limitVelocity2=this.upperLimit2-n):(this.limitState2=2,this.limitVelocity2=this.limitImpulse2=0),g||(this.limitVelocity2=0.02<this.limitVelocity2?this.limitVelocity2-0.02:-0.02>this.limitVelocity2?this.limitVelocity2+0.02:0)):(this.limitState2=2,this.limitImpulse2=0);k=this.limitMotor3.angle;l?(this.lowerLimit3==this.upperLimit3?(0!=this.limitState3&&(this.limitImpulse3=this.limitState3=0),this.limitVelocity3=
this.lowerLimit3-k):k<this.lowerLimit3?(-1!=this.limitState3&&(this.limitState3=-1,this.limitImpulse3=0),this.limitVelocity3=this.lowerLimit3-k):k>this.upperLimit3?(1!=this.limitState3&&(this.limitState3=1,this.limitImpulse3=0),this.limitVelocity3=this.upperLimit3-k):(this.limitState3=2,this.limitVelocity3=this.limitImpulse3=0),h||(this.limitVelocity3=0.02<this.limitVelocity3?this.limitVelocity3-0.02:-0.02>this.limitVelocity3?this.limitVelocity3+0.02:0)):(this.limitState3=2,this.limitImpulse3=0);
this.maxMotorImpulse1=this.enableMotor1&&(0!=this.limitState1||f)?this.maxMotorForce1*a:this.motorImpulse1=0;this.maxMotorImpulse2=this.enableMotor2&&(0!=this.limitState2||g)?this.maxMotorForce2*a:this.motorImpulse2=0;this.maxMotorImpulse3=this.enableMotor3&&(0!=this.limitState3||h)?this.maxMotorForce3*a:this.motorImpulse3=0;this.a1x1=this.ax1*this.i1e00+this.ay1*this.i1e01+this.az1*this.i1e02;this.a1y1=this.ax1*this.i1e10+this.ay1*this.i1e11+this.az1*this.i1e12;this.a1z1=this.ax1*this.i1e20+this.ay1*
this.i1e21+this.az1*this.i1e22;this.a2x1=this.ax1*this.i2e00+this.ay1*this.i2e01+this.az1*this.i2e02;this.a2y1=this.ax1*this.i2e10+this.ay1*this.i2e11+this.az1*this.i2e12;this.a2z1=this.ax1*this.i2e20+this.ay1*this.i2e21+this.az1*this.i2e22;this.a1x2=this.ax2*this.i1e00+this.ay2*this.i1e01+this.az2*this.i1e02;this.a1y2=this.ax2*this.i1e10+this.ay2*this.i1e11+this.az2*this.i1e12;this.a1z2=this.ax2*this.i1e20+this.ay2*this.i1e21+this.az2*this.i1e22;this.a2x2=this.ax2*this.i2e00+this.ay2*this.i2e01+
this.az2*this.i2e02;this.a2y2=this.ax2*this.i2e10+this.ay2*this.i2e11+this.az2*this.i2e12;this.a2z2=this.ax2*this.i2e20+this.ay2*this.i2e21+this.az2*this.i2e22;this.a1x3=this.ax3*this.i1e00+this.ay3*this.i1e01+this.az3*this.i1e02;this.a1y3=this.ax3*this.i1e10+this.ay3*this.i1e11+this.az3*this.i1e12;this.a1z3=this.ax3*this.i1e20+this.ay3*this.i1e21+this.az3*this.i1e22;this.a2x3=this.ax3*this.i2e00+this.ay3*this.i2e01+this.az3*this.i2e02;this.a2y3=this.ax3*this.i2e10+this.ay3*this.i2e11+this.az3*this.i2e12;
this.a2z3=this.ax3*this.i2e20+this.ay3*this.i2e21+this.az3*this.i2e22;this.k00=this.ax1*(this.a1x1+this.a2x1)+this.ay1*(this.a1y1+this.a2y1)+this.az1*(this.a1z1+this.a2z1);this.k01=this.ax1*(this.a1x2+this.a2x2)+this.ay1*(this.a1y2+this.a2y2)+this.az1*(this.a1z2+this.a2z2);this.k02=this.ax1*(this.a1x3+this.a2x3)+this.ay1*(this.a1y3+this.a2y3)+this.az1*(this.a1z3+this.a2z3);this.k10=this.ax2*(this.a1x1+this.a2x1)+this.ay2*(this.a1y1+this.a2y1)+this.az2*(this.a1z1+this.a2z1);this.k11=this.ax2*(this.a1x2+
this.a2x2)+this.ay2*(this.a1y2+this.a2y2)+this.az2*(this.a1z2+this.a2z2);this.k12=this.ax2*(this.a1x3+this.a2x3)+this.ay2*(this.a1y3+this.a2y3)+this.az2*(this.a1z3+this.a2z3);this.k20=this.ax3*(this.a1x1+this.a2x1)+this.ay3*(this.a1y1+this.a2y1)+this.az3*(this.a1z1+this.a2z1);this.k21=this.ax3*(this.a1x2+this.a2x2)+this.ay3*(this.a1y2+this.a2y2)+this.az3*(this.a1z2+this.a2z2);this.k22=this.ax3*(this.a1x3+this.a2x3)+this.ay3*(this.a1y3+this.a2y3)+this.az3*(this.a1z3+this.a2z3);this.kv00=this.k00;this.kv11=
this.k11;this.kv22=this.k22;this.dv00=1/this.kv00;this.dv11=1/this.kv11;this.dv22=1/this.kv22;f&&2!=this.limitState1?(f=6.2831853*e,e=f*f*a,f=c/(e+2*this.limitMotor1.dampingRatio*f),this.cfm1=this.kv00*f,this.limitVelocity1=this.limitVelocity1*e*f):(this.cfm1=0,this.limitVelocity1=0.05*this.limitVelocity1*c);g&&2!=this.limitState2?(f=6.2831853*b,e=f*f*a,f=c/(e+2*this.limitMotor2.dampingRatio*f),this.cfm2=this.kv11*f,this.limitVelocity2=this.limitVelocity2*e*f):(this.cfm2=0,this.limitVelocity2=0.05*
this.limitVelocity2*c);h&&2!=this.limitState3?(f=6.2831853*d,e=f*f*a,f=c/(e+2*this.limitMotor3.dampingRatio*f),this.cfm3=this.kv22*f,this.limitVelocity3=this.limitVelocity3*e*f):(this.cfm3=0,this.limitVelocity3=0.05*this.limitVelocity3*c);this.k00+=this.cfm1;this.k11+=this.cfm2;this.k22+=this.cfm3;b=1/(this.k00*(this.k11*this.k22-this.k21*this.k12)+this.k10*(this.k21*this.k02-this.k01*this.k22)+this.k20*(this.k01*this.k12-this.k11*this.k02));this.d00=(this.k11*this.k22-this.k12*this.k21)*b;this.d01=
(this.k02*this.k21-this.k01*this.k22)*b;this.d02=(this.k01*this.k12-this.k02*this.k11)*b;this.d10=(this.k12*this.k20-this.k10*this.k22)*b;this.d11=(this.k00*this.k22-this.k02*this.k20)*b;this.d12=(this.k02*this.k10-this.k00*this.k12)*b;this.d20=(this.k10*this.k21-this.k11*this.k20)*b;this.d21=(this.k01*this.k20-this.k00*this.k21)*b;this.d22=(this.k00*this.k11-this.k01*this.k10)*b;this.limitImpulse1*=0.95;this.motorImpulse1*=0.95;this.limitImpulse2*=0.95;this.motorImpulse2*=0.95;this.limitImpulse3*=
0.95;this.motorImpulse3*=0.95;b=this.limitImpulse1+this.motorImpulse1;d=this.limitImpulse2+this.motorImpulse2;g=this.limitImpulse3+this.motorImpulse3;this.a1.x+=b*this.a1x1+d*this.a1x2+g*this.a1x3;this.a1.y+=b*this.a1y1+d*this.a1y2+g*this.a1y3;this.a1.z+=b*this.a1z1+d*this.a1z2+g*this.a1z3;this.a2.x-=b*this.a2x1+d*this.a2x2+g*this.a2x3;this.a2.y-=b*this.a2y1+d*this.a2y2+g*this.a2y3;this.a2.z-=b*this.a2z1+d*this.a2z2+g*this.a2z3},solve_:function(){var a=this.a2.x-this.a1.x,c=this.a2.y-this.a1.y,b=
this.a2.z-this.a1.z;this.limitVelocity3=30;var d=a*this.ax1+c*this.ay1+b*this.az1-this.limitVelocity1,e=a*this.ax2+c*this.ay2+b*this.az2-this.limitVelocity2,b=a*this.ax3+c*this.ay3+b*this.az3-this.limitVelocity3,a=d*this.d00+e*this.d01+b*this.d02,c=d*this.d10+e*this.d11+b*this.d12,d=d*this.d20+e*this.d21+b*this.d22;this.limitImpulse1+=a;this.limitImpulse2+=c;this.limitImpulse3+=d;this.a1.x+=a*this.a1x1+c*this.a1x2+d*this.a1x3;this.a1.y+=a*this.a1y1+c*this.a1y2+d*this.a1y3;this.a1.z+=a*this.a1z1+c*
this.a1z2+d*this.a1z3;this.a2.x-=a*this.a2x1+c*this.a2x2+d*this.a2x3;this.a2.y-=a*this.a2y1+c*this.a2y2+d*this.a2y3;this.a2.z-=a*this.a2z1+c*this.a2z2+d*this.a2z3},solve:function(){var a=this.a2.x-this.a1.x,c=this.a2.y-this.a1.y,b=this.a2.z-this.a1.z,d=a*this.ax1+c*this.ay1+b*this.az1,e=a*this.ax2+c*this.ay2+b*this.az2,b=a*this.ax3+c*this.ay3+b*this.az3,f=this.motorImpulse1,g=this.motorImpulse2,h=this.motorImpulse3,k=0,a=c=0;this.enableMotor1&&(k=(d-this.motorSpeed1)*this.dv00,this.motorImpulse1+=
k,this.motorImpulse1>this.maxMotorImpulse1?this.motorImpulse1=this.maxMotorImpulse1:this.motorImpulse1<-this.maxMotorImpulse1&&(this.motorImpulse1=-this.maxMotorImpulse1),k=this.motorImpulse1-f);this.enableMotor2&&(c=(e-this.motorSpeed2)*this.dv11,this.motorImpulse2+=c,this.motorImpulse2>this.maxMotorImpulse2?this.motorImpulse2=this.maxMotorImpulse2:this.motorImpulse2<-this.maxMotorImpulse2&&(this.motorImpulse2=-this.maxMotorImpulse2),c=this.motorImpulse2-g);this.enableMotor3&&(a=(b-this.motorSpeed3)*
this.dv22,this.motorImpulse3+=a,this.motorImpulse3>this.maxMotorImpulse3?this.motorImpulse3=this.maxMotorImpulse3:this.motorImpulse3<-this.maxMotorImpulse3&&(this.motorImpulse3=-this.maxMotorImpulse3),a=this.motorImpulse3-h);var d=d+(k*this.kv00+c*this.k01+a*this.k02),e=e+(k*this.k10+c*this.kv11+a*this.k12),b=b+(k*this.k20+c*this.k21+a*this.kv22),d=d-(this.limitVelocity1+this.limitImpulse1*this.cfm1),e=e-(this.limitVelocity2+this.limitImpulse2*this.cfm2),b=b-(this.limitVelocity3+this.limitImpulse3*
this.cfm3),h=this.limitImpulse1,l=this.limitImpulse2,n=this.limitImpulse3,p=d*this.d00+e*this.d01+b*this.d02,g=d*this.d10+e*this.d11+b*this.d12,f=d*this.d20+e*this.d21+b*this.d22;this.limitImpulse1+=p;this.limitImpulse2+=g;this.limitImpulse3+=f;var m=0;if(2==this.limitState1||0>this.limitImpulse1*this.limitState1)p=-h,e+=p*this.k10,b+=p*this.k20,m|=1;if(2==this.limitState2||0>this.limitImpulse2*this.limitState2)g=-l,d+=g*this.k01,b+=g*this.k21,m|=2;if(2==this.limitState3||0>this.limitImpulse3*this.limitState3)f=
-n,d+=f*this.k02,e+=f*this.k12,m|=4;switch(m){case 1:m=1/(this.k11*this.k22-this.k12*this.k21);g=(this.k22*e+-this.k12*b)*m;f=(-this.k21*e+this.k11*b)*m;break;case 2:m=1/(this.k00*this.k22-this.k02*this.k20);p=(this.k22*d+-this.k02*b)*m;f=(-this.k20*d+this.k00*b)*m;break;case 3:f=b/this.k22;break;case 4:m=1/(this.k00*this.k11-this.k01*this.k10);p=(this.k11*d+-this.k01*e)*m;g=(-this.k10*d+this.k00*e)*m;break;case 5:g=e/this.k11;break;case 6:p=d/this.k00}this.limitImpulse1=p+h;this.limitImpulse2=g+
l;this.limitImpulse3=f+n;d=k+p;e=c+g;a+=f;this.a1.x+=d*this.a1x1+e*this.a1x2+a*this.a1x3;this.a1.y+=d*this.a1y1+e*this.a1y2+a*this.a1y3;this.a1.z+=d*this.a1z1+e*this.a1z2+a*this.a1z3;this.a2.x-=d*this.a2x1+e*this.a2x2+a*this.a2x3;this.a2.y-=d*this.a2y1+e*this.a2y2+a*this.a2y3;this.a2.z-=d*this.a2z1+e*this.a2z2+a*this.a2z3}};OIMO.RotationalConstraint=function(a,c){this.a2z=this.a2y=this.a2x=this.a1z=this.a1y=this.a1x=this.az=this.ay=this.ax=this.invDenom=this.invMotorDenom=this.motorDenom=this.i2e22=this.i2e21=this.i2e20=this.i2e12=this.i2e11=this.i2e10=this.i2e02=this.i2e01=this.i2e00=this.i1e22=this.i1e21=this.i1e20=this.i1e12=this.i1e11=this.i1e10=this.i1e02=this.i1e01=this.i1e00=this.cfm=NaN;this.enableLimit=!1;this.limitVelocity=this.upperLimit=this.lowerLimit=NaN;this.limitState=0;this.enableMotor=!1;this.maxMotorImpulse=
this.maxMotorForce=this.motorSpeed=NaN;this.limitMotor=c;this.b1=a.body1;this.b2=a.body2;this.a1=this.b1.angularVelocity;this.a2=this.b2.angularVelocity;this.i1=this.b1.inverseInertia;this.i2=this.b2.inverseInertia;this.motorImpulse=this.limitImpulse=0};
OIMO.RotationalConstraint.prototype={constructor:OIMO.RotationalConstraint,preSolve:function(a,c){this.ax=this.limitMotor.axis.x;this.ay=this.limitMotor.axis.y;this.az=this.limitMotor.axis.z;this.lowerLimit=this.limitMotor.lowerLimit;this.upperLimit=this.limitMotor.upperLimit;this.motorSpeed=this.limitMotor.motorSpeed;this.maxMotorForce=this.limitMotor.maxMotorForce;this.enableMotor=0<this.maxMotorForce;var b=this.i1.elements,d=this.i2.elements;this.i1e00=b[0];this.i1e01=b[1];this.i1e02=b[2];this.i1e10=
b[3];this.i1e11=b[4];this.i1e12=b[5];this.i1e20=b[6];this.i1e21=b[7];this.i1e22=b[8];this.i2e00=d[0];this.i2e01=d[1];this.i2e02=d[2];this.i2e10=d[3];this.i2e11=d[4];this.i2e12=d[5];this.i2e20=d[6];this.i2e21=d[7];this.i2e22=d[8];var b=this.limitMotor.frequency,d=0<b,e=this.limitMotor.angle;this.lowerLimit<=this.upperLimit?(this.lowerLimit==this.upperLimit?(0!=this.limitState&&(this.limitImpulse=this.limitState=0),this.limitVelocity=this.lowerLimit-e):e<this.lowerLimit?(-1!=this.limitState&&(this.limitState=
-1,this.limitImpulse=0),this.limitVelocity=this.lowerLimit-e):e>this.upperLimit?(1!=this.limitState&&(this.limitState=1,this.limitImpulse=0),this.limitVelocity=this.upperLimit-e):(this.limitState=2,this.limitVelocity=this.limitImpulse=0),d||(this.limitVelocity=0.02<this.limitVelocity?this.limitVelocity-0.02:-0.02>this.limitVelocity?this.limitVelocity+0.02:0)):(this.limitState=2,this.limitImpulse=0);this.maxMotorImpulse=this.enableMotor&&(0!=this.limitState||d)?this.maxMotorForce*a:this.motorImpulse=
0;this.a1x=this.ax*this.i1e00+this.ay*this.i1e01+this.az*this.i1e02;this.a1y=this.ax*this.i1e10+this.ay*this.i1e11+this.az*this.i1e12;this.a1z=this.ax*this.i1e20+this.ay*this.i1e21+this.az*this.i1e22;this.a2x=this.ax*this.i2e00+this.ay*this.i2e01+this.az*this.i2e02;this.a2y=this.ax*this.i2e10+this.ay*this.i2e11+this.az*this.i2e12;this.a2z=this.ax*this.i2e20+this.ay*this.i2e21+this.az*this.i2e22;this.motorDenom=this.ax*(this.a1x+this.a2x)+this.ay*(this.a1y+this.a2y)+this.az*(this.a1z+this.a2z);this.invMotorDenom=
1/this.motorDenom;d&&2!=this.limitState?(d=6.2831853*b,b=d*d*a,d=c/(b+2*this.limitMotor.dampingRatio*d),this.cfm=this.motorDenom*d,this.limitVelocity=this.limitVelocity*b*d):(this.cfm=0,this.limitVelocity=0.05*this.limitVelocity*c);this.invDenom=1/(this.motorDenom+this.cfm);this.limitImpulse*=0.95;this.motorImpulse*=0.95;b=this.limitImpulse+this.motorImpulse;this.a1.x+=b*this.a1x;this.a1.y+=b*this.a1y;this.a1.z+=b*this.a1z;this.a2.x-=b*this.a2x;this.a2.y-=b*this.a2y;this.a2.z-=b*this.a2z},solve:function(){var a=
this.ax*(this.a2.x-this.a1.x)+this.ay*(this.a2.y-this.a1.y)+this.az*(this.a2.z-this.a1.z),c;if(this.enableMotor){c=(a-this.motorSpeed)*this.invMotorDenom;var b=this.motorImpulse;this.motorImpulse+=c;this.motorImpulse>this.maxMotorImpulse?this.motorImpulse=this.maxMotorImpulse:this.motorImpulse<-this.maxMotorImpulse&&(this.motorImpulse=-this.maxMotorImpulse);c=this.motorImpulse-b;a-=c*this.motorDenom}else c=0;2!=this.limitState?(a=(a-this.limitVelocity-this.limitImpulse*this.cfm)*this.invDenom,b=this.limitImpulse,
this.limitImpulse+=a,0>this.limitImpulse*this.limitState&&(this.limitImpulse=0),a=this.limitImpulse-b):a=0;c=a+c;this.a1.x+=c*this.a1x;this.a1.y+=c*this.a1y;this.a1.z+=c*this.a1z;this.a2.x-=c*this.a2x;this.a2.y-=c*this.a2y;this.a2.z-=c*this.a2z}};OIMO.Translational3Constraint=function(a,c,b,d){this.limitVelocity1=this.upperLimit1=this.lowerLimit1=this.a2z3=this.a2y3=this.a2x3=this.a1z3=this.a1y3=this.a1x3=this.l2z3=this.l2y3=this.l2x3=this.l1z3=this.l1y3=this.l1x3=this.t2z3=this.t2y3=this.t2x3=this.t1z3=this.t1y3=this.t1x3=this.a2z2=this.a2y2=this.a2x2=this.a1z2=this.a1y2=this.a1x2=this.l2z2=this.l2y2=this.l2x2=this.l1z2=this.l1y2=this.l1x2=this.t2z2=this.t2y2=this.t2x2=this.t1z2=this.t1y2=this.t1x2=this.a2z1=this.a2y1=this.a2x1=this.a1z1=
this.a1y1=this.a1x1=this.l2z1=this.l2y1=this.l2x1=this.l1z1=this.l1y1=this.l1x1=this.t2z1=this.t2y1=this.t2x1=this.t1z1=this.t1y1=this.t1x1=this.r2z=this.r2y=this.r2x=this.r1z=this.r1y=this.r1x=this.az3=this.ay3=this.ax3=this.az2=this.ay2=this.ax2=this.az1=this.ay1=this.ax1=this.i2e22=this.i2e21=this.i2e20=this.i2e12=this.i2e11=this.i2e10=this.i2e02=this.i2e01=this.i2e00=this.i1e22=this.i1e21=this.i1e20=this.i1e12=this.i1e11=this.i1e10=this.i1e02=this.i1e01=this.i1e00=this.m2=this.m1=NaN;this.limitState1=
0;this.enableMotor1=!1;this.limitVelocity2=this.upperLimit2=this.lowerLimit2=this.maxMotorImpulse1=this.maxMotorForce1=this.motorSpeed1=NaN;this.limitState2=0;this.enableMotor2=!1;this.limitVelocity3=this.upperLimit3=this.lowerLimit3=this.maxMotorImpulse2=this.maxMotorForce2=this.motorSpeed2=NaN;this.limitState3=0;this.enableMotor3=!1;this.d22=this.d21=this.d20=this.d12=this.d11=this.d10=this.d02=this.d01=this.d00=this.dv22=this.dv11=this.dv00=this.kv22=this.kv11=this.kv00=this.k22=this.k21=this.k20=
this.k12=this.k11=this.k10=this.k02=this.k01=this.k00=this.maxMotorImpulse3=this.maxMotorForce3=this.motorSpeed3=NaN;this.limitMotor1=c;this.limitMotor2=b;this.limitMotor3=d;this.b1=a.body1;this.b2=a.body2;this.p1=a.anchorPoint1;this.p2=a.anchorPoint2;this.r1=a.relativeAnchorPoint1;this.r2=a.relativeAnchorPoint2;this.l1=this.b1.linearVelocity;this.l2=this.b2.linearVelocity;this.a1=this.b1.angularVelocity;this.a2=this.b2.angularVelocity;this.i1=this.b1.inverseInertia;this.i2=this.b2.inverseInertia;
this.cfm3=this.cfm2=this.cfm1=this.motorImpulse3=this.limitImpulse3=this.motorImpulse2=this.limitImpulse2=this.motorImpulse1=this.limitImpulse1=0;this.weight=-1};
OIMO.Translational3Constraint.prototype={constructor:OIMO.Translational3Constraint,preSolve:function(a,c){this.ax1=this.limitMotor1.axis.x;this.ay1=this.limitMotor1.axis.y;this.az1=this.limitMotor1.axis.z;this.ax2=this.limitMotor2.axis.x;this.ay2=this.limitMotor2.axis.y;this.az2=this.limitMotor2.axis.z;this.ax3=this.limitMotor3.axis.x;this.ay3=this.limitMotor3.axis.y;this.az3=this.limitMotor3.axis.z;this.lowerLimit1=this.limitMotor1.lowerLimit;this.upperLimit1=this.limitMotor1.upperLimit;this.motorSpeed1=
this.limitMotor1.motorSpeed;this.maxMotorForce1=this.limitMotor1.maxMotorForce;this.enableMotor1=0<this.maxMotorForce1;this.lowerLimit2=this.limitMotor2.lowerLimit;this.upperLimit2=this.limitMotor2.upperLimit;this.motorSpeed2=this.limitMotor2.motorSpeed;this.maxMotorForce2=this.limitMotor2.maxMotorForce;this.enableMotor2=0<this.maxMotorForce2;this.lowerLimit3=this.limitMotor3.lowerLimit;this.upperLimit3=this.limitMotor3.upperLimit;this.motorSpeed3=this.limitMotor3.motorSpeed;this.maxMotorForce3=this.limitMotor3.maxMotorForce;
this.enableMotor3=0<this.maxMotorForce3;this.m1=this.b1.inverseMass;this.m2=this.b2.inverseMass;var b=this.i1.elements,d=this.i2.elements;this.i1e00=b[0];this.i1e01=b[1];this.i1e02=b[2];this.i1e10=b[3];this.i1e11=b[4];this.i1e12=b[5];this.i1e20=b[6];this.i1e21=b[7];this.i1e22=b[8];this.i2e00=d[0];this.i2e01=d[1];this.i2e02=d[2];this.i2e10=d[3];this.i2e11=d[4];this.i2e12=d[5];this.i2e20=d[6];this.i2e21=d[7];this.i2e22=d[8];var b=this.p2.x-this.p1.x,d=this.p2.y-this.p1.y,e=this.p2.z-this.p1.z,f=b*this.ax1+
d*this.ay1+e*this.az1,g=b*this.ax2+d*this.ay2+e*this.az2,h=b*this.ax3+d*this.ay3+e*this.az3,k=this.limitMotor1.frequency,b=this.limitMotor2.frequency,d=this.limitMotor3.frequency,l=0<k,e=0<b,n=0<d,p=this.lowerLimit1<=this.upperLimit1,m=this.lowerLimit2<=this.upperLimit2,t=this.lowerLimit3<=this.upperLimit3;if(l&&20<f||-20>f)l=!1;if(e&&20<g||-20>g)e=!1;if(n&&20<h||-20>h)n=!1;p?(this.lowerLimit1==this.upperLimit1?(0!=this.limitState1&&(this.limitImpulse1=this.limitState1=0),this.limitVelocity1=this.lowerLimit1-
f,l||(f=this.lowerLimit1)):f<this.lowerLimit1?(-1!=this.limitState1&&(this.limitState1=-1,this.limitImpulse1=0),this.limitVelocity1=this.lowerLimit1-f,l||(f=this.lowerLimit1)):f>this.upperLimit1?(1!=this.limitState1&&(this.limitState1=1,this.limitImpulse1=0),this.limitVelocity1=this.upperLimit1-f,l||(f=this.upperLimit1)):(this.limitState1=2,this.limitVelocity1=this.limitImpulse1=0),l||(this.limitVelocity1=0.005<this.limitVelocity1?this.limitVelocity1-0.005:-0.005>this.limitVelocity1?this.limitVelocity1+
0.005:0)):(this.limitState1=2,this.limitImpulse1=0);m?(this.lowerLimit2==this.upperLimit2?(0!=this.limitState2&&(this.limitImpulse2=this.limitState2=0),this.limitVelocity2=this.lowerLimit2-g,e||(g=this.lowerLimit2)):g<this.lowerLimit2?(-1!=this.limitState2&&(this.limitState2=-1,this.limitImpulse2=0),this.limitVelocity2=this.lowerLimit2-g,e||(g=this.lowerLimit2)):g>this.upperLimit2?(1!=this.limitState2&&(this.limitState2=1,this.limitImpulse2=0),this.limitVelocity2=this.upperLimit2-g,e||(g=this.upperLimit2)):
(this.limitState2=2,this.limitVelocity2=this.limitImpulse2=0),e||(this.limitVelocity2=0.005<this.limitVelocity2?this.limitVelocity2-0.005:-0.005>this.limitVelocity2?this.limitVelocity2+0.005:0)):(this.limitState2=2,this.limitImpulse2=0);t?(this.lowerLimit3==this.upperLimit3?(0!=this.limitState3&&(this.limitImpulse3=this.limitState3=0),this.limitVelocity3=this.lowerLimit3-h,n||(h=this.lowerLimit3)):h<this.lowerLimit3?(-1!=this.limitState3&&(this.limitState3=-1,this.limitImpulse3=0),this.limitVelocity3=
this.lowerLimit3-h,n||(h=this.lowerLimit3)):h>this.upperLimit3?(1!=this.limitState3&&(this.limitState3=1,this.limitImpulse3=0),this.limitVelocity3=this.upperLimit3-h,n||(h=this.upperLimit3)):(this.limitState3=2,this.limitVelocity3=this.limitImpulse3=0),n||(this.limitVelocity3=0.005<this.limitVelocity3?this.limitVelocity3-0.005:-0.005>this.limitVelocity3?this.limitVelocity3+0.005:0)):(this.limitState3=2,this.limitImpulse3=0);this.maxMotorImpulse1=this.enableMotor1&&(0!=this.limitState1||l)?this.maxMotorForce1*
a:this.motorImpulse1=0;this.maxMotorImpulse2=this.enableMotor2&&(0!=this.limitState2||e)?this.maxMotorForce2*a:this.motorImpulse2=0;this.maxMotorImpulse3=this.enableMotor3&&(0!=this.limitState3||n)?this.maxMotorForce3*a:this.motorImpulse3=0;p=f*this.ax1+g*this.ax2+h*this.ax2;m=f*this.ay1+g*this.ay2+h*this.ay2;f=f*this.az1+g*this.az2+h*this.az2;g=this.m2/(this.m1+this.m2);0<=this.weight&&(g=this.weight);h=1-g;this.r1x=this.r1.x+p*g;this.r1y=this.r1.y+m*g;this.r1z=this.r1.z+f*g;this.r2x=this.r2.x-p*
h;this.r2y=this.r2.y-m*h;this.r2z=this.r2.z-f*h;this.t1x1=this.r1y*this.az1-this.r1z*this.ay1;this.t1y1=this.r1z*this.ax1-this.r1x*this.az1;this.t1z1=this.r1x*this.ay1-this.r1y*this.ax1;this.t2x1=this.r2y*this.az1-this.r2z*this.ay1;this.t2y1=this.r2z*this.ax1-this.r2x*this.az1;this.t2z1=this.r2x*this.ay1-this.r2y*this.ax1;this.l1x1=this.ax1*this.m1;this.l1y1=this.ay1*this.m1;this.l1z1=this.az1*this.m1;this.l2x1=this.ax1*this.m2;this.l2y1=this.ay1*this.m2;this.l2z1=this.az1*this.m2;this.a1x1=this.t1x1*
this.i1e00+this.t1y1*this.i1e01+this.t1z1*this.i1e02;this.a1y1=this.t1x1*this.i1e10+this.t1y1*this.i1e11+this.t1z1*this.i1e12;this.a1z1=this.t1x1*this.i1e20+this.t1y1*this.i1e21+this.t1z1*this.i1e22;this.a2x1=this.t2x1*this.i2e00+this.t2y1*this.i2e01+this.t2z1*this.i2e02;this.a2y1=this.t2x1*this.i2e10+this.t2y1*this.i2e11+this.t2z1*this.i2e12;this.a2z1=this.t2x1*this.i2e20+this.t2y1*this.i2e21+this.t2z1*this.i2e22;this.t1x2=this.r1y*this.az2-this.r1z*this.ay2;this.t1y2=this.r1z*this.ax2-this.r1x*
this.az2;this.t1z2=this.r1x*this.ay2-this.r1y*this.ax2;this.t2x2=this.r2y*this.az2-this.r2z*this.ay2;this.t2y2=this.r2z*this.ax2-this.r2x*this.az2;this.t2z2=this.r2x*this.ay2-this.r2y*this.ax2;this.l1x2=this.ax2*this.m1;this.l1y2=this.ay2*this.m1;this.l1z2=this.az2*this.m1;this.l2x2=this.ax2*this.m2;this.l2y2=this.ay2*this.m2;this.l2z2=this.az2*this.m2;this.a1x2=this.t1x2*this.i1e00+this.t1y2*this.i1e01+this.t1z2*this.i1e02;this.a1y2=this.t1x2*this.i1e10+this.t1y2*this.i1e11+this.t1z2*this.i1e12;
this.a1z2=this.t1x2*this.i1e20+this.t1y2*this.i1e21+this.t1z2*this.i1e22;this.a2x2=this.t2x2*this.i2e00+this.t2y2*this.i2e01+this.t2z2*this.i2e02;this.a2y2=this.t2x2*this.i2e10+this.t2y2*this.i2e11+this.t2z2*this.i2e12;this.a2z2=this.t2x2*this.i2e20+this.t2y2*this.i2e21+this.t2z2*this.i2e22;this.t1x3=this.r1y*this.az3-this.r1z*this.ay3;this.t1y3=this.r1z*this.ax3-this.r1x*this.az3;this.t1z3=this.r1x*this.ay3-this.r1y*this.ax3;this.t2x3=this.r2y*this.az3-this.r2z*this.ay3;this.t2y3=this.r2z*this.ax3-
this.r2x*this.az3;this.t2z3=this.r2x*this.ay3-this.r2y*this.ax3;this.l1x3=this.ax3*this.m1;this.l1y3=this.ay3*this.m1;this.l1z3=this.az3*this.m1;this.l2x3=this.ax3*this.m2;this.l2y3=this.ay3*this.m2;this.l2z3=this.az3*this.m2;this.a1x3=this.t1x3*this.i1e00+this.t1y3*this.i1e01+this.t1z3*this.i1e02;this.a1y3=this.t1x3*this.i1e10+this.t1y3*this.i1e11+this.t1z3*this.i1e12;this.a1z3=this.t1x3*this.i1e20+this.t1y3*this.i1e21+this.t1z3*this.i1e22;this.a2x3=this.t2x3*this.i2e00+this.t2y3*this.i2e01+this.t2z3*
this.i2e02;this.a2y3=this.t2x3*this.i2e10+this.t2y3*this.i2e11+this.t2z3*this.i2e12;this.a2z3=this.t2x3*this.i2e20+this.t2y3*this.i2e21+this.t2z3*this.i2e22;f=this.m1+this.m2;this.k00=(this.ax1*this.ax1+this.ay1*this.ay1+this.az1*this.az1)*f;this.k01=(this.ax1*this.ax2+this.ay1*this.ay2+this.az1*this.az2)*f;this.k02=(this.ax1*this.ax3+this.ay1*this.ay3+this.az1*this.az3)*f;this.k10=(this.ax2*this.ax1+this.ay2*this.ay1+this.az2*this.az1)*f;this.k11=(this.ax2*this.ax2+this.ay2*this.ay2+this.az2*this.az2)*
f;this.k12=(this.ax2*this.ax3+this.ay2*this.ay3+this.az2*this.az3)*f;this.k20=(this.ax3*this.ax1+this.ay3*this.ay1+this.az3*this.az1)*f;this.k21=(this.ax3*this.ax2+this.ay3*this.ay2+this.az3*this.az2)*f;this.k22=(this.ax3*this.ax3+this.ay3*this.ay3+this.az3*this.az3)*f;this.k00+=this.t1x1*this.a1x1+this.t1y1*this.a1y1+this.t1z1*this.a1z1;this.k01+=this.t1x1*this.a1x2+this.t1y1*this.a1y2+this.t1z1*this.a1z2;this.k02+=this.t1x1*this.a1x3+this.t1y1*this.a1y3+this.t1z1*this.a1z3;this.k10+=this.t1x2*this.a1x1+
this.t1y2*this.a1y1+this.t1z2*this.a1z1;this.k11+=this.t1x2*this.a1x2+this.t1y2*this.a1y2+this.t1z2*this.a1z2;this.k12+=this.t1x2*this.a1x3+this.t1y2*this.a1y3+this.t1z2*this.a1z3;this.k20+=this.t1x3*this.a1x1+this.t1y3*this.a1y1+this.t1z3*this.a1z1;this.k21+=this.t1x3*this.a1x2+this.t1y3*this.a1y2+this.t1z3*this.a1z2;this.k22+=this.t1x3*this.a1x3+this.t1y3*this.a1y3+this.t1z3*this.a1z3;this.k00+=this.t2x1*this.a2x1+this.t2y1*this.a2y1+this.t2z1*this.a2z1;this.k01+=this.t2x1*this.a2x2+this.t2y1*this.a2y2+
this.t2z1*this.a2z2;this.k02+=this.t2x1*this.a2x3+this.t2y1*this.a2y3+this.t2z1*this.a2z3;this.k10+=this.t2x2*this.a2x1+this.t2y2*this.a2y1+this.t2z2*this.a2z1;this.k11+=this.t2x2*this.a2x2+this.t2y2*this.a2y2+this.t2z2*this.a2z2;this.k12+=this.t2x2*this.a2x3+this.t2y2*this.a2y3+this.t2z2*this.a2z3;this.k20+=this.t2x3*this.a2x1+this.t2y3*this.a2y1+this.t2z3*this.a2z1;this.k21+=this.t2x3*this.a2x2+this.t2y3*this.a2y2+this.t2z3*this.a2z2;this.k22+=this.t2x3*this.a2x3+this.t2y3*this.a2y3+this.t2z3*this.a2z3;
this.kv00=this.k00;this.kv11=this.k11;this.kv22=this.k22;this.dv00=1/this.kv00;this.dv11=1/this.kv11;this.dv22=1/this.kv22;l&&2!=this.limitState1?(l=6.2831853*k,k=l*l*a,l=c/(k+2*this.limitMotor1.dampingRatio*l),this.cfm1=this.kv00*l,this.limitVelocity1=this.limitVelocity1*k*l):(this.cfm1=0,this.limitVelocity1=0.05*this.limitVelocity1*c);e&&2!=this.limitState2?(l=6.2831853*b,k=l*l*a,l=c/(k+2*this.limitMotor2.dampingRatio*l),this.cfm2=this.kv11*l,this.limitVelocity2=this.limitVelocity2*k*l):(this.cfm2=
0,this.limitVelocity2=0.05*this.limitVelocity2*c);n&&2!=this.limitState3?(l=6.2831853*d,k=l*l*a,l=c/(k+2*this.limitMotor3.dampingRatio*l),this.cfm3=this.kv22*l,this.limitVelocity3=this.limitVelocity3*k*l):(this.cfm3=0,this.limitVelocity3=0.05*this.limitVelocity3*c);this.k00+=this.cfm1;this.k11+=this.cfm2;this.k22+=this.cfm3;b=1/(this.k00*(this.k11*this.k22-this.k21*this.k12)+this.k10*(this.k21*this.k02-this.k01*this.k22)+this.k20*(this.k01*this.k12-this.k11*this.k02));this.d00=(this.k11*this.k22-
this.k12*this.k21)*b;this.d01=(this.k02*this.k21-this.k01*this.k22)*b;this.d02=(this.k01*this.k12-this.k02*this.k11)*b;this.d10=(this.k12*this.k20-this.k10*this.k22)*b;this.d11=(this.k00*this.k22-this.k02*this.k20)*b;this.d12=(this.k02*this.k10-this.k00*this.k12)*b;this.d20=(this.k10*this.k21-this.k11*this.k20)*b;this.d21=(this.k01*this.k20-this.k00*this.k21)*b;this.d22=(this.k00*this.k11-this.k01*this.k10)*b;b=this.limitImpulse1+this.motorImpulse1;d=this.limitImpulse2+this.motorImpulse2;e=this.limitImpulse3+
this.motorImpulse3;this.l1.x+=b*this.l1x1+d*this.l1x2+e*this.l1x3;this.l1.y+=b*this.l1y1+d*this.l1y2+e*this.l1y3;this.l1.z+=b*this.l1z1+d*this.l1z2+e*this.l1z3;this.a1.x+=b*this.a1x1+d*this.a1x2+e*this.a1x3;this.a1.y+=b*this.a1y1+d*this.a1y2+e*this.a1y3;this.a1.z+=b*this.a1z1+d*this.a1z2+e*this.a1z3;this.l2.x-=b*this.l2x1+d*this.l2x2+e*this.l2x3;this.l2.y-=b*this.l2y1+d*this.l2y2+e*this.l2y3;this.l2.z-=b*this.l2z1+d*this.l2z2+e*this.l2z3;this.a2.x-=b*this.a2x1+d*this.a2x2+e*this.a2x3;this.a2.y-=b*
this.a2y1+d*this.a2y2+e*this.a2y3;this.a2.z-=b*this.a2z1+d*this.a2z2+e*this.a2z3},solve:function(){var a=this.l2.x-this.l1.x+this.a2.y*this.r2z-this.a2.z*this.r2y-this.a1.y*this.r1z+this.a1.z*this.r1y,c=this.l2.y-this.l1.y+this.a2.z*this.r2x-this.a2.x*this.r2z-this.a1.z*this.r1x+this.a1.x*this.r1z,b=this.l2.z-this.l1.z+this.a2.x*this.r2y-this.a2.y*this.r2x-this.a1.x*this.r1y+this.a1.y*this.r1x,d=a*this.ax1+c*this.ay1+b*this.az1,e=a*this.ax2+c*this.ay2+b*this.az2,b=a*this.ax3+c*this.ay3+b*this.az3,
f=this.motorImpulse1,g=this.motorImpulse2,h=this.motorImpulse3,k=0,a=c=0;this.enableMotor1&&(k=(d-this.motorSpeed1)*this.dv00,this.motorImpulse1+=k,this.motorImpulse1>this.maxMotorImpulse1?this.motorImpulse1=this.maxMotorImpulse1:this.motorImpulse1<-this.maxMotorImpulse1&&(this.motorImpulse1=-this.maxMotorImpulse1),k=this.motorImpulse1-f);this.enableMotor2&&(c=(e-this.motorSpeed2)*this.dv11,this.motorImpulse2+=c,this.motorImpulse2>this.maxMotorImpulse2?this.motorImpulse2=this.maxMotorImpulse2:this.motorImpulse2<
-this.maxMotorImpulse2&&(this.motorImpulse2=-this.maxMotorImpulse2),c=this.motorImpulse2-g);this.enableMotor3&&(a=(b-this.motorSpeed3)*this.dv22,this.motorImpulse3+=a,this.motorImpulse3>this.maxMotorImpulse3?this.motorImpulse3=this.maxMotorImpulse3:this.motorImpulse3<-this.maxMotorImpulse3&&(this.motorImpulse3=-this.maxMotorImpulse3),a=this.motorImpulse3-h);var d=d+(k*this.kv00+c*this.k01+a*this.k02),e=e+(k*this.k10+c*this.kv11+a*this.k12),b=b+(k*this.k20+c*this.k21+a*this.kv22),d=d-(this.limitVelocity1+
this.limitImpulse1*this.cfm1),e=e-(this.limitVelocity2+this.limitImpulse2*this.cfm2),b=b-(this.limitVelocity3+this.limitImpulse3*this.cfm3),h=this.limitImpulse1,l=this.limitImpulse2,n=this.limitImpulse3,p=d*this.d00+e*this.d01+b*this.d02,g=d*this.d10+e*this.d11+b*this.d12,f=d*this.d20+e*this.d21+b*this.d22;this.limitImpulse1+=p;this.limitImpulse2+=g;this.limitImpulse3+=f;var m=0;if(2==this.limitState1||0>this.limitImpulse1*this.limitState1)p=-h,e+=p*this.k10,b+=p*this.k20,m|=1;if(2==this.limitState2||
0>this.limitImpulse2*this.limitState2)g=-l,d+=g*this.k01,b+=g*this.k21,m|=2;if(2==this.limitState3||0>this.limitImpulse3*this.limitState3)f=-n,d+=f*this.k02,e+=f*this.k12,m|=4;switch(m){case 1:m=1/(this.k11*this.k22-this.k12*this.k21);g=(this.k22*e+-this.k12*b)*m;f=(-this.k21*e+this.k11*b)*m;break;case 2:m=1/(this.k00*this.k22-this.k02*this.k20);p=(this.k22*d+-this.k02*b)*m;f=(-this.k20*d+this.k00*b)*m;break;case 3:f=b/this.k22;break;case 4:m=1/(this.k00*this.k11-this.k01*this.k10);p=(this.k11*d+
-this.k01*e)*m;g=(-this.k10*d+this.k00*e)*m;break;case 5:g=e/this.k11;break;case 6:p=d/this.k00}this.limitImpulse1=h+p;this.limitImpulse2=l+g;this.limitImpulse3=n+f;d=k+p;e=c+g;a+=f;this.l1.x+=d*this.l1x1+e*this.l1x2+a*this.l1x3;this.l1.y+=d*this.l1y1+e*this.l1y2+a*this.l1y3;this.l1.z+=d*this.l1z1+e*this.l1z2+a*this.l1z3;this.a1.x+=d*this.a1x1+e*this.a1x2+a*this.a1x3;this.a1.y+=d*this.a1y1+e*this.a1y2+a*this.a1y3;this.a1.z+=d*this.a1z1+e*this.a1z2+a*this.a1z3;this.l2.x-=d*this.l2x1+e*this.l2x2+a*
this.l2x3;this.l2.y-=d*this.l2y1+e*this.l2y2+a*this.l2y3;this.l2.z-=d*this.l2z1+e*this.l2z2+a*this.l2z3;this.a2.x-=d*this.a2x1+e*this.a2x2+a*this.a2x3;this.a2.y-=d*this.a2y1+e*this.a2y2+a*this.a2y3;this.a2.z-=d*this.a2z1+e*this.a2z2+a*this.a2z3}};OIMO.TranslationalConstraint=function(a,c){this.limitVelocity=this.upperLimit=this.lowerLimit=this.a2z=this.a2y=this.a2x=this.a1z=this.a1y=this.a1x=this.l2z=this.l2y=this.l2x=this.l1z=this.l1y=this.l1x=this.t2z=this.t2y=this.t2x=this.t1z=this.t1y=this.t1x=this.r2z=this.r2y=this.r2x=this.r1z=this.r1y=this.r1x=this.az=this.ay=this.ax=this.invDenom=this.invMotorDenom=this.motorDenom=this.i2e22=this.i2e21=this.i2e20=this.i2e12=this.i2e11=this.i2e10=this.i2e02=this.i2e01=this.i2e00=this.i1e22=this.i1e21=
this.i1e20=this.i1e12=this.i1e11=this.i1e10=this.i1e02=this.i1e01=this.i1e00=this.m2=this.m1=this.cfm=NaN;this.limitState=0;this.enableMotor=!1;this.maxMotorImpulse=this.maxMotorForce=this.motorSpeed=NaN;this.limitMotor=c;this.b1=a.body1;this.b2=a.body2;this.p1=a.anchorPoint1;this.p2=a.anchorPoint2;this.r1=a.relativeAnchorPoint1;this.r2=a.relativeAnchorPoint2;this.l1=this.b1.linearVelocity;this.l2=this.b2.linearVelocity;this.a1=this.b1.angularVelocity;this.a2=this.b2.angularVelocity;this.i1=this.b1.inverseInertia;
this.i2=this.b2.inverseInertia;this.motorImpulse=this.limitImpulse=0};
OIMO.TranslationalConstraint.prototype={constructor:OIMO.TranslationalConstraint,preSolve:function(a,c){this.ax=this.limitMotor.axis.x;this.ay=this.limitMotor.axis.y;this.az=this.limitMotor.axis.z;this.lowerLimit=this.limitMotor.lowerLimit;this.upperLimit=this.limitMotor.upperLimit;this.motorSpeed=this.limitMotor.motorSpeed;this.maxMotorForce=this.limitMotor.maxMotorForce;this.enableMotor=0<this.maxMotorForce;this.m1=this.b1.inverseMass;this.m2=this.b2.inverseMass;var b=this.i1.elements,d=this.i2.elements;
this.i1e00=b[0];this.i1e01=b[1];this.i1e02=b[2];this.i1e10=b[3];this.i1e11=b[4];this.i1e12=b[5];this.i1e20=b[6];this.i1e21=b[7];this.i1e22=b[8];this.i2e00=d[0];this.i2e01=d[1];this.i2e02=d[2];this.i2e10=d[3];this.i2e11=d[4];this.i2e12=d[5];this.i2e20=d[6];this.i2e21=d[7];this.i2e22=d[8];var e=(this.p2.x-this.p1.x)*this.ax+(this.p2.y-this.p1.y)*this.ay+(this.p2.z-this.p1.z)*this.az,b=this.limitMotor.frequency,d=0<b,f=this.lowerLimit<=this.upperLimit;if(d&&20<e||-20>e)d=!1;f?(this.lowerLimit==this.upperLimit?
(0!=this.limitState&&(this.limitImpulse=this.limitState=0),this.limitVelocity=this.lowerLimit-e,d||(e=this.lowerLimit)):e<this.lowerLimit?(-1!=this.limitState&&(this.limitState=-1,this.limitImpulse=0),this.limitVelocity=this.lowerLimit-e,d||(e=this.lowerLimit)):e>this.upperLimit?(1!=this.limitState&&(this.limitState=1,this.limitImpulse=0),this.limitVelocity=this.upperLimit-e,d||(e=this.upperLimit)):(this.limitState=2,this.limitVelocity=this.limitImpulse=0),d||(this.limitVelocity=0.005<this.limitVelocity?
this.limitVelocity-0.005:-0.005>this.limitVelocity?this.limitVelocity+0.005:0)):(this.limitState=2,this.limitImpulse=0);this.maxMotorImpulse=this.enableMotor&&(0!=this.limitState||d)?this.maxMotorForce*a:this.motorImpulse=0;var f=e*this.ax,g=e*this.ay,e=e*this.az,h=this.m1/(this.m1+this.m2),k=1-h;this.r1x=this.r1.x+f*h;this.r1y=this.r1.y+g*h;this.r1z=this.r1.z+e*h;this.r2x=this.r2.x-f*k;this.r2y=this.r2.y-g*k;this.r2z=this.r2.z-e*k;this.t1x=this.r1y*this.az-this.r1z*this.ay;this.t1y=this.r1z*this.ax-
this.r1x*this.az;this.t1z=this.r1x*this.ay-this.r1y*this.ax;this.t2x=this.r2y*this.az-this.r2z*this.ay;this.t2y=this.r2z*this.ax-this.r2x*this.az;this.t2z=this.r2x*this.ay-this.r2y*this.ax;this.l1x=this.ax*this.m1;this.l1y=this.ay*this.m1;this.l1z=this.az*this.m1;this.l2x=this.ax*this.m2;this.l2y=this.ay*this.m2;this.l2z=this.az*this.m2;this.a1x=this.t1x*this.i1e00+this.t1y*this.i1e01+this.t1z*this.i1e02;this.a1y=this.t1x*this.i1e10+this.t1y*this.i1e11+this.t1z*this.i1e12;this.a1z=this.t1x*this.i1e20+
this.t1y*this.i1e21+this.t1z*this.i1e22;this.a2x=this.t2x*this.i2e00+this.t2y*this.i2e01+this.t2z*this.i2e02;this.a2y=this.t2x*this.i2e10+this.t2y*this.i2e11+this.t2z*this.i2e12;this.a2z=this.t2x*this.i2e20+this.t2y*this.i2e21+this.t2z*this.i2e22;this.motorDenom=this.m1+this.m2+this.ax*(this.a1y*this.r1z-this.a1z*this.r1y+this.a2y*this.r2z-this.a2z*this.r2y)+this.ay*(this.a1z*this.r1x-this.a1x*this.r1z+this.a2z*this.r2x-this.a2x*this.r2z)+this.az*(this.a1x*this.r1y-this.a1y*this.r1x+this.a2x*this.r2y-
this.a2y*this.r2x);this.invMotorDenom=1/this.motorDenom;d&&2!=this.limitState?(d=6.2831853*b,b=d*d*a,d=c/(b+2*this.limitMotor.dampingRatio*d),this.cfm=this.motorDenom*d,this.limitVelocity=this.limitVelocity*b*d):(this.cfm=0,this.limitVelocity=0.05*this.limitVelocity*c);this.invDenom=1/(this.motorDenom+this.cfm);b=this.limitImpulse+this.motorImpulse;this.l1.x+=b*this.l1x;this.l1.y+=b*this.l1y;this.l1.z+=b*this.l1z;this.a1.x+=b*this.a1x;this.a1.y+=b*this.a1y;this.a1.z+=b*this.a1z;this.l2.x-=b*this.l2x;
this.l2.y-=b*this.l2y;this.l2.z-=b*this.l2z;this.a2.x-=b*this.a2x;this.a2.y-=b*this.a2y;this.a2.z-=b*this.a2z},solve:function(){var a=this.ax*(this.l2.x-this.l1.x)+this.ay*(this.l2.y-this.l1.y)+this.az*(this.l2.z-this.l1.z)+this.t2x*this.a2.x-this.t1x*this.a1.x+this.t2y*this.a2.y-this.t1y*this.a1.y+this.t2z*this.a2.z-this.t1z*this.a1.z,c;if(this.enableMotor){c=(a-this.motorSpeed)*this.invMotorDenom;var b=this.motorImpulse;this.motorImpulse+=c;this.motorImpulse>this.maxMotorImpulse?this.motorImpulse=
this.maxMotorImpulse:this.motorImpulse<-this.maxMotorImpulse&&(this.motorImpulse=-this.maxMotorImpulse);c=this.motorImpulse-b;a-=c*this.motorDenom}else c=0;2!=this.limitState?(a=(a-this.limitVelocity-this.limitImpulse*this.cfm)*this.invDenom,b=this.limitImpulse,this.limitImpulse+=a,0>this.limitImpulse*this.limitState&&(this.limitImpulse=0),a=this.limitImpulse-b):a=0;c=a+c;this.l1.x+=c*this.l1x;this.l1.y+=c*this.l1y;this.l1.z+=c*this.l1z;this.a1.x+=c*this.a1x;this.a1.y+=c*this.a1y;this.a1.z+=c*this.a1z;
this.l2.x-=c*this.l2x;this.l2.y-=c*this.l2y;this.l2.z-=c*this.l2z;this.a2.x-=c*this.a2x;this.a2.y-=c*this.a2y;this.a2.z-=c*this.a2z}};OIMO.Contact=function(){this.next=this.prev=this.body2=this.body1=this.shape2=this.shape1=null;this.sleeping=this.persisting=!1;this.constraint=this.detector=null;this.touching=!1;this.b1Link=new OIMO.ContactLink(this);this.b2Link=new OIMO.ContactLink(this);this.s1Link=new OIMO.ContactLink(this);this.s2Link=new OIMO.ContactLink(this);this.manifold=new OIMO.ContactManifold;this.buffer=[];this.buffer.length=4;this.buffer[0]=new OIMO.ImpulseDataBuffer;this.buffer[1]=new OIMO.ImpulseDataBuffer;this.buffer[2]=
new OIMO.ImpulseDataBuffer;this.buffer[3]=new OIMO.ImpulseDataBuffer;this.points=this.manifold.points;this.constraint=new OIMO.ContactConstraint(this.manifold)};
OIMO.Contact.prototype={constructor:OIMO.Contact,mixRestitution:function(a,c){return Math.sqrt(a*c)},mixFriction:function(a,c){return Math.sqrt(a*c)},updateManifold:function(){this.constraint.restitution=this.mixRestitution(this.shape1.restitution,this.shape2.restitution);this.constraint.friction=this.mixFriction(this.shape1.friction,this.shape2.friction);for(var a=this.manifold.numPoints,c=0;c<a;c++){var b=this.buffer[c],d=this.points[c];b.lp1X=d.localPoint1.x;b.lp1Y=d.localPoint1.y;b.lp1Z=d.localPoint1.z;
b.lp2X=d.localPoint2.x;b.lp2Y=d.localPoint2.y;b.lp2Z=d.localPoint2.z;b.impulse=d.normalImpulse}this.manifold.numPoints=0;this.detector.detectCollision(this.shape1,this.shape2,this.manifold);var e=this.manifold.numPoints;if(0==e)this.touching=!1;else for(this.touching=!0,c=0;c<e;c++){for(var d=this.points[c],f=d.localPoint1.x,g=d.localPoint1.y,h=d.localPoint1.z,k=d.localPoint2.x,l=d.localPoint2.y,n=d.localPoint2.z,p=-1,m=4E-4,t=0;t<a;t++){var b=this.buffer[t],r=b.lp1X-f,w=b.lp1Y-g,u=b.lp1Z-h,y=r*r+
w*w+u*u,r=b.lp2X-k,w=b.lp2Y-l,u=b.lp2Z-n,b=r*r+w*w+u*u;y<b?y<m&&(m=y,p=t):b<m&&(m=b,p=t)}-1!=p?(f=this.buffer[p],this.buffer[p]=this.buffer[--a],this.buffer[a]=f,d.normalImpulse=f.impulse,d.warmStarted=!0):(d.normalImpulse=0,d.warmStarted=!1)}},attach:function(a,c){this.shape1=a;this.shape2=c;this.body1=a.parent;this.body2=c.parent;this.manifold.body1=this.body1;this.manifold.body2=this.body2;this.constraint.body1=this.body1;this.constraint.body2=this.body2;this.constraint.attach();this.s1Link.shape=
c;this.s1Link.body=this.body2;this.s2Link.shape=a;this.s2Link.body=this.body1;null!=a.contactLink?(this.s1Link.next=a.contactLink).prev=this.s1Link:this.s1Link.next=null;a.contactLink=this.s1Link;a.numContacts++;null!=c.contactLink?(this.s2Link.next=c.contactLink).prev=this.s2Link:this.s2Link.next=null;c.contactLink=this.s2Link;c.numContacts++;this.b1Link.shape=c;this.b1Link.body=this.body2;this.b2Link.shape=a;this.b2Link.body=this.body1;null!=this.body1.contactLink?(this.b1Link.next=this.body1.contactLink).prev=
this.b1Link:this.b1Link.next=null;this.body1.contactLink=this.b1Link;this.body1.numContacts++;null!=this.body2.contactLink?(this.b2Link.next=this.body2.contactLink).prev=this.b2Link:this.b2Link.next=null;this.body2.contactLink=this.b2Link;this.body2.numContacts++;this.next=this.prev=null;this.persisting=!0;this.sleeping=this.body1.sleeping&&this.body2.sleeping;this.manifold.numPoints=0},detach:function(){var a=this.s1Link.prev,c=this.s1Link.next;null!=a&&(a.next=c);null!=c&&(c.prev=a);this.shape1.contactLink==
this.s1Link&&(this.shape1.contactLink=c);this.s1Link.prev=null;this.s1Link.next=null;this.s1Link.shape=null;this.s1Link.body=null;this.shape1.numContacts--;a=this.s2Link.prev;c=this.s2Link.next;null!=a&&(a.next=c);null!=c&&(c.prev=a);this.shape2.contactLink==this.s2Link&&(this.shape2.contactLink=c);this.s2Link.prev=null;this.s2Link.next=null;this.s2Link.shape=null;this.s2Link.body=null;this.shape2.numContacts--;a=this.b1Link.prev;c=this.b1Link.next;null!=a&&(a.next=c);null!=c&&(c.prev=a);this.body1.contactLink==
this.b1Link&&(this.body1.contactLink=c);this.b1Link.prev=null;this.b1Link.next=null;this.b1Link.shape=null;this.b1Link.body=null;this.body1.numContacts--;a=this.b2Link.prev;c=this.b2Link.next;null!=a&&(a.next=c);null!=c&&(c.prev=a);this.body2.contactLink==this.b2Link&&(this.body2.contactLink=c);this.b2Link.prev=null;this.b2Link.next=null;this.b2Link.shape=null;this.b2Link.body=null;this.body2.numContacts--;this.manifold.body1=null;this.manifold.body2=null;this.constraint.body1=null;this.constraint.body2=
null;this.constraint.detach();this.body2=this.body1=this.shape2=this.shape1=null}};OIMO.ContactConstraint=function(a){OIMO.Constraint.call(this);this.friction=this.restitution=NaN;this.i2=this.i1=this.av2=this.av1=this.lv2=this.lv1=this.p2=this.p1=null;this.m2=this.m1=this.i2e22=this.i2e21=this.i2e20=this.i2e12=this.i2e11=this.i2e10=this.i2e02=this.i2e01=this.i2e00=this.i1e22=this.i1e21=this.i1e20=this.i1e12=this.i1e11=this.i1e10=this.i1e02=this.i1e01=this.i1e00=NaN;this.num=0;this.manifold=a;this.ps=a.points;this.cs=new OIMO.ContactPointDataBuffer;this.cs.next=new OIMO.ContactPointDataBuffer;
this.cs.next.next=new OIMO.ContactPointDataBuffer;this.cs.next.next.next=new OIMO.ContactPointDataBuffer};OIMO.ContactConstraint.prototype=Object.create(OIMO.Constraint.prototype);OIMO.ContactConstraint.prototype.attach=function(){this.p1=this.body1.position;this.p2=this.body2.position;this.lv1=this.body1.linearVelocity;this.av1=this.body1.angularVelocity;this.lv2=this.body2.linearVelocity;this.av2=this.body2.angularVelocity;this.i1=this.body1.inverseInertia;this.i2=this.body2.inverseInertia};
OIMO.ContactConstraint.prototype.detach=function(){this.i2=this.i1=this.av2=this.av1=this.lv2=this.lv1=this.p2=this.p1=null};
OIMO.ContactConstraint.prototype.preSolve=function(a,c){this.m1=this.body1.inverseMass;this.m2=this.body2.inverseMass;var b=this.i1.elements,d=this.i2.elements;this.i1e00=b[0];this.i1e01=b[1];this.i1e02=b[2];this.i1e10=b[3];this.i1e11=b[4];this.i1e12=b[5];this.i1e20=b[6];this.i1e21=b[7];this.i1e22=b[8];this.i2e00=d[0];this.i2e01=d[1];this.i2e02=d[2];this.i2e10=d[3];this.i2e11=d[4];this.i2e12=d[5];this.i2e20=d[6];this.i2e21=d[7];this.i2e22=d[8];var b=this.p1.x,d=this.p1.y,e=this.p1.z,f=this.p2.x,g=
this.p2.y,h=this.p2.z,k=this.m1+this.m2;this.num=this.manifold.numPoints;for(var l=this.cs,n=0;n<this.num;n++){var p=this.ps[n],m,t,r,w,u,y;m=p.position.x;t=p.position.y;r=p.position.z;var z=m-b,A=t-d,E=r-e,U=m-f,V=t-g,W=r-h;l.rp1X=z;l.rp1Y=A;l.rp1Z=E;l.rp2X=U;l.rp2Y=V;l.rp2Z=W;l.norImp=p.normalImpulse;l.tanImp=p.tangentImpulse;l.binImp=p.binormalImpulse;var ga=p.normal.x,qa=p.normal.y,N=p.normal.z,K=this.lv2.x+this.av2.y*W-this.av2.z*V-(this.lv1.x+this.av1.y*E-this.av1.z*A),ha=this.lv2.y+this.av2.z*
U-this.av2.x*W-(this.lv1.y+this.av1.z*z-this.av1.x*E),S=this.lv2.z+this.av2.x*V-this.av2.y*U-(this.lv1.z+this.av1.x*A-this.av1.y*z),G=ga*K+qa*ha+N*S,K=K-G*ga,L=ha-G*qa,M=S-G*N,S=K*K+L*L+M*M;0.04<S?S=1/Math.sqrt(S):(K=qa*ga-N*N,L=-N*qa-ga*ga,M=ga*N+qa*qa,S=1/Math.sqrt(K*K+L*L+M*M));var K=K*S,L=L*S,M=M*S,X=qa*M-N*L,Y=N*K-ga*M,Va=ga*L-qa*K;l.norX=ga;l.norY=qa;l.norZ=N;l.tanX=K;l.tanY=L;l.tanZ=M;l.binX=X;l.binY=Y;l.binZ=Va;l.norU1X=ga*this.m1;l.norU1Y=qa*this.m1;l.norU1Z=N*this.m1;l.norU2X=ga*this.m2;
l.norU2Y=qa*this.m2;l.norU2Z=N*this.m2;l.tanU1X=K*this.m1;l.tanU1Y=L*this.m1;l.tanU1Z=M*this.m1;l.tanU2X=K*this.m2;l.tanU2Y=L*this.m2;l.tanU2Z=M*this.m2;l.binU1X=X*this.m1;l.binU1Y=Y*this.m1;l.binU1Z=Va*this.m1;l.binU2X=X*this.m2;l.binU2Y=Y*this.m2;l.binU2Z=Va*this.m2;r=A*N-E*qa;w=E*ga-z*N;u=z*qa-A*ga;var Wa=V*N-W*qa,Xa=W*ga-U*N,Ya=U*qa-V*ga,Za=A*M-E*L,$a=E*K-z*M,ab=z*L-A*K,bb=V*M-W*L,cb=W*K-U*M,Z=U*L-V*K,$=A*Va-E*Y,aa=E*X-z*Va,ba=z*Y-A*X,ca=V*Va-W*Y,da=W*X-U*Va,ea=U*Y-V*X,S=r*this.i1e00+w*this.i1e01+
u*this.i1e02,ha=r*this.i1e10+w*this.i1e11+u*this.i1e12,ja=r*this.i1e20+w*this.i1e21+u*this.i1e22,ka=Wa*this.i2e00+Xa*this.i2e01+Ya*this.i2e02,Qb=Wa*this.i2e10+Xa*this.i2e11+Ya*this.i2e12,Rb=Wa*this.i2e20+Xa*this.i2e21+Ya*this.i2e22;m=Za*this.i1e00+$a*this.i1e01+ab*this.i1e02;t=Za*this.i1e10+$a*this.i1e11+ab*this.i1e12;y=Za*this.i1e20+$a*this.i1e21+ab*this.i1e22;var Sb=bb*this.i2e00+cb*this.i2e01+Z*this.i2e02,Tb=bb*this.i2e10+cb*this.i2e11+Z*this.i2e12,Ub=bb*this.i2e20+cb*this.i2e21+Z*this.i2e22,Vb=
$*this.i1e00+aa*this.i1e01+ba*this.i1e02,Wb=$*this.i1e10+aa*this.i1e11+ba*this.i1e12,Xb=$*this.i1e20+aa*this.i1e21+ba*this.i1e22,Yb=ca*this.i2e00+da*this.i2e01+ea*this.i2e02,db=ca*this.i2e10+da*this.i2e11+ea*this.i2e12,eb=ca*this.i2e20+da*this.i2e21+ea*this.i2e22;l.norT1X=r;l.norT1Y=w;l.norT1Z=u;l.tanT1X=Za;l.tanT1Y=$a;l.tanT1Z=ab;l.binT1X=$;l.binT1Y=aa;l.binT1Z=ba;l.norT2X=Wa;l.norT2Y=Xa;l.norT2Z=Ya;l.tanT2X=bb;l.tanT2Y=cb;l.tanT2Z=Z;l.binT2X=ca;l.binT2Y=da;l.binT2Z=ea;l.norTU1X=S;l.norTU1Y=ha;l.norTU1Z=
ja;l.tanTU1X=m;l.tanTU1Y=t;l.tanTU1Z=y;l.binTU1X=Vb;l.binTU1Y=Wb;l.binTU1Z=Xb;l.norTU2X=ka;l.norTU2Y=Qb;l.norTU2Z=Rb;l.tanTU2X=Sb;l.tanTU2Y=Tb;l.tanTU2Z=Ub;l.binTU2X=Yb;l.binTU2Y=db;l.binTU2Z=eb;m=r*this.i1e00+w*this.i1e01+u*this.i1e02;t=r*this.i1e10+w*this.i1e11+u*this.i1e12;r=r*this.i1e20+w*this.i1e21+u*this.i1e22;w=t*E-r*A;u=r*z-m*E;y=m*A-t*z;m=Wa*this.i2e00+Xa*this.i2e01+Ya*this.i2e02;t=Wa*this.i2e10+Xa*this.i2e11+Ya*this.i2e12;r=Wa*this.i2e20+Xa*this.i2e21+Ya*this.i2e22;w+=t*W-r*V;u+=r*U-m*W;
y+=m*V-t*U;ga=1/(k+ga*w+qa*u+N*y);m=Za*this.i1e00+$a*this.i1e01+ab*this.i1e02;t=Za*this.i1e10+$a*this.i1e11+ab*this.i1e12;r=Za*this.i1e20+$a*this.i1e21+ab*this.i1e22;w=t*E-r*A;u=r*z-m*E;y=m*A-t*z;m=bb*this.i2e00+cb*this.i2e01+Z*this.i2e02;t=bb*this.i2e10+cb*this.i2e11+Z*this.i2e12;r=bb*this.i2e20+cb*this.i2e21+Z*this.i2e22;w+=t*W-r*V;u+=r*U-m*W;y+=m*V-t*U;qa=1/(k+K*w+L*u+M*y);m=$*this.i1e00+aa*this.i1e01+ba*this.i1e02;t=$*this.i1e10+aa*this.i1e11+ba*this.i1e12;r=$*this.i1e20+aa*this.i1e21+ba*this.i1e22;
w=t*E-r*A;u=r*z-m*E;y=m*A-t*z;m=ca*this.i2e00+da*this.i2e01+ea*this.i2e02;t=ca*this.i2e10+da*this.i2e11+ea*this.i2e12;r=ca*this.i2e20+da*this.i2e21+ea*this.i2e22;w+=t*W-r*V;u+=r*U-m*W;y+=m*V-t*U;z=1/(k+X*w+Y*u+Va*y);l.norDen=ga;l.tanDen=qa;l.binDen=z;p.warmStarted?(G=p.normalImpulse,this.lv1.x+=l.norU1X*G,this.lv1.y+=l.norU1Y*G,this.lv1.z+=l.norU1Z*G,this.av1.x+=S*G,this.av1.y+=ha*G,this.av1.z+=ja*G,this.lv2.x-=l.norU2X*G,this.lv2.y-=l.norU2Y*G,this.lv2.z-=l.norU2Z*G,this.av2.x-=ka*G,this.av2.y-=
Qb*G,this.av2.z-=Rb*G,l.norImp=G,l.tanImp=0,G=l.binImp=0):(l.norImp=0,l.tanImp=0,l.binImp=0);-1<G&&(G=0);G=this.restitution*-G;p=-(p.penetration+0.005)*c*0.05;G<p&&(G=p);l.norTar=G;l.last=n==this.num-1;l=l.next}};
OIMO.ContactConstraint.prototype.solve=function(){for(var a=this.lv1.x,c=this.lv1.y,b=this.lv1.z,d=this.lv2.x,e=this.lv2.y,f=this.lv2.z,g=this.av1.x,h=this.av1.y,k=this.av1.z,l=this.av2.x,n=this.av2.y,p=this.av2.z,m=this.cs;;){var t,r,w,u,y=m.norImp,z=m.tanImp,A=m.binImp,E=-y*this.friction;w=d-a;u=e-c;var U=f-b;r=w*m.tanX+u*m.tanY+U*m.tanZ+l*m.tanT2X+n*m.tanT2Y+p*m.tanT2Z-g*m.tanT1X-h*m.tanT1Y-k*m.tanT1Z;t=z;r*=m.tanDen;z+=r;r=w*m.binX+u*m.binY+U*m.binZ+l*m.binT2X+n*m.binT2Y+p*m.binT2Z-g*m.binT1X-
h*m.binT1Y-k*m.binT1Z;w=A;u=r*m.binDen;A+=u;r=z*z+A*A;r>E*E&&(r=E/Math.sqrt(r),z*=r,A*=r);r=z-t;u=A-w;a+=m.tanU1X*r+m.binU1X*u;c+=m.tanU1Y*r+m.binU1Y*u;b+=m.tanU1Z*r+m.binU1Z*u;g+=m.tanTU1X*r+m.binTU1X*u;h+=m.tanTU1Y*r+m.binTU1Y*u;k+=m.tanTU1Z*r+m.binTU1Z*u;d-=m.tanU2X*r+m.binU2X*u;e-=m.tanU2Y*r+m.binU2Y*u;f-=m.tanU2Z*r+m.binU2Z*u;l-=m.tanTU2X*r+m.binTU2X*u;n-=m.tanTU2Y*r+m.binTU2Y*u;p-=m.tanTU2Z*r+m.binTU2Z*u;r=(d-a)*m.norX+(e-c)*m.norY+(f-b)*m.norZ+l*m.norT2X+n*m.norT2Y+p*m.norT2Z-g*m.norT1X-h*
m.norT1Y-k*m.norT1Z;t=y;r=(r-m.norTar)*m.norDen;y+=r;0<y&&(y=0);r=y-t;a+=m.norU1X*r;c+=m.norU1Y*r;b+=m.norU1Z*r;g+=m.norTU1X*r;h+=m.norTU1Y*r;k+=m.norTU1Z*r;d-=m.norU2X*r;e-=m.norU2Y*r;f-=m.norU2Z*r;l-=m.norTU2X*r;n-=m.norTU2Y*r;p-=m.norTU2Z*r;m.norImp=y;m.tanImp=z;m.binImp=A;if(m.last)break;m=m.next}this.lv1.x=a;this.lv1.y=c;this.lv1.z=b;this.lv2.x=d;this.lv2.y=e;this.lv2.z=f;this.av1.x=g;this.av1.y=h;this.av1.z=k;this.av2.x=l;this.av2.y=n;this.av2.z=p};
OIMO.ContactConstraint.prototype.postSolve=function(){for(var a=this.cs,c=0;c<this.num;c++){var b=this.ps[c];b.normal.x=a.norX;b.normal.y=a.norY;b.normal.z=a.norZ;b.tangent.x=a.tanX;b.tangent.y=a.tanY;b.tangent.z=a.tanZ;b.binormal.x=a.binX;b.binormal.y=a.binY;b.binormal.z=a.binZ;b.normalImpulse=a.norImp;b.tangentImpulse=a.tanImp;b.binormalImpulse=a.binImp;b.normalDenominator=a.norDen;b.tangentDenominator=a.tanDen;b.binormalDenominator=a.binDen;a=a.next}};OIMO.ContactLink=function(a){this.body=this.shape=this.next=this.prev=null;this.contact=a};OIMO.ContactManifold=function(){this.body2=this.body1=null;this.numPoints=0;this.points=[];this.points.length=4;this.points[0]=new OIMO.ManifoldPoint;this.points[1]=new OIMO.ManifoldPoint;this.points[2]=new OIMO.ManifoldPoint;this.points[3]=new OIMO.ManifoldPoint};
OIMO.ContactManifold.prototype={constructor:OIMO.ContactManifold,reset:function(a,c){this.body1=a.parent;this.body2=c.parent;this.numPoints=0},addPoint:function(a,c,b,d,e,f,g,h){var k=this.points[this.numPoints++];k.position.x=a;k.position.y=c;k.position.z=b;var l=a-this.body1.position.x,n=c-this.body1.position.y,p=b-this.body1.position.z,m=this.body1.rotation.elements;k.localPoint1.x=l*m[0]+n*m[3]+p*m[6];k.localPoint1.y=l*m[1]+n*m[4]+p*m[7];k.localPoint1.z=l*m[2]+n*m[5]+p*m[8];l=a-this.body2.position.x;
n=c-this.body2.position.y;p=b-this.body2.position.z;k.localPoint2.x=l*m[0]+n*m[3]+p*m[6];k.localPoint2.y=l*m[1]+n*m[4]+p*m[7];k.localPoint2.z=l*m[2]+n*m[5]+p*m[8];k.normalImpulse=0;h?(k.normal.x=-d,k.normal.y=-e,k.normal.z=-f):(k.normal.x=d,k.normal.y=e,k.normal.z=f);k.penetration=g;k.warmStarted=!1}};OIMO.ContactPointDataBuffer=function(){this.norTar=this.binDen=this.tanDen=this.norDen=this.binImp=this.tanImp=this.norImp=this.binTU2Z=this.binTU2Y=this.binTU2X=this.binTU1Z=this.binTU1Y=this.binTU1X=this.tanTU2Z=this.tanTU2Y=this.tanTU2X=this.tanTU1Z=this.tanTU1Y=this.tanTU1X=this.norTU2Z=this.norTU2Y=this.norTU2X=this.norTU1Z=this.norTU1Y=this.norTU1X=this.binT2Z=this.binT2Y=this.binT2X=this.binT1Z=this.binT1Y=this.binT1X=this.tanT2Z=this.tanT2Y=this.tanT2X=this.tanT1Z=this.tanT1Y=this.tanT1X=
this.norT2Z=this.norT2Y=this.norT2X=this.norT1Z=this.norT1Y=this.norT1X=this.binU2Z=this.binU2Y=this.binU2X=this.binU1Z=this.binU1Y=this.binU1X=this.tanU2Z=this.tanU2Y=this.tanU2X=this.tanU1Z=this.tanU1Y=this.tanU1X=this.norU2Z=this.norU2Y=this.norU2X=this.norU1Z=this.norU1Y=this.norU1X=this.rp2Z=this.rp2Y=this.rp2X=this.rp1Z=this.rp1Y=this.rp1X=this.binZ=this.binY=this.binX=this.tanZ=this.tanY=this.tanX=this.norZ=this.norY=this.norX=NaN;this.next=null;this.last=!1};OIMO.ImpulseDataBuffer=function(){this.impulse=this.lp2Z=this.lp2Y=this.lp2X=this.lp1Z=this.lp1Y=this.lp1X=NaN};OIMO.ManifoldPoint=function(){this.warmStarted=!1;this.position=new OIMO.Vec3;this.localPoint1=new OIMO.Vec3;this.localPoint2=new OIMO.Vec3;this.normal=new OIMO.Vec3;this.tangent=new OIMO.Vec3;this.binormal=new OIMO.Vec3;this.penetration=this.binormalDenominator=this.tangentDenominator=this.normalDenominator=this.binormalImpulse=this.tangentImpulse=this.normalImpulse=0};OIMO.MassInfo=function(){this.mass=0;this.inertia=new OIMO.Mat33};OIMO.Shape=function(a){this.next=this.prev=null;this.type=0;this.contactLink=this.parent=this.proxy=null;this.numContacts=0;this.id=OIMO.nextID++;this.position=new OIMO.Vec3;this.relativePosition=(new OIMO.Vec3).copy(a.relativePosition);this.rotation=new OIMO.Mat33;this.relativeRotation=(new OIMO.Mat33).copy(a.relativeRotation);this.aabb=new OIMO.AABB;this.density=a.density;this.friction=a.friction;this.restitution=a.restitution;this.belongsTo=a.belongsTo;this.collidesWith=a.collidesWith};
OIMO.Shape.prototype={constructor:OIMO.Shape,calculateMassInfo:function(a){throw Error("Inheritance error.");},updateProxy:function(){throw Error("Inheritance error.");}};OIMO.ShapeConfig=function(){this.relativePosition=new OIMO.Vec3;this.relativeRotation=new OIMO.Mat33;this.friction=0.4;this.restitution=0.2;this.belongsTo=this.density=1;this.collidesWith=4294967295};OIMO.BoxShape=function(a,c,b,d){OIMO.Shape.call(this,a);this.width=c;this.height=b;this.depth=d;this.halfWidth=0.5*c;this.halfHeight=0.5*b;this.halfDepth=0.5*d;this.dimentions=new OIMO_ARRAY_TYPE(18);this.elements=new OIMO_ARRAY_TYPE(24);this.type=OIMO.SHAPE_BOX};OIMO.BoxShape.prototype=Object.create(OIMO.Shape.prototype);
OIMO.BoxShape.prototype.calculateMassInfo=function(a){var c=this.width*this.height*this.depth*this.density;a.mass=c;a.inertia.init(c*(this.height*this.height+this.depth*this.depth)/12,0,0,0,c*(this.width*this.width+this.depth*this.depth)/12,0,0,0,c*(this.width*this.width+this.height*this.height)/12)};
OIMO.BoxShape.prototype.updateProxy=function(){var a=this.rotation.elements,c=this.dimentions;c[0]=a[0];c[1]=a[3];c[2]=a[6];c[3]=a[1];c[4]=a[4];c[5]=a[7];c[6]=a[2];c[7]=a[5];c[8]=a[8];c[9]=a[0]*this.halfWidth;c[10]=a[3]*this.halfWidth;c[11]=a[6]*this.halfWidth;c[12]=a[1]*this.halfHeight;c[13]=a[4]*this.halfHeight;c[14]=a[7]*this.halfHeight;c[15]=a[2]*this.halfDepth;c[16]=a[5]*this.halfDepth;c[17]=a[8]*this.halfDepth;var a=c[9],b=c[10],d=c[11],e=c[12],f=c[13],g=c[14],h=c[15],k=c[16],l=c[17],n=this.position.x,
p=this.position.y,m=this.position.z,t=this.elements;t[0]=n+a+e+h;t[1]=p+b+f+k;t[2]=m+d+g+l;t[3]=n+a+e-h;t[4]=p+b+f-k;t[5]=m+d+g-l;t[6]=n+a-e+h;t[7]=p+b-f+k;t[8]=m+d-g+l;t[9]=n+a-e-h;t[10]=p+b-f-k;t[11]=m+d-g-l;t[12]=n-a+e+h;t[13]=p-b+f+k;t[14]=m-d+g+l;t[15]=n-a+e-h;t[16]=p-b+f-k;t[17]=m-d+g-l;t[18]=n-a-e+h;t[19]=p-b-f+k;t[20]=m-d-g+l;t[21]=n-a-e-h;t[22]=p-b-f-k;t[23]=m-d-g-l;a=0>c[9]?-c[9]:c[9];b=0>c[10]?-c[10]:c[10];d=0>c[11]?-c[11]:c[11];a=0>c[12]?a-c[12]:a+c[12];b=0>c[13]?b-c[13]:b+c[13];d=0>c[14]?
d-c[14]:d+c[14];a=0>c[15]?a-c[15]:a+c[15];b=0>c[16]?b-c[16]:b+c[16];d=0>c[17]?d-c[17]:d+c[17];this.aabb.init(this.position.x-a-0.005,this.position.x+a+0.005,this.position.y-b-0.005,this.position.y+b+0.005,this.position.z-d-0.005,this.position.z+d+0.005);null!==this.proxy&&this.proxy.update()};OIMO.SphereShape=function(a,c){OIMO.Shape.call(this,a);this.radius=c;this.type=OIMO.SHAPE_SPHERE};OIMO.SphereShape.prototype=Object.create(OIMO.Shape.prototype);OIMO.SphereShape.prototype.calculateMassInfo=function(a){var c=4/3*Math.PI*this.radius*this.radius*this.radius*this.density;a.mass=c;c=c*this.radius*this.radius*2/5;a.inertia.init(c,0,0,0,c,0,0,0,c)};
OIMO.SphereShape.prototype.updateProxy=function(){this.aabb.init(this.position.x-this.radius-0.005,this.position.x+this.radius+0.005,this.position.y-this.radius-0.005,this.position.y+this.radius+0.005,this.position.z-this.radius-0.005,this.position.z+this.radius+0.005);null!==this.proxy&&this.proxy.update()};OIMO.CollisionDetector=function(){this.flip=!1};OIMO.CollisionDetector.prototype={constructor:OIMO.CollisionDetector,detectCollision:function(a,c,b){throw Error("Inheritance error.");}};OIMO.BoxBoxCollisionDetector=function(){OIMO.CollisionDetector.call(this);this.clipVertices1=new OIMO_ARRAY_TYPE(24);this.clipVertices2=new OIMO_ARRAY_TYPE(24);this.used=new OIMO_ARRAY_TYPE(8);this.INF=1/0};OIMO.BoxBoxCollisionDetector.prototype=Object.create(OIMO.CollisionDetector.prototype);
OIMO.BoxBoxCollisionDetector.prototype.detectCollision=function(a,c,b){var d,e;a.id<c.id?(d=a,e=c):(d=c,e=a);var f=d.elements,g=e.elements,h=d.dimentions,k=e.dimentions,l=d.position,n=e.position,p=l.x,m=l.y,t=l.z,r=n.x,w=n.y,u=n.z,y=r-p,z=w-m,A=u-t,E=d.halfWidth,U=d.halfHeight,V=d.halfDepth,W=e.halfWidth,ga=e.halfHeight,qa=e.halfDepth,N=h[0],K=h[1],ha=h[2],S=h[3],G=h[4],L=h[5],M=h[6],X=h[7],Y=h[8],Va=h[9],Wa=h[10],Xa=h[11],Ya=h[12],Za=h[13],$a=h[14],ab=h[15],bb=h[16],cb=h[17],Z=k[0],$=k[1],aa=k[2],
ba=k[3],ca=k[4],da=k[5],ea=k[6],ja=k[7],ka=k[8],Qb=k[9],Rb=k[10],Sb=k[11],Tb=k[12],Ub=k[13],Vb=k[14],Wb=k[15],Xb=k[16],Yb=k[17],db=K*aa-ha*$,eb=ha*Z-N*aa,ib=N*$-K*Z,jb=K*da-ha*ca,kb=ha*ba-N*da,lb=N*ca-K*ba,mb=K*ka-ha*ja,nb=ha*ea-N*ka,ob=N*ja-K*ea,pb=G*aa-L*$,qb=L*Z-S*aa,rb=S*$-G*Z,sb=G*da-L*ca,tb=L*ba-S*da,ub=S*ca-G*ba,vb=G*ka-L*ja,wb=L*ea-S*ka,xb=S*ja-G*ea,yb=X*aa-Y*$,zb=Y*Z-M*aa,Ab=M*$-X*Z,Bb=X*da-Y*ca,Cb=Y*ba-M*da,Db=M*ca-X*ba,Eb=X*ka-Y*ja,Fb=Y*ea-M*ka,Gb=M*ja-X*ea,Bc,Cc,Dc,Ec,Fc,Gc,qc,rc,sc,tc,
uc,vc,wc,xc,yc,kc,lc,mc,nc,oc,pc,Zb,$b,ac,bc,cc,dc,ec,fc,gc,Hc=!1,Ic=!1,Jc=!1,Kc=!1,Lc=!1,Mc=!1,Nc=!1,Oc=!1,Pc=!1,v,la,ma,q,s,na;v=N*y+K*z+ha*A;(Bc=0<v)||(v=-v);la=E;q=N*Z+K*$+ha*aa;s=N*ba+K*ca+ha*da;na=N*ea+K*ja+ha*ka;0>q&&(q=-q);0>s&&(s=-s);0>na&&(na=-na);ma=q*W+s*ga+na*qa;kc=v-la-ma;if(!(0<kc||(v=S*y+G*z+L*A,(Cc=0<v)||(v=-v),la=U,q=S*Z+G*$+L*aa,s=S*ba+G*ca+L*da,na=S*ea+G*ja+L*ka,0>q&&(q=-q),0>s&&(s=-s),0>na&&(na=-na),ma=q*W+s*ga+na*qa,lc=v-la-ma,0<lc||(v=M*y+X*z+Y*A,(Dc=0<v)||(v=-v),la=V,q=M*Z+
X*$+Y*aa,s=M*ba+X*ca+Y*da,na=M*ea+X*ja+Y*ka,0>q&&(q=-q),0>s&&(s=-s),0>na&&(na=-na),ma=q*W+s*ga+na*qa,mc=v-la-ma,0<mc||(v=Z*y+$*z+aa*A,(Ec=0<v)||(v=-v),q=Z*N+$*K+aa*ha,s=Z*S+$*G+aa*L,na=Z*M+$*X+aa*Y,0>q&&(q=-q),0>s&&(s=-s),0>na&&(na=-na),la=q*E+s*U+na*V,ma=W,nc=1*(v-la-ma),0<nc||(v=ba*y+ca*z+da*A,(Fc=0<v)||(v=-v),q=ba*N+ca*K+da*ha,s=ba*S+ca*G+da*L,na=ba*M+ca*X+da*Y,0>q&&(q=-q),0>s&&(s=-s),0>na&&(na=-na),la=q*E+s*U+na*V,ma=ga,oc=1*(v-la-ma),0<oc||(v=ea*y+ja*z+ka*A,(Gc=0<v)||(v=-v),q=ea*N+ja*K+ka*ha,
s=ea*S+ja*G+ka*L,na=ea*M+ja*X+ka*Y,0>q&&(q=-q),0>s&&(s=-s),0>na&&(na=-na),la=q*E+s*U+na*V,ma=qa,pc=1*(v-la-ma),0<pc))))))){v=db*db+eb*eb+ib*ib;if(1E-5<v){if(v=1/Math.sqrt(v),db*=v,eb*=v,ib*=v,v=db*y+eb*z+ib*A,(qc=0<v)||(v=-v),q=db*S+eb*G+ib*L,s=db*M+eb*X+ib*Y,0>q&&(q=-q),0>s&&(s=-s),la=q*U+s*V,q=db*ba+eb*ca+ib*da,s=db*ea+eb*ja+ib*ka,0>q&&(q=-q),0>s&&(s=-s),ma=q*ga+s*qa,Zb=v-la-ma,0<Zb)return}else qc=!1,Zb=0,Hc=!0;v=jb*jb+kb*kb+lb*lb;if(1E-5<v){if(v=1/Math.sqrt(v),jb*=v,kb*=v,lb*=v,v=jb*y+kb*z+lb*
A,(rc=0<v)||(v=-v),q=jb*S+kb*G+lb*L,s=jb*M+kb*X+lb*Y,0>q&&(q=-q),0>s&&(s=-s),la=q*U+s*V,q=jb*Z+kb*$+lb*aa,s=jb*ea+kb*ja+lb*ka,0>q&&(q=-q),0>s&&(s=-s),ma=q*W+s*qa,$b=v-la-ma,0<$b)return}else rc=!1,$b=0,Ic=!0;v=mb*mb+nb*nb+ob*ob;if(1E-5<v){if(v=1/Math.sqrt(v),mb*=v,nb*=v,ob*=v,v=mb*y+nb*z+ob*A,(sc=0<v)||(v=-v),q=mb*S+nb*G+ob*L,s=mb*M+nb*X+ob*Y,0>q&&(q=-q),0>s&&(s=-s),la=q*U+s*V,q=mb*Z+nb*$+ob*aa,s=mb*ba+nb*ca+ob*da,0>q&&(q=-q),0>s&&(s=-s),ma=q*W+s*ga,ac=v-la-ma,0<ac)return}else sc=!1,ac=0,Jc=!0;v=pb*
pb+qb*qb+rb*rb;if(1E-5<v){if(v=1/Math.sqrt(v),pb*=v,qb*=v,rb*=v,v=pb*y+qb*z+rb*A,(tc=0<v)||(v=-v),q=pb*N+qb*K+rb*ha,s=pb*M+qb*X+rb*Y,0>q&&(q=-q),0>s&&(s=-s),la=q*E+s*V,q=pb*ba+qb*ca+rb*da,s=pb*ea+qb*ja+rb*ka,0>q&&(q=-q),0>s&&(s=-s),ma=q*ga+s*qa,bc=v-la-ma,0<bc)return}else tc=!1,bc=0,Kc=!0;v=sb*sb+tb*tb+ub*ub;if(1E-5<v){if(v=1/Math.sqrt(v),sb*=v,tb*=v,ub*=v,v=sb*y+tb*z+ub*A,(uc=0<v)||(v=-v),q=sb*N+tb*K+ub*ha,s=sb*M+tb*X+ub*Y,0>q&&(q=-q),0>s&&(s=-s),la=q*E+s*V,q=sb*Z+tb*$+ub*aa,s=sb*ea+tb*ja+ub*ka,
0>q&&(q=-q),0>s&&(s=-s),ma=q*W+s*qa,cc=v-la-ma,0<cc)return}else uc=!1,cc=0,Lc=!0;v=vb*vb+wb*wb+xb*xb;if(1E-5<v){if(v=1/Math.sqrt(v),vb*=v,wb*=v,xb*=v,v=vb*y+wb*z+xb*A,(vc=0<v)||(v=-v),q=vb*N+wb*K+xb*ha,s=vb*M+wb*X+xb*Y,0>q&&(q=-q),0>s&&(s=-s),la=q*E+s*V,q=vb*Z+wb*$+xb*aa,s=vb*ba+wb*ca+xb*da,0>q&&(q=-q),0>s&&(s=-s),ma=q*W+s*ga,dc=v-la-ma,0<dc)return}else vc=!1,dc=0,Mc=!0;v=yb*yb+zb*zb+Ab*Ab;if(1E-5<v){if(v=1/Math.sqrt(v),yb*=v,zb*=v,Ab*=v,v=yb*y+zb*z+Ab*A,(wc=0<v)||(v=-v),q=yb*N+zb*K+Ab*ha,s=yb*S+
zb*G+Ab*L,0>q&&(q=-q),0>s&&(s=-s),la=q*E+s*U,q=yb*ba+zb*ca+Ab*da,s=yb*ea+zb*ja+Ab*ka,0>q&&(q=-q),0>s&&(s=-s),ma=q*ga+s*qa,ec=v-la-ma,0<ec)return}else wc=!1,ec=0,Nc=!0;v=Bb*Bb+Cb*Cb+Db*Db;if(1E-5<v){if(v=1/Math.sqrt(v),Bb*=v,Cb*=v,Db*=v,v=Bb*y+Cb*z+Db*A,(xc=0<v)||(v=-v),q=Bb*N+Cb*K+Db*ha,s=Bb*S+Cb*G+Db*L,0>q&&(q=-q),0>s&&(s=-s),la=q*E+s*U,q=Bb*Z+Cb*$+Db*aa,s=Bb*ea+Cb*ja+Db*ka,0>q&&(q=-q),0>s&&(s=-s),ma=q*W+s*qa,fc=v-la-ma,0<fc)return}else xc=!1,fc=0,Oc=!0;v=Eb*Eb+Fb*Fb+Gb*Gb;if(1E-5<v){if(v=1/Math.sqrt(v),
Eb*=v,Fb*=v,Gb*=v,v=Eb*y+Fb*z+Gb*A,(yc=0<v)||(v=-v),q=Eb*N+Fb*K+Gb*ha,s=Eb*S+Fb*G+Gb*L,0>q&&(q=-q),0>s&&(s=-s),la=q*E+s*U,q=Eb*Z+Fb*$+Gb*aa,s=Eb*ba+Fb*ca+Gb*da,0>q&&(q=-q),0>s&&(s=-s),ma=q*W+s*ga,gc=v-la-ma,0<gc)return}else yc=!1,gc=0,Pc=!0;var Fa=kc,ua=kc,Ha=0,Ea=Bc;lc>ua&&(ua=Fa=lc,Ha=1,Ea=Cc);mc>ua&&(ua=Fa=mc,Ha=2,Ea=Dc);nc>ua&&(ua=Fa=nc,Ha=3,Ea=Ec);oc>ua&&(ua=Fa=oc,Ha=4,Ea=Fc);pc>ua&&(ua=Fa=pc,Ha=5,Ea=Gc);Zb-0.01>ua&&!Hc&&(Fa=Zb,ua=Zb-0.01,Ha=6,Ea=qc);$b-0.01>ua&&!Ic&&(Fa=$b,ua=$b-0.01,Ha=7,Ea=
rc);ac-0.01>ua&&!Jc&&(Fa=ac,ua=ac-0.01,Ha=8,Ea=sc);bc-0.01>ua&&!Kc&&(Fa=bc,ua=bc-0.01,Ha=9,Ea=tc);cc-0.01>ua&&!Lc&&(Fa=cc,ua=cc-0.01,Ha=10,Ea=uc);dc-0.01>ua&&!Mc&&(Fa=dc,ua=dc-0.01,Ha=11,Ea=vc);ec-0.01>ua&&!Nc&&(Fa=ec,ua=ec-0.01,Ha=12,Ea=wc);fc-0.01>ua&&!Oc&&(Fa=fc,ua=fc-0.01,Ha=13,Ea=xc);gc-0.01>ua&&!Pc&&(Fa=gc,Ha=14,Ea=yc);var B=0,C=0,D=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,va=0,wa=0,xa=0,Hb=0,Ib=0,Jb=0,Kb=0,Lb=0,Mb=0,hc=!1;switch(Ha){case 0:Ea?(va=p+Va,wa=m+Wa,xa=t+Xa,B=N,C=K,D=ha):(va=p-Va,wa=m-Wa,
xa=t-Xa,B=-N,C=-K,D=-ha);Hb=Ya;Ib=Za;Jb=$a;ya=-S;za=-G;Aa=-L;Kb=ab;Lb=bb;Mb=cb;Ba=-M;Ca=-X;Da=-Y;break;case 1:Ea?(va=p+Ya,wa=m+Za,xa=t+$a,B=S,C=G,D=L):(va=p-Ya,wa=m-Za,xa=t-$a,B=-S,C=-G,D=-L);Hb=Va;Ib=Wa;Jb=Xa;ya=-N;za=-K;Aa=-ha;Kb=ab;Lb=bb;Mb=cb;Ba=-M;Ca=-X;Da=-Y;break;case 2:Ea?(va=p+ab,wa=m+bb,xa=t+cb,B=M,C=X,D=Y):(va=p-ab,wa=m-bb,xa=t-cb,B=-M,C=-X,D=-Y);Hb=Va;Ib=Wa;Jb=Xa;ya=-N;za=-K;Aa=-ha;Kb=Ya;Lb=Za;Mb=$a;Ba=-S;Ca=-G;Da=-L;break;case 3:hc=!0;Ea?(va=r-Qb,wa=w-Rb,xa=u-Sb,B=-Z,C=-$,D=-aa):(va=
r+Qb,wa=w+Rb,xa=u+Sb,B=Z,C=$,D=aa);Hb=Tb;Ib=Ub;Jb=Vb;ya=-ba;za=-ca;Aa=-da;Kb=Wb;Lb=Xb;Mb=Yb;Ba=-ea;Ca=-ja;Da=-ka;break;case 4:hc=!0;Ea?(va=r-Tb,wa=w-Ub,xa=u-Vb,B=-ba,C=-ca,D=-da):(va=r+Tb,wa=w+Ub,xa=u+Vb,B=ba,C=ca,D=da);Hb=Qb;Ib=Rb;Jb=Sb;ya=-Z;za=-$;Aa=-aa;Kb=Wb;Lb=Xb;Mb=Yb;Ba=-ea;Ca=-ja;Da=-ka;break;case 5:hc=!0;Ea?(va=r-Wb,wa=w-Xb,xa=u-Yb,B=-ea,C=-ja,D=-ka):(va=r+Wb,wa=w+Xb,xa=u+Yb,B=ea,C=ja,D=ka);Hb=Qb;Ib=Rb;Jb=Sb;ya=-Z;za=-$;Aa=-aa;Kb=Tb;Lb=Ub;Mb=Vb;Ba=-ba;Ca=-ca;Da=-da;break;case 6:B=db;C=eb;
D=ib;ya=N;za=K;Aa=ha;Ba=Z;Ca=$;Da=aa;break;case 7:B=jb;C=kb;D=lb;ya=N;za=K;Aa=ha;Ba=ba;Ca=ca;Da=da;break;case 8:B=mb;C=nb;D=ob;ya=N;za=K;Aa=ha;Ba=ea;Ca=ja;Da=ka;break;case 9:B=pb;C=qb;D=rb;ya=S;za=G;Aa=L;Ba=Z;Ca=$;Da=aa;break;case 10:B=sb;C=tb;D=ub;ya=S;za=G;Aa=L;Ba=ba;Ca=ca;Da=da;break;case 11:B=vb;C=wb;D=xb;ya=S;za=G;Aa=L;Ba=ea;Ca=ja;Da=ka;break;case 12:B=yb;C=zb;D=Ab;ya=M;za=X;Aa=Y;Ba=Z;Ca=$;Da=aa;break;case 13:B=Bb;C=Cb;D=Db;ya=M;za=X;Aa=Y;Ba=ba;Ca=ca;Da=da;break;case 14:B=Eb,C=Fb,D=Gb,ya=M,za=
X,Aa=Y,Ba=ea,Ca=ja,Da=ka}if(5<Ha){Ea||(B=-B,C=-C,D=-D);var R,oa,O,P,Q,fb,gb,hb,Nb,Ob,Pb;fb=f[0];gb=f[1];hb=f[2];oa=B*fb+C*gb+D*hb;O=f[3];P=f[4];Q=f[5];R=B*O+C*P+D*Q;R>oa&&(oa=R,fb=O,gb=P,hb=Q);O=f[6];P=f[7];Q=f[8];R=B*O+C*P+D*Q;R>oa&&(oa=R,fb=O,gb=P,hb=Q);O=f[9];P=f[10];Q=f[11];R=B*O+C*P+D*Q;R>oa&&(oa=R,fb=O,gb=P,hb=Q);O=f[12];P=f[13];Q=f[14];R=B*O+C*P+D*Q;R>oa&&(oa=R,fb=O,gb=P,hb=Q);O=f[15];P=f[16];Q=f[17];R=B*O+C*P+D*Q;R>oa&&(oa=R,fb=O,gb=P,hb=Q);O=f[18];P=f[19];Q=f[20];R=B*O+C*P+D*Q;R>oa&&(oa=
R,fb=O,gb=P,hb=Q);O=f[21];P=f[22];Q=f[23];R=B*O+C*P+D*Q;R>oa&&(oa=R,fb=O,gb=P,hb=Q);Nb=g[0];Ob=g[1];Pb=g[2];oa=B*Nb+C*Ob+D*Pb;O=g[3];P=g[4];Q=g[5];R=B*O+C*P+D*Q;R<oa&&(oa=R,Nb=O,Ob=P,Pb=Q);O=g[6];P=g[7];Q=g[8];R=B*O+C*P+D*Q;R<oa&&(oa=R,Nb=O,Ob=P,Pb=Q);O=g[9];P=g[10];Q=g[11];R=B*O+C*P+D*Q;R<oa&&(oa=R,Nb=O,Ob=P,Pb=Q);O=g[12];P=g[13];Q=g[14];R=B*O+C*P+D*Q;R<oa&&(oa=R,Nb=O,Ob=P,Pb=Q);O=g[15];P=g[16];Q=g[17];R=B*O+C*P+D*Q;R<oa&&(oa=R,Nb=O,Ob=P,Pb=Q);O=g[18];P=g[19];Q=g[20];R=B*O+C*P+D*Q;R<oa&&(oa=R,Nb=
O,Ob=P,Pb=Q);O=g[21];P=g[22];Q=g[23];R=B*O+C*P+D*Q;R<oa&&(oa=R,Nb=O,Ob=P,Pb=Q);O=Nb-fb;P=Ob-gb;Q=Pb-hb;q=ya*Ba+za*Ca+Aa*Da;var fa=(O*(ya-Ba*q)+P*(za-Ca*q)+Q*(Aa-Da*q))/(1-q*q);b.addPoint(fb+ya*fa+B*Fa*0.5,gb+za*fa+C*Fa*0.5,hb+Aa*fa+D*Fa*0.5,B,C,D,Fa,!1)}else{var Ia,Ja,Ka,La,Ma,Na,Oa,Pa,Qa,Ra,Sa,Ta,pa=1,F=0,Ua=0;if(hc)switch(F=N*B+K*C+ha*D,F<pa&&(pa=F,Ua=0),-F<pa&&(pa=-F,Ua=1),F=S*B+G*C+L*D,F<pa&&(pa=F,Ua=2),-F<pa&&(pa=-F,Ua=3),F=M*B+X*C+Y*D,F<pa&&(pa=F,Ua=4),-F<pa&&(pa=-F,Ua=5),Ua){case 0:Ia=f[0];
Ja=f[1];Ka=f[2];La=f[6];Ma=f[7];Na=f[8];Oa=f[9];Pa=f[10];Qa=f[11];Ra=f[3];Sa=f[4];Ta=f[5];break;case 1:Ia=f[15];Ja=f[16];Ka=f[17];La=f[21];Ma=f[22];Na=f[23];Oa=f[18];Pa=f[19];Qa=f[20];Ra=f[12];Sa=f[13];Ta=f[14];break;case 2:Ia=f[12];Ja=f[13];Ka=f[14];La=f[0];Ma=f[1];Na=f[2];Oa=f[3];Pa=f[4];Qa=f[5];Ra=f[15];Sa=f[16];Ta=f[17];break;case 3:Ia=f[21];Ja=f[22];Ka=f[23];La=f[9];Ma=f[10];Na=f[11];Oa=f[6];Pa=f[7];Qa=f[8];Ra=f[18];Sa=f[19];Ta=f[20];break;case 4:Ia=f[12];Ja=f[13];Ka=f[14];La=f[18];Ma=f[19];
Na=f[20];Oa=f[6];Pa=f[7];Qa=f[8];Ra=f[0];Sa=f[1];Ta=f[2];break;case 5:Ia=f[3],Ja=f[4],Ka=f[5],La=f[6],Ma=f[7],Na=f[8],Oa=f[21],Pa=f[22],Qa=f[23],Ra=f[15],Sa=f[16],Ta=f[17]}else switch(F=Z*B+$*C+aa*D,F<pa&&(pa=F,Ua=0),-F<pa&&(pa=-F,Ua=1),F=ba*B+ca*C+da*D,F<pa&&(pa=F,Ua=2),-F<pa&&(pa=-F,Ua=3),F=ea*B+ja*C+ka*D,F<pa&&(pa=F,Ua=4),-F<pa&&(pa=-F,Ua=5),Ua){case 0:Ia=g[0];Ja=g[1];Ka=g[2];La=g[6];Ma=g[7];Na=g[8];Oa=g[9];Pa=g[10];Qa=g[11];Ra=g[3];Sa=g[4];Ta=g[5];break;case 1:Ia=g[15];Ja=g[16];Ka=g[17];La=g[21];
Ma=g[22];Na=g[23];Oa=g[18];Pa=g[19];Qa=g[20];Ra=g[12];Sa=g[13];Ta=g[14];break;case 2:Ia=g[12];Ja=g[13];Ka=g[14];La=g[0];Ma=g[1];Na=g[2];Oa=g[3];Pa=g[4];Qa=g[5];Ra=g[15];Sa=g[16];Ta=g[17];break;case 3:Ia=g[21];Ja=g[22];Ka=g[23];La=g[9];Ma=g[10];Na=g[11];Oa=g[6];Pa=g[7];Qa=g[8];Ra=g[18];Sa=g[19];Ta=g[20];break;case 4:Ia=g[12];Ja=g[13];Ka=g[14];La=g[18];Ma=g[19];Na=g[20];Oa=g[6];Pa=g[7];Qa=g[8];Ra=g[0];Sa=g[1];Ta=g[2];break;case 5:Ia=g[3],Ja=g[4],Ka=g[5],La=g[9],Ma=g[10],Na=g[11],Oa=g[21],Pa=g[22],Qa=
g[23],Ra=g[15],Sa=g[16],Ta=g[17]}var Ga,T,x,H,I,J,ra,sa,ta;this.clipVertices1[0]=Ia;this.clipVertices1[1]=Ja;this.clipVertices1[2]=Ka;this.clipVertices1[3]=La;this.clipVertices1[4]=Ma;this.clipVertices1[5]=Na;this.clipVertices1[6]=Oa;this.clipVertices1[7]=Pa;this.clipVertices1[8]=Qa;this.clipVertices1[9]=Ra;this.clipVertices1[10]=Sa;this.clipVertices1[11]=Ta;T=0;H=this.clipVertices1[9];I=this.clipVertices1[10];J=this.clipVertices1[11];q=(H-va-Hb)*ya+(I-wa-Ib)*za+(J-xa-Jb)*Aa;for(var ia=0;4>ia;ia++)x=
3*ia,ra=this.clipVertices1[x],sa=this.clipVertices1[x+1],ta=this.clipVertices1[x+2],s=(ra-va-Hb)*ya+(sa-wa-Ib)*za+(ta-xa-Jb)*Aa,0<q?0<s?(x=3*T,T++,this.clipVertices2[x]=ra,this.clipVertices2[x+1]=sa,this.clipVertices2[x+2]=ta):(x=3*T,T++,fa=q/(q-s),this.clipVertices2[x]=H+(ra-H)*fa,this.clipVertices2[x+1]=I+(sa-I)*fa,this.clipVertices2[x+2]=J+(ta-J)*fa):0<s&&(x=3*T,T++,fa=q/(q-s),this.clipVertices2[x]=H+(ra-H)*fa,this.clipVertices2[x+1]=I+(sa-I)*fa,this.clipVertices2[x+2]=J+(ta-J)*fa,x=3*T,T++,this.clipVertices2[x]=
ra,this.clipVertices2[x+1]=sa,this.clipVertices2[x+2]=ta),H=ra,I=sa,J=ta,q=s;Ga=T;if(0!=Ga){T=0;x=3*(Ga-1);H=this.clipVertices2[x];I=this.clipVertices2[x+1];J=this.clipVertices2[x+2];q=(H-va-Kb)*Ba+(I-wa-Lb)*Ca+(J-xa-Mb)*Da;for(ia=0;ia<Ga;ia++)x=3*ia,ra=this.clipVertices2[x],sa=this.clipVertices2[x+1],ta=this.clipVertices2[x+2],s=(ra-va-Kb)*Ba+(sa-wa-Lb)*Ca+(ta-xa-Mb)*Da,0<q?0<s?(x=3*T,T++,this.clipVertices1[x]=ra,this.clipVertices1[x+1]=sa,this.clipVertices1[x+2]=ta):(x=3*T,T++,fa=q/(q-s),this.clipVertices1[x]=
H+(ra-H)*fa,this.clipVertices1[x+1]=I+(sa-I)*fa,this.clipVertices1[x+2]=J+(ta-J)*fa):0<s&&(x=3*T,T++,fa=q/(q-s),this.clipVertices1[x]=H+(ra-H)*fa,this.clipVertices1[x+1]=I+(sa-I)*fa,this.clipVertices1[x+2]=J+(ta-J)*fa,x=3*T,T++,this.clipVertices1[x]=ra,this.clipVertices1[x+1]=sa,this.clipVertices1[x+2]=ta),H=ra,I=sa,J=ta,q=s;Ga=T;if(0!=Ga){T=0;x=3*(Ga-1);H=this.clipVertices1[x];I=this.clipVertices1[x+1];J=this.clipVertices1[x+2];q=(H-va+Hb)*-ya+(I-wa+Ib)*-za+(J-xa+Jb)*-Aa;for(ia=0;ia<Ga;ia++)x=3*
ia,ra=this.clipVertices1[x],sa=this.clipVertices1[x+1],ta=this.clipVertices1[x+2],s=(ra-va+Hb)*-ya+(sa-wa+Ib)*-za+(ta-xa+Jb)*-Aa,0<q?0<s?(x=3*T,T++,this.clipVertices2[x]=ra,this.clipVertices2[x+1]=sa,this.clipVertices2[x+2]=ta):(x=3*T,T++,fa=q/(q-s),this.clipVertices2[x]=H+(ra-H)*fa,this.clipVertices2[x+1]=I+(sa-I)*fa,this.clipVertices2[x+2]=J+(ta-J)*fa):0<s&&(x=3*T,T++,fa=q/(q-s),this.clipVertices2[x]=H+(ra-H)*fa,this.clipVertices2[x+1]=I+(sa-I)*fa,this.clipVertices2[x+2]=J+(ta-J)*fa,x=3*T,T++,this.clipVertices2[x]=
ra,this.clipVertices2[x+1]=sa,this.clipVertices2[x+2]=ta),H=ra,I=sa,J=ta,q=s;Ga=T;if(0!=Ga){T=0;x=3*(Ga-1);H=this.clipVertices2[x];I=this.clipVertices2[x+1];J=this.clipVertices2[x+2];q=(H-va+Kb)*-Ba+(I-wa+Lb)*-Ca+(J-xa+Mb)*-Da;for(ia=0;ia<Ga;ia++)x=3*ia,ra=this.clipVertices2[x],sa=this.clipVertices2[x+1],ta=this.clipVertices2[x+2],s=(ra-va+Kb)*-Ba+(sa-wa+Lb)*-Ca+(ta-xa+Mb)*-Da,0<q?0<s?(x=3*T,T++,this.clipVertices1[x]=ra,this.clipVertices1[x+1]=sa,this.clipVertices1[x+2]=ta):(x=3*T,T++,fa=q/(q-s),
this.clipVertices1[x]=H+(ra-H)*fa,this.clipVertices1[x+1]=I+(sa-I)*fa,this.clipVertices1[x+2]=J+(ta-J)*fa):0<s&&(x=3*T,T++,fa=q/(q-s),this.clipVertices1[x]=H+(ra-H)*fa,this.clipVertices1[x+1]=I+(sa-I)*fa,this.clipVertices1[x+2]=J+(ta-J)*fa,x=3*T,T++,this.clipVertices1[x]=ra,this.clipVertices1[x+1]=sa,this.clipVertices1[x+2]=ta),H=ra,I=sa,J=ta,q=s;Ga=T;if(hc){var Sc=d;d=e;e=Sc}if(0!=Ga){var ic=d!=a;if(4<Ga){H=0.25*(Ia+La+Oa+Ra);I=0.25*(Ja+Ma+Pa+Sa);J=0.25*(Ka+Na+Qa+Ta);for(var ya=Ia-H,za=Ja-I,Aa=Ka-
J,Ba=La-H,Ca=Ma-I,Da=Na-J,zc=0,Qc=0,Ac=0,Rc=0,jc=-this.INF,pa=this.INF,ia=0;ia<Ga;ia++)this.used[ia]=!1,x=3*ia,H=this.clipVertices1[x],I=this.clipVertices1[x+1],J=this.clipVertices1[x+2],F=H*ya+I*za+J*Aa,F<pa&&(pa=F,zc=ia),F>jc&&(jc=F,Ac=ia);this.used[zc]=!0;this.used[Ac]=!0;jc=-this.INF;pa=this.INF;for(ia=0;ia<Ga;ia++)this.used[ia]||(x=3*ia,H=this.clipVertices1[x],I=this.clipVertices1[x+1],J=this.clipVertices1[x+2],F=H*Ba+I*Ca+J*Da,F<pa&&(pa=F,Qc=ia),F>jc&&(jc=F,Rc=ia));x=3*zc;H=this.clipVertices1[x];
I=this.clipVertices1[x+1];J=this.clipVertices1[x+2];F=(H-va)*B+(I-wa)*C+(J-xa)*D;0>F&&b.addPoint(H,I,J,B,C,D,F,ic);x=3*Qc;H=this.clipVertices1[x];I=this.clipVertices1[x+1];J=this.clipVertices1[x+2];F=(H-va)*B+(I-wa)*C+(J-xa)*D;0>F&&b.addPoint(H,I,J,B,C,D,F,ic);x=3*Ac;H=this.clipVertices1[x];I=this.clipVertices1[x+1];J=this.clipVertices1[x+2];F=(H-va)*B+(I-wa)*C+(J-xa)*D;0>F&&b.addPoint(H,I,J,B,C,D,F,ic);x=3*Rc;H=this.clipVertices1[x];I=this.clipVertices1[x+1];J=this.clipVertices1[x+2];F=(H-va)*B+
(I-wa)*C+(J-xa)*D;0>F&&b.addPoint(H,I,J,B,C,D,F,ic)}else for(ia=0;ia<Ga;ia++)x=3*ia,H=this.clipVertices1[x],I=this.clipVertices1[x+1],J=this.clipVertices1[x+2],F=(H-va)*B+(I-wa)*C+(J-xa)*D,0>F&&b.addPoint(H,I,J,B,C,D,F,ic)}}}}}}};OIMO.SphereBoxCollisionDetector=function(a){OIMO.CollisionDetector.call(this);this.flip=a};OIMO.SphereBoxCollisionDetector.prototype=Object.create(OIMO.CollisionDetector.prototype);
OIMO.SphereBoxCollisionDetector.prototype.detectCollision=function(a,c,b){var d,e;this.flip?(d=c,e=a):(d=a,e=c);var f=e.dimentions,g=d.position;a=g.x;c=g.y;var h=g.z,k=e.position,l=k.x,n=k.y,k=k.z;d=d.radius;var p=e.halfWidth,m=e.halfHeight,t=e.halfDepth;e=a-l;var r=c-n,w=h-k,u=f[0]*e+f[1]*r+f[2]*w,y=f[3]*e+f[4]*r+f[5]*w,z=f[6]*e+f[7]*r+f[8]*w;e=0;u>p?u=p:u<-p?u=-p:e=1;y>m?y=m:y<-m?y=-m:e|=2;z>t?z=t:z<-t?z=-t:e|=4;7==e?(e=0>u?p+u:p-u,r=0>y?m+y:m-y,w=0>z?t+z:t-z,e<r?e<w?(g=e-p,0>u?(e=f[0],r=f[1],w=
f[2]):(e=-f[0],r=-f[1],w=-f[2])):(g=w-t,0>z?(e=f[6],r=f[7],w=f[8]):(e=-f[6],r=-f[7],w=-f[8])):r<w?(g=r-m,0>y?(e=f[3],r=f[4],w=f[5]):(e=-f[3],r=-f[4],w=-f[5])):(g=w-t,0>z?(e=f[6],r=f[7],w=f[8]):(e=-f[6],r=-f[7],w=-f[8])),b.addPoint(a+d*e,c+d*r,h+d*w,e,r,w,g-d,this.flip)):(l=l+u*f[0]+y*f[3]+z*f[6],n=n+u*f[1]+y*f[4]+z*f[7],f=k+u*f[2]+y*f[5]+z*f[8],e=l-g.x,r=n-g.y,w=f-g.z,g=e*e+r*r+w*w,0<g&&g<d*d&&(g=Math.sqrt(g),f=1/g,e*=f,r*=f,w*=f,b.addPoint(a+d*e,c+d*r,h+d*w,e,r,w,g-d,this.flip)))};OIMO.SphereSphereCollisionDetector=function(){OIMO.CollisionDetector.call(this)};OIMO.SphereSphereCollisionDetector.prototype=Object.create(OIMO.CollisionDetector.prototype);OIMO.SphereSphereCollisionDetector.prototype.detectCollision=function(a,c,b){var d=a.position,e=c.position,f=e.x-d.x,g=e.y-d.y,e=e.z-d.z,h=f*f+g*g+e*e;a=a.radius;c=a+c.radius;if(0<h&&h<c*c){var h=Math.sqrt(h),k=1/h,f=f*k,g=g*k,e=e*k;b.addPoint(d.x+f*a,d.y+g*a,d.z+e*a,f,g,e,h-c,!1)}};OIMO.AABB=function(a,c,b,d,e,f){this.minX=a||0;this.maxX=c||0;this.minY=b||0;this.maxY=d||0;this.minZ=e||0;this.maxZ=f||0};
OIMO.AABB.prototype={constructor:OIMO.AABB,init:function(a,c,b,d,e,f){this.minX=a;this.maxX=c;this.minY=b;this.maxY=d;this.minZ=e;this.maxZ=f},combine:function(a,c){this.minX=a.minX<c.minX?a.minX:c.minX;this.maxX=a.maxX>c.maxX?a.maxX:c.maxX;this.minY=a.minY<c.minY?a.minY:c.minY;this.maxY=a.maxY>c.maxY?a.maxY:c.maxY;this.minZ=a.minZ<c.minZ?a.minZ:c.minZ;this.maxZ=a.maxZ>c.maxZ?a.maxZ:c.maxZ},surfaceArea:function(){var a=this.maxY-this.minY,c=this.maxZ-this.minZ;return 2*((this.maxX-this.minX)*(a+c)+
a*c)},intersectsWithPoint:function(a,c,b){return a>=this.minX&&a<=this.maxX&&c>=this.minY&&c<=this.maxY&&b>=this.minZ&&b<=this.maxZ}};OIMO.Proxy=function(a){this.shape=a;this.aabb=a.aabb};OIMO.Proxy.prototype={constructor:OIMO.Proxy,update:function(){throw Error("Inheritance error.");}};OIMO.BasicProxy=function(a){OIMO.Proxy.call(this,a)};OIMO.BasicProxy.prototype=Object.create(OIMO.Proxy.prototype);OIMO.BasicProxy.prototype.update=function(){};OIMO.BroadPhase=function(){this.numPairs=this.numPairChecks=this.types=0;this.bufferSize=256;this.pairs=[];for(var a=this.pairs.length=this.bufferSize;a--;)this.pairs[a]=new OIMO.Pair};
OIMO.BroadPhase.prototype={constructor:OIMO.BroadPhase,createProxy:function(a){throw Error("Inheritance error.");},addProxy:function(a){throw Error("Inheritance error.");},removeProxy:function(a){throw Error("Inheritance error.");},isAvailablePair:function(a,c){var b=a.parent,d=c.parent;if(b==d||!b.isDynamic&&!d.isDynamic||0==(a.belongsTo&c.collidesWith)||0==(c.belongsTo&a.collidesWith))return!1;var e;for(e=b.numJoints<d.numJoints?b.jointLink:d.jointLink;null!=e;){var f=e.joint;if(!f.allowCollision&&
(f.body1==b&&f.body2==d||f.body1==d&&f.body2==b))return!1;e=e.next}return!0},detectPairs:function(){for(;0<this.numPairs;){var a=this.pairs[--this.numPairs];a.shape1=null;a.shape2=null}this.numPairChecks=0;this.collectPairs()},collectPairs:function(){throw Error("Inheritance error.");},addPair:function(a,c){if(this.numPairs==this.bufferSize){for(var b=2*this.bufferSize,d=[],e=d.length=this.bufferSize;e--;)d[e]=this.pairs[e];for(e=this.bufferSize;e<b;e++)d[e]=new OIMO.Pair;this.pairs=d;this.bufferSize=
b}b=this.pairs[this.numPairs++];b.shape1=a;b.shape2=c}};OIMO.BruteForceBroadPhase=function(){OIMO.BroadPhase.call(this);this.types=1;this.numProxies=0;this.maxProxies=256;this.proxies=[];this.proxies.length=256};OIMO.BruteForceBroadPhase.prototype=Object.create(OIMO.BroadPhase.prototype);OIMO.BruteForceBroadPhase.prototype.createProxy=function(a){return new OIMO.BasicProxy(a)};
OIMO.BruteForceBroadPhase.prototype.addProxy=function(a){if(this.numProxies==this.maxProxies){this.maxProxies*=2;for(var c=[],b=this.numProxies;b--;)c[b]=this.proxies[b];this.proxies=c}this.proxies[this.numProxies++]=a};OIMO.BruteForceBroadPhase.prototype.removeProxy=function(a){for(var c=0,b=this.numProxies;c<b;c++)if(this.proxies[c]==a){this.proxies[c]=this.proxies[--this.numProxies];this.proxies[this.numProxies]=null;break}};
OIMO.BruteForceBroadPhase.prototype.collectPairs=function(){this.numPairChecks=this.numProxies*(this.numProxies-1)>>1;for(var a=this.numProxies;a--;)for(var c=this.proxies[a],b=c.aabb,c=c.shape,d=this.numProxies;d--;)if(0!==d){var e=this.proxies[d],f=e.aabb,e=e.shape;b.maxX<f.minX||b.minX>f.maxX||b.maxY<f.minY||b.minY>f.maxY||b.maxZ<f.minZ||b.minZ>f.maxZ||!this.isAvailablePair(c,e)||this.addPair(c,e)}};OIMO.Pair=function(){this.shape2=this.shape1=null};OIMO.SAPAxis=function(){this.numElements=0;this.stack=[];this.stack.length=64;this.bufferSize=256;this.elements=[];this.elements.length=this.bufferSize};
OIMO.SAPAxis.prototype={constructor:OIMO.SAPAxis,addElements:function(a,c){if(this.numElements+2>=this.bufferSize){this.bufferSize*=2;for(var b=0,d=this.numElements;b<d;b++);}this.elements[this.numElements++]=a;this.elements[this.numElements++]=c},removeElements:function(a,c){for(var b=-1,d=-1,e=0,f=this.numElements;e<f;e++){var g=this.elements[e];if(g==a||g==c)if(-1==b)b=e;else{d=e;break}}e=b+1;for(f=d;e<f;e++)this.elements[e-1]=this.elements[e];e=d+1;for(f=this.numElements;e<f;e++)this.elements[e-
2]=this.elements[e];this.elements[--this.numElements]=null;this.elements[--this.numElements]=null},sort:function(){for(var a=0,c=1;0!=this.numElements>>c;)c++;for(var c=c*this.numElements>>2,a=0,b=!1,d=this.elements,e=1,f=this.numElements;e<f;e++){var g=d[e],h=g.value,k=d[e-1];if(k.value>h){var l=e;do{d[l]=k;if(0==--l)break;k=d[l-1]}while(k.value>h);d[l]=g;a+=e-l;if(a>c){b=!0;break}}}if(b)for(a=2,c=this.stack,c[0]=0,c[1]=this.numElements-1;0<a;)if(b=c[--a],k=c[--a],g=b-k,16<g){e=k+(g>>1);g=d[e];d[e]=
d[b];d[b]=g;h=g.value;e=k-1;for(l=b;;){var n;do f=d[++e];while(f.value<h);do n=d[--l];while(h<n.value&&l!=k);if(e>=l)break;d[e]=n;d[l]=f}d[b]=d[e];d[e]=g;e-k>b-e?(c[a++]=k,c[a++]=e-1,c[a++]=e+1,c[a++]=b):(c[a++]=e+1,c[a++]=b,c[a++]=k,c[a++]=e-1)}else for(e=k+1;e<=b;e++)if(g=d[e],h=g.value,k=d[e-1],k.value>h){l=e;do{d[l]=k;if(0==--l)break;k=d[l-1]}while(k.value>h);d[l]=g}},calculateTestCount:function(){for(var a=1,c=0,b=1,d=this.numElements;b<d;b++)this.elements[b].max?a--:(c+=a,a++);return c}};OIMO.SAPBroadPhase=function(){OIMO.BroadPhase.call(this);this.types=2;this.numElementsS=this.numElementsD=0;this.axesD=[];this.axesS=[];this.axesD.length=3;this.axesS.length=3;this.axesD[0]=new OIMO.SAPAxis;this.axesD[1]=new OIMO.SAPAxis;this.axesD[2]=new OIMO.SAPAxis;this.axesS[0]=new OIMO.SAPAxis;this.axesS[1]=new OIMO.SAPAxis;this.axesS[2]=new OIMO.SAPAxis;this.index1=0;this.index2=1};OIMO.SAPBroadPhase.prototype=Object.create(OIMO.BroadPhase.prototype);
OIMO.SAPBroadPhase.prototype.createProxy=function(a){return new OIMO.SAPProxy(this,a)};OIMO.SAPBroadPhase.prototype.addProxy=function(a){a.isDynamic()?(this.axesD[0].addElements(a.min[0],a.max[0]),this.axesD[1].addElements(a.min[1],a.max[1]),this.axesD[2].addElements(a.min[2],a.max[2]),a.belongsTo=1,this.numElementsD+=2):(this.axesS[0].addElements(a.min[0],a.max[0]),this.axesS[1].addElements(a.min[1],a.max[1]),this.axesS[2].addElements(a.min[2],a.max[2]),a.belongsTo=2,this.numElementsS+=2)};
OIMO.SAPBroadPhase.prototype.removeProxy=function(a){if(0!=a.belongsTo){switch(a.belongsTo){case 1:this.axesD[0].removeElements(a.min[0],a.max[0]);this.axesD[1].removeElements(a.min[1],a.max[1]);this.axesD[2].removeElements(a.min[2],a.max[2]);this.numElementsD-=2;break;case 2:this.axesS[0].removeElements(a.min[0],a.max[0]),this.axesS[1].removeElements(a.min[1],a.max[1]),this.axesS[2].removeElements(a.min[2],a.max[2]),this.numElementsS-=2}a.belongsTo=0}};
OIMO.SAPBroadPhase.prototype.collectPairs=function(){if(0!=this.numElementsD){var a=this.axesD[this.index1],c=this.axesD[this.index2];a.sort();c.sort();var b=a.calculateTestCount(),d=c.calculateTestCount();b<=d?(c=this.axesS[this.index1],c.sort(),b=a.elements,a=c.elements):(a=this.axesS[this.index2],a.sort(),b=c.elements,a=a.elements,this.index1^=this.index2,this.index2^=this.index1,this.index1^=this.index2);for(var e,f,d=c=0;c<this.numElementsD;){var g,h;d==this.numElementsS?(g=b[c],h=!0,c++):(g=
b[c],h=a[d],g.value<h.value?(h=!0,c++):(g=h,h=!1,d++));if(g.max){var k=g.pair;if(h)if(k==e){e=e.pair;continue}else g=e;else if(k==f){f=f.pair;continue}else g=f;do{t=g.pair;if(t==k){g.pair=t.pair;break}g=t}while(null!=g)}else{for(var k=g.proxy.shape,l=g.min1.value,n=g.max1.value,p=g.min2.value,m=g.max2.value,t=e;null!=t;t=t.pair){var r=t.proxy.shape;this.numPairChecks++;l>t.max1.value||n<t.min1.value||p>t.max2.value||m<t.min2.value||!this.isAvailablePair(k,r)||this.addPair(k,r)}if(h){for(t=f;null!=
t;t=t.pair)r=t.proxy.shape,this.numPairChecks++,l>t.max1.value||n<t.min1.value||p>t.max2.value||m<t.min2.value||!this.isAvailablePair(k,r)||this.addPair(k,r);g.pair=e;e=g}else g.pair=f,f=g}}this.index2=(this.index1|this.index2)^3}};OIMO.SAPElement=function(a,c){this.max2=this.min2=this.max1=this.min1=this.pair=null;this.proxy=a;this.max=c;this.value=0};OIMO.SAPProxy=function(a,c){OIMO.Proxy.call(this,c);this.belongsTo=0;this.max=[];this.min=[];this.sap=a;this.min[0]=new OIMO.SAPElement(this,!1);this.max[0]=new OIMO.SAPElement(this,!0);this.min[1]=new OIMO.SAPElement(this,!1);this.max[1]=new OIMO.SAPElement(this,!0);this.min[2]=new OIMO.SAPElement(this,!1);this.max[2]=new OIMO.SAPElement(this,!0);this.max[0].pair=this.min[0];this.max[1].pair=this.min[1];this.max[2].pair=this.min[2];this.min[0].min1=this.min[1];this.min[0].max1=this.max[1];this.min[0].min2=
this.min[2];this.min[0].max2=this.max[2];this.min[1].min1=this.min[0];this.min[1].max1=this.max[0];this.min[1].min2=this.min[2];this.min[1].max2=this.max[2];this.min[2].min1=this.min[0];this.min[2].max1=this.max[0];this.min[2].min2=this.min[1];this.min[2].max2=this.max[1]};OIMO.SAPProxy.prototype=Object.create(OIMO.Proxy.prototype);OIMO.SAPProxy.prototype.isDynamic=function(){var a=this.shape.parent;return a.isDynamic&&!a.sleeping};
OIMO.SAPProxy.prototype.update=function(){this.min[0].value=this.aabb.minX;this.max[0].value=this.aabb.maxX;this.min[1].value=this.aabb.minY;this.max[1].value=this.aabb.maxY;this.min[2].value=this.aabb.minZ;this.max[2].value=this.aabb.maxZ;if(1==this.belongsTo&&!this.isDynamic()||2==this.belongsTo&&this.isDynamic())this.sap.removeProxy(this),this.sap.addProxy(this)};OIMO.DBVT=function(){this.root=null;this.freeNodes=[];this.freeNodes.length=16384;this.numFreeNodes=0;this.aabb=new OIMO.AABB};
OIMO.DBVT.prototype={constructor:OIMO.DBVT,moveLeaf:function(a){this.deleteLeaf(a);this.insertLeaf(a)},insertLeaf:function(a){if(null==this.root)this.root=a;else{for(var c=a.aabb,b=this.root,d,e;null==b.proxy;){var f=b.child1,g=b.child2,h=b.aabb,k=f.aabb,l=g.aabb;d=h.surfaceArea();this.aabb.combine(c,h);e=this.aabb.surfaceArea();h=2*e;d=e=2*(e-d);this.aabb.combine(c,k);d=null!=f.proxy?d+this.aabb.surfaceArea():d+(this.aabb.surfaceArea()-k.surfaceArea());k=e;this.aabb.combine(c,l);k=null!=g.proxy?
k+this.aabb.surfaceArea():k+(this.aabb.surfaceArea()-l.surfaceArea());if(d<k)if(h<d)break;else b=f;else if(h<k)break;else b=g}c=b.parent;f=0<this.numFreeNodes?this.freeNodes[--this.numFreeNodes]:new OIMO.DBVTNode;f.parent=c;f.child1=a;f.child2=b;f.aabb.combine(a.aabb,b.aabb);f.height=b.height+1;b.parent=f;a.parent=f;b==this.root?this.root=f:c.child1==b?c.child1=f:c.child2=f;do f=this.balance(f),this.fix(f),f=f.parent;while(null!=f)}},getBalance:function(a){return null!=a.proxy?0:a.child1.height-a.child2.height},
print:function(a,c,b){var d=null==a.proxy;d&&(b=this.print(a.child1,c+1,b));for(var e=2*c;0<=e;e--)b+=" ";b+=(d?this.getBalance(a):"["+a.proxy.aabb.minX+"]")+"\n";d&&(b=this.print(a.child2,c+1,b));return b},deleteLeaf:function(a){if(a==this.root)this.root=null;else{var c=a.parent;a=c.child1==a?c.child2:c.child1;if(c==this.root)this.root=a,a.parent=null;else{var b=c.parent;a.parent=b;b.child1==c?b.child1=a:b.child2=a;16384>this.numFreeNodes&&(this.freeNodes[this.numFreeNodes++]=c);do b=this.balance(b),
this.fix(b),b=b.parent;while(null!=b)}}},balance:function(a){var c=a.height;if(2>c)return a;var b=a.parent,d=a.child1,e=a.child2,f=d.height,g=e.height,h=f-g;if(1<h){var f=d.child1,h=d.child2,k=f.height,l=h.height;k>l?(d.child2=a,a.parent=d,a.child1=h,h.parent=a,a.aabb.combine(h.aabb,e.aabb),g=l-g,a.height=l-(g&g>>31)+1,d.aabb.combine(f.aabb,a.aabb),g=k-c,d.height=k-(g&g>>31)+1):(d.child1=a,a.parent=d,a.child1=f,f.parent=a,a.aabb.combine(f.aabb,e.aabb),g=k-g,a.height=k-(g&g>>31)+1,d.aabb.combine(a.aabb,
h.aabb),g=c-l,d.height=c-(g&g>>31)+1);null!=b?b.child1==a?b.child1=d:b.child2=d:this.root=d;d.parent=b;return d}if(-1>h){var h=e.child1,k=e.child2,l=h.height,n=k.height;l>n?(e.child2=a,a.parent=e,a.child2=k,k.parent=a,a.aabb.combine(d.aabb,k.aabb),g=f-n,a.height=f-(g&g>>31)+1,e.aabb.combine(h.aabb,a.aabb),g=l-c,e.height=l-(g&g>>31)+1):(e.child1=a,a.parent=e,a.child2=h,h.parent=a,a.aabb.combine(d.aabb,h.aabb),g=f-l,a.height=f-(g&g>>31)+1,e.aabb.combine(a.aabb,k.aabb),g=c-n,e.height=c-(g&g>>31)+1);
null!=b?b.child1==a?b.child1=e:b.child2=e:this.root=e;e.parent=b;return e}return a},fix:function(a){var c=a.child1,b=a.child2;a.aabb.combine(c.aabb,b.aabb);c=c.height;b=b.height;a.height=c<b?b+1:c+1}};OIMO.DBVTBroadPhase=function(){OIMO.BroadPhase.call(this);this.types=3;this.maxLeaves=this.numLeaves=0;this.tree=new OIMO.DBVT;this.maxStack=256;this.stack=[];this.stack.length=this.maxStack;this.maxLeaves=256;this.leaves=[];this.leaves.length=this.maxLeaves};OIMO.DBVTBroadPhase.prototype=Object.create(OIMO.BroadPhase.prototype);OIMO.DBVTBroadPhase.prototype.createProxy=function(a){return new OIMO.DBVTProxy(a)};
OIMO.DBVTBroadPhase.prototype.addProxy=function(a){this.tree.insertLeaf(a.leaf);if(this.numLeaves==this.maxLeaves){this.maxLeaves*=2;var c=[];c.length=this.maxLeaves;for(var b=0;b<this.numLeaves;b++)c[b]=this.leaves[b];this.leaves=c}this.leaves[this.numLeaves++]=a.leaf};OIMO.DBVTBroadPhase.prototype.removeProxy=function(a){this.tree.deleteLeaf(a.leaf);for(var c=0;c<this.numLeaves;c++)if(this.leaves[c]==a.leaf){this.leaves[c]=this.leaves[--this.numLeaves];this.leaves[this.numLeaves]=null;break}};
OIMO.DBVTBroadPhase.prototype.collectPairs=function(){if(!(2>this.numLeaves))for(var a=0;a<this.numLeaves;a++){var c=this.leaves[a],b=c.proxy.aabb,d=c.aabb;if(b.minX<d.minX||b.maxX>d.maxX||b.minY<d.minY||b.maxY>d.maxY||b.minZ<d.minZ||b.maxZ>d.maxZ)this.tree.deleteLeaf(c),d.minX=b.minX-0.1,d.maxX=b.maxX+0.1,d.minY=b.minY-0.1,d.maxY=b.maxY+0.1,d.minZ=b.minZ-0.1,d.maxZ=b.maxZ+0.1,this.tree.insertLeaf(c),this.collide(c,this.tree.root)}};
OIMO.DBVTBroadPhase.prototype.collide=function(a,c){var b=2;this.stack[0]=a;for(this.stack[1]=c;0<b;){var d=this.stack[--b],e=this.stack[--b],f=null!=d.proxy,g=null!=e.proxy;this.numPairChecks++;if(f&&g){var d=d.proxy.shape,e=e.proxy.shape,h=d.aabb,k=e.aabb;d==e||h.maxX<k.minX||h.minX>k.maxX||h.maxY<k.minY||h.minY>k.maxY||h.maxZ<k.minZ||h.minZ>k.maxZ||!this.isAvailablePair(d,e)||this.addPair(d,e)}else if(h=d.aabb,k=e.aabb,!(h.maxX<k.minX||h.minX>k.maxX||h.maxY<k.minY||h.minY>k.maxY||h.maxZ<k.minZ||
h.minZ>k.maxZ)){if(b+4>=this.maxStack){this.maxStack*=2;h=[];h.length=this.maxStack;for(k=0;k<b;k++)h[k]=this.stack[k];this.stack=h}g||!f&&d.aabb.surfaceArea()>e.aabb.surfaceArea()?(this.stack[b++]=d.child1,this.stack[b++]=e,this.stack[b++]=d.child2,this.stack[b++]=e):(this.stack[b++]=d,this.stack[b++]=e.child1,this.stack[b++]=d,this.stack[b++]=e.child2)}}};OIMO.DBVTNode=function(){this.proxy=this.parent=this.child2=this.child1=null;this.height=0;this.aabb=new OIMO.AABB};OIMO.DBVTProxy=function(a){OIMO.Proxy.call(this,a);this.leaf=new OIMO.DBVTNode;this.leaf.proxy=this};OIMO.DBVTProxy.prototype=Object.create(OIMO.Proxy.prototype);OIMO.DBVTProxy.prototype.update=function(){};

define("OIMO", (function (global) {
    return function () {
        var ret, fn;
        return ret || global.OIMO;
    };
}(this)));

define('worldcup-high/closeData',[],function() {
    return 'data:image/png;base64,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';
});
define('worldcup-high/EntryScene',['require','qtek','./cubeGeo','OIMO','./closeData'],function(require) {

    var qtek = require('qtek');
    var cubeGeo = require('./cubeGeo');
    var OIMO = require('OIMO');

    var closeData = require('./closeData');

    var tipStyle = {
        position: 'fixed',
        bottom: '60px',
        width: '200px',
        cursor: 'pointer',

        fontSize: '14px',
        color: '#666',

        textAlign: 'center',

        zIndex: 10010
    }

    var closeStyle = {
        position: 'absolute',
        right: '10px',
        top: '-20px',

        width: '21px',
        height: '21px',

        backgroundSize: '21px 21px',
        backgroundRepeat: 'no-repeat',

        backgroundImage: 'url(' + closeData +')',

        cursor: 'pointer'
    }

    function EntryScene(renderer, animation, container) {

        this.renderer = renderer;
        this.animation = animation;

        this.container = container;

        this.radius = 7;

        this._cubes = [];

        this.onMouseMove = this.onMouseMove.bind(this);
    }

    EntryScene.prototype.init = function() {

        this.scene = new qtek.Scene();

        this.camera = new qtek.camera.Perspective({
            aspect: this.renderer.canvas.width / this.renderer.canvas.height,
            fov: 30
        });
        this.camera.position.z = 35;

        var light = new qtek.light.Directional({
            intensity: 1
        });
        light.position.set(0, 10, 50);
        light.lookAt(qtek.math.Vector3.ZERO);
        this.scene.add(light);

        this.scene.add(new qtek.light.Ambient({
            intensity: 0.1
        }));

        this._createCubes();

        this.world = new OIMO.World();
        this.world.gravity = new OIMO.Vec3(0, -5, 0);

        var ground = new OIMO.Body({
            size: [100, 40, 100],
            pos: [0, -26, 0],
            world: this.world
        });
    }

    EntryScene.prototype.start = function() {

        var renderer = this.renderer;
        var root = this.root;

        renderer.resize(200, 100);
        renderer.canvas.style.position = 'fixed';
        renderer.canvas.style.bottom = '0px';
        renderer.canvas.style.left = '0px';

        this.camera.aspect = 2;

        var contentRightDom = document.getElementById('content_right');
        var x0; 
        if (contentRightDom) {
            if (contentRightDom.getBoundingClientRect) {
                var bb = contentRightDom.getBoundingClientRect();
                x0 = bb.left - 143;
            }
        }
        if (!x0) {
            x0 = window.innerWidth / 2 - 50;
        }
        var obj = {
            angle : x0 / this.radius / 5,
            x: 0,
            y: 200
        }
        this.animation.animate(obj)
            .when(1300, {
                y: 0
            })
            .during(function() {
                renderer.canvas.style.bottom = obj.y + 'px';
            })
            .start('BounceOut');

        this.animation.animate(obj)
            .when(1300, {
                x: x0
            })
            .during(function() {
                renderer.canvas.style.left = obj.x + "px";
            })
            .start();

        root.rotation.rotateZ(obj.angle);

        this.animation.animate(obj)
            .when(1300, {
                angle: 0
            })
            .during(function() {
                root.rotation.identity();
                root.rotation.rotateZ(obj.angle);
            })
            .done(this._enablePhysics.bind(this))
            .start('QuadraticOut');
    }

    EntryScene.prototype.stop = function() {
        this.animation.off('frame', this.updatePhysics);
        document.body.removeEventListener('mousemove', this.onMouseMove);
    }

    EntryScene.prototype.frame = function() {
        if (!this.scene) {
            return;
        }
        this.renderer.render(this.scene, this.camera);
    }

    EntryScene.prototype.dispose = function() {
        this.stop();
        if (this.scene) {
            this.renderer.disposeScene(this.scene);
        }
        this.scene = null;
        this.camera = null;

        this.world = null;

        if (this._tipDom) {
            this._tipDom.parentNode.removeChild(this._tipDom);
            this._tipDom = null;
        }
    }

    EntryScene.prototype._createCubes = function() {

        var geo = cubeGeo.get();
        var shader = qtek.shader.library.get('buildin.physical');

        var root = new qtek.Node();
        this.scene.add(root);

        this.root = root;

        var R = this.radius;

        var segTheta = 8;
        var white = [1, 1, 1];
        var black = [0, 0, 0]
        for (var k = 0; k <= segTheta; k++) {
            var theta = (k - segTheta / 2) * Math.PI / segTheta;

            var r0 = Math.cos(theta) * R;
            var perimeter = r0 * Math.PI * 2;

            var steps = perimeter / (R * 2 * Math.PI / 16);
            for (var i = 0; i <= steps; i ++) {

                if (steps == 0) {
                    var phi = 0;
                } else {
                    var phi = i / steps * Math.PI * 2;
                }

                var scale = 1.5;
                var x = Math.cos(phi) * Math.cos(theta) * (R - scale / 2);
                var y = Math.sin(theta) * (R - scale / 2);
                var z = Math.sin(phi) * Math.cos(theta) * (R - scale / 2);

                var material = new qtek.Material({
                    shader: shader
                });
                material.set('glossiness', 0.6);
                material.set('specularColor', [0.2, 0.2, 0.2]);
                material.set('color', k % 2 ? white: (i % 2 == 0 ? black: white));

                var cube = new qtek.Mesh({
                    geometry: geo,
                    material: material
                });

                cube.position.set(x, y, z);

                cube.rotation.rotateY(-phi);
                cube.rotation.rotateZ(theta);
                cube.scale.set(scale, scale, scale);

                root.add(cube);

                this._cubes.push(cube);
            }
        }
    }

    EntryScene.prototype._enablePhysics = function() {

        var self = this;

        var count = this._cubes.length;

        this.camera.position.y = 5;
        this.camera.lookAt(qtek.math.Vector3.ZERO);

        for (var i = 0; i < count; i++) {
            var child = this._cubes[i];
            var body = new OIMO.Body({
                type: 'box',
                size: [child.scale.x, child.scale.y, child.scale.z],
                pos: [child.position.x, child.position.y, child.position.z],
                move: true,
                world: this.world
            });

            child._body = body;
        }

        this.animation.on('frame', this.updatePhysics, this);

        document.body.addEventListener('mousemove', this.onMouseMove);

        ////////////////  Show tip and close button
        var tipDom = document.createElement('div');
        tipDom.innerHTML = '';
        tipDom.className = 'OP_LOG_BTN';
        tipDom.id = 'worldcup-fx-webgl-tip';
        tipDom.style.left = this.renderer.canvas.style.left;

        qtek.core.util.extend(tipDom.style, tipStyle);
        this.container.appendChild(tipDom);

        var closeDom = document.createElement('div');
        closeDom.className = 'OP_LOG_BTN';
        closeDom.id = 'worldcup-fx-webgl-entry-close';

        qtek.core.util.extend(closeDom.style, closeStyle);
        tipDom.appendChild(closeDom);

        closeDom.addEventListener('click', function() {
            self.trigger('close');
        });

        this._tipDom = tipDom;

        function enter(e) {
            if (e.target != closeDom) {
                self.trigger('enter');
                self.renderer.canvas.removeEventListener('click', enter);
                self.renderer.canvas.style.cursor = 'default';
            }
        }

        tipDom.addEventListener('click', enter);
        this.renderer.canvas.addEventListener('click', enter);
        this.renderer.canvas.style.cursor = 'pointer';

        // Change position to percent
        this.renderer.canvas.style.left = Math.round(parseInt(this.renderer.canvas.style.left) / window.innerWidth * 100) + '%';
        this._tipDom.style.left = Math.round(parseInt(this._tipDom.style.left) / window.innerWidth * 100) + '%';
    }

    EntryScene.prototype.updatePhysics = function() {

        var noScale = new qtek.math.Vector3();

        this.world.step();

        var count = this._cubes.length;
        for (var i = 0; i < count; i++) {
            var cube = this._cubes[i];
            if (cube._body.body.sleeping) {
                continue;
            }
            var m = cube._body.body.getMatrix();

            for (var j = 0; j < 16; j++) {
                cube.worldTransform._array[j] = m[j];
            }
            cube.worldTransform.decomposeMatrix(noScale, cube.rotation, cube.position);
        }
    }

    EntryScene.prototype.onMouseMove = function(e) {
        var dx = e.pageX - this.renderer.width / 2;
        this.root.rotation.identity().rotateY(dx / 200);
    }

    qtek.core.util.extend(EntryScene.prototype, qtek.core.mixin.notifier);

    return EntryScene;
});
/**
 * @license RequireJS text 2.0.5 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/requirejs/text for details
 */
/*jslint regexp: true */
/*global require: false, XMLHttpRequest: false, ActiveXObject: false,
  define: false, window: false, process: false, Packages: false,
  java: false, location: false */

define('text',['module'], function (module) {
    
    
    var text, fs,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
        bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
        hasLocation = typeof location !== 'undefined' && location.href,
        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
        defaultHostName = hasLocation && location.hostname,
        defaultPort = hasLocation && (location.port || undefined),
        buildMap = [],
        masterConfig = (module.config && module.config()) || {};

    text = {
        version: '2.0.5',

        strip: function (content) {
            //Strips <?xml ...?> declarations so that external SVG and XML
            //documents can be added to a document without worry. Also, if the string
            //is an HTML document, only the part inside the body tag is returned.
            if (content) {
                content = content.replace(xmlRegExp, "");
                var matches = content.match(bodyRegExp);
                if (matches) {
                    content = matches[1];
                }
            } else {
                content = "";
            }
            return content;
        },

        jsEscape: function (content) {
            return content.replace(/(['\\])/g, '\\$1')
                .replace(/[\f]/g, "\\f")
                .replace(/[\b]/g, "\\b")
                .replace(/[\n]/g, "\\n")
                .replace(/[\t]/g, "\\t")
                .replace(/[\r]/g, "\\r")
                .replace(/[\u2028]/g, "\\u2028")
                .replace(/[\u2029]/g, "\\u2029");
        },

        createXhr: masterConfig.createXhr || function () {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else if (typeof ActiveXObject !== "undefined") {
                for (i = 0; i < 3; i += 1) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) {}

                    if (xhr) {
                        progIds = [progId];  // so faster next time
                        break;
                    }
                }
            }

            return xhr;
        },

        /**
         * Parses a resource name into its component parts. Resource names
         * look like: module/name.ext!strip, where the !strip part is
         * optional.
         * @param {String} name the resource name
         * @returns {Object} with properties "moduleName", "ext" and "strip"
         * where strip is a boolean.
         */
        parseName: function (name) {
            var modName, ext, temp,
                strip = false,
                index = name.indexOf("."),
                isRelative = name.indexOf('./') === 0 ||
                             name.indexOf('../') === 0;

            if (index !== -1 && (!isRelative || index > 1)) {
                modName = name.substring(0, index);
                ext = name.substring(index + 1, name.length);
            } else {
                modName = name;
            }

            temp = ext || modName;
            index = temp.indexOf("!");
            if (index !== -1) {
                //Pull off the strip arg.
                strip = temp.substring(index + 1) === "strip";
                temp = temp.substring(0, index);
                if (ext) {
                    ext = temp;
                } else {
                    modName = temp;
                }
            }

            return {
                moduleName: modName,
                ext: ext,
                strip: strip
            };
        },

        xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,

        /**
         * Is an URL on another domain. Only works for browser use, returns
         * false in non-browser environments. Only used to know if an
         * optimized .js version of a text resource should be loaded
         * instead.
         * @param {String} url
         * @returns Boolean
         */
        useXhr: function (url, protocol, hostname, port) {
            var uProtocol, uHostName, uPort,
                match = text.xdRegExp.exec(url);
            if (!match) {
                return true;
            }
            uProtocol = match[2];
            uHostName = match[3];

            uHostName = uHostName.split(':');
            uPort = uHostName[1];
            uHostName = uHostName[0];

            return (!uProtocol || uProtocol === protocol) &&
                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
                   ((!uPort && !uHostName) || uPort === port);
        },

        finishLoad: function (name, strip, content, onLoad) {
            content = strip ? text.strip(content) : content;
            if (masterConfig.isBuild) {
                buildMap[name] = content;
            }
            onLoad(content);
        },

        load: function (name, req, onLoad, config) {
            //Name has format: some.module.filext!strip
            //The strip part is optional.
            //if strip is present, then that means only get the string contents
            //inside a body tag in an HTML string. For XML/SVG content it means
            //removing the <?xml ...?> declarations so the content can be inserted
            //into the current doc without problems.

            // Do not bother with the work if a build and text will
            // not be inlined.
            if (config.isBuild && !config.inlineText) {
                onLoad();
                return;
            }

            masterConfig.isBuild = config.isBuild;

            var parsed = text.parseName(name),
                nonStripName = parsed.moduleName +
                    (parsed.ext ? '.' + parsed.ext : ''),
                url = req.toUrl(nonStripName),
                useXhr = (masterConfig.useXhr) ||
                         text.useXhr;

            //Load the text. Use XHR if possible and in a browser.
            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
                text.get(url, function (content) {
                    text.finishLoad(name, parsed.strip, content, onLoad);
                }, function (err) {
                    if (onLoad.error) {
                        onLoad.error(err);
                    }
                });
            } else {
                //Need to fetch the resource across domains. Assume
                //the resource has been optimized into a JS module. Fetch
                //by the module name + extension, but do not include the
                //!strip part to avoid file system issues.
                req([nonStripName], function (content) {
                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,
                                    parsed.strip, content, onLoad);
                });
            }
        },

        write: function (pluginName, moduleName, write, config) {
            if (buildMap.hasOwnProperty(moduleName)) {
                var content = text.jsEscape(buildMap[moduleName]);
                write.asModule(pluginName + "!" + moduleName,
                               "define(function () { return '" +
                                   content +
                               "';});\n");
            }
        },

        writeFile: function (pluginName, moduleName, req, write, config) {
            var parsed = text.parseName(moduleName),
                extPart = parsed.ext ? '.' + parsed.ext : '',
                nonStripName = parsed.moduleName + extPart,
                //Use a '.js' file name so that it indicates it is a
                //script that can be loaded across domains.
                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';

            //Leverage own load() method to load plugin value, but only
            //write out values that do not have the strip argument,
            //to avoid any potential issues with ! in file names.
            text.load(nonStripName, req, function (value) {
                //Use own write() method to construct full module value.
                //But need to create shell that translates writeFile's
                //write() to the right interface.
                var textWrite = function (contents) {
                    return write(fileName, contents);
                };
                textWrite.asModule = function (moduleName, contents) {
                    return write.asModule(moduleName, fileName, contents);
                };

                text.write(pluginName, nonStripName, textWrite, config);
            }, config);
        }
    };

    if (masterConfig.env === 'node' || (!masterConfig.env &&
            typeof process !== "undefined" &&
            process.versions &&
            !!process.versions.node)) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');

        text.get = function (url, callback) {
            var file = fs.readFileSync(url, 'utf8');
            //Remove BOM (Byte Mark Order) from utf8 files if it is there.
            if (file.indexOf('\uFEFF') === 0) {
                file = file.substring(1);
            }
            callback(file);
        };
    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&
            text.createXhr())) {
        text.get = function (url, callback, errback, headers) {
            var xhr = text.createXhr(), header;
            xhr.open('GET', url, true);

            //Allow plugins direct access to xhr headers
            if (headers) {
                for (header in headers) {
                    if (headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);
                    }
                }
            }

            //Allow overrides specified in config
            if (masterConfig.onXhr) {
                masterConfig.onXhr(xhr, url);
            }

            xhr.onreadystatechange = function (evt) {
                var status, err;
                //Do not explicitly handle errors, those should be
                //visible via console output in the browser.
                if (xhr.readyState === 4) {
                    status = xhr.status;
                    if (status > 399 && status < 600) {
                        //An http 4xx or 5xx error. Signal an error.
                        err = new Error(url + ' HTTP status: ' + status);
                        err.xhr = xhr;
                        errback(err);
                    } else {
                        callback(xhr.responseText);
                    }
                }
            };
            xhr.send(null);
        };
    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&
            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {
        //Why Java, why is this so awkward?
        text.get = function (url, callback) {
            var stringBuffer, line,
                encoding = "utf-8",
                file = new java.io.File(url),
                lineSeparator = java.lang.System.getProperty("line.separator"),
                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
                content = '';
            try {
                stringBuffer = new java.lang.StringBuffer();
                line = input.readLine();

                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
                // http://www.unicode.org/faq/utf_bom.html

                // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
                if (line && line.length() && line.charAt(0) === 0xfeff) {
                    // Eat the BOM, since we've already found the encoding on this file,
                    // and we plan to concatenating this buffer with others; the BOM should
                    // only appear at the top of a file.
                    line = line.substring(1);
                }

                stringBuffer.append(line);

                while ((line = input.readLine()) !== null) {
                    stringBuffer.append(lineSeparator);
                    stringBuffer.append(line);
                }
                //Make sure we return a JavaScript string and not a Java string.
                content = String(stringBuffer.toString()); //String
            } finally {
                input.close();
            }
            callback(content);
        };
    }

    return text;
});

define('worldcup-high/instanced_standard.essl',[],function () { return '@export instanced_standard.vertex\n\nuniform mat4 view: VIEW;\nuniform mat4 projection: PROJECTION;\n\nuniform vec2 uvRepeat : [1.0, 1.0];\n\nattribute vec3 position : POSITION;\nattribute vec2 texcoord : TEXCOORD_0;\nattribute vec3 normal : NORMAL;\nattribute vec4 tangent : TANGENT;\n\nattribute float meshIndex;\n\n#ifdef INSTANCING_NUMBER\n    uniform mat4 meshMatrix[INSTANCING_NUMBER];\n    uniform mat3 meshNormalMatrix[INSTANCING_NUMBER];\n    uniform vec3 meshColor[INSTANCING_NUMBER];\n#endif\n\nvarying vec2 v_Texcoord;\nvarying vec3 v_Normal;\nvarying vec3 v_WorldPosition;\n\n#ifdef NORMALMAP_ENABLED\nvarying vec3 v_Tangent;\nvarying vec3 v_Bitangent;\n#endif\n\nvarying vec3 v_Color;\n\nvoid main()\n{\n    mat4 world;\n    mat3 normalMatrix;\n\n    #ifdef INSTANCING_NUMBER\n        int iMeshIndex = int(meshIndex);\n        v_Color = meshColor[iMeshIndex];\n        world = meshMatrix[iMeshIndex];\n        normalMatrix = meshNormalMatrix[iMeshIndex];\n    #endif\n\n    mat4 worldViewProjection = projection * view * world;\n\n    gl_Position = worldViewProjection * vec4(position, 1.0);\n\n    v_Texcoord = texcoord * uvRepeat;\n    v_WorldPosition = (world * vec4(position, 1.0)).xyz;\n\n    v_Normal = normalize(normalMatrix * normal);\n    \n    #ifdef NORMALMAP_ENABLED\n        v_Tangent = normalize(normalMatrix * tangent.xyz);\n        v_Bitangent = normalize(cross(v_Normal, v_Tangent) * tangent.w);\n    #endif\n}\n\n@end\n\n\n@export instanced_standard.fragment\n\n#define PI 3.14159265358979\n\nuniform mat4 viewInverse : VIEWINVERSE;\n\nvarying vec2 v_Texcoord;\nvarying vec3 v_Normal;\nvarying vec3 v_WorldPosition;\n\nvarying vec3 v_Color;\n\n#ifdef NORMALMAP_ENABLED\nvarying vec3 v_Tangent;\nvarying vec3 v_Bitangent;\n#endif\n\nuniform sampler2D diffuseMap;\nuniform sampler2D normalMap;\nuniform samplerCube environmentMap;\n\nuniform float alpha : 1.0;\n\nuniform float glossiness : 0.5;\n\nuniform vec3 specularColor : [0.1, 0.1, 0.1];\nuniform vec3 emission : [0.0, 0.0, 0.0];\n\n#ifdef AMBIENT_LIGHT_NUMBER\n@import buildin.header.ambient_light\n#endif\n#ifdef POINT_LIGHT_NUMBER\n@import buildin.header.point_light\n#endif\n#ifdef DIRECTIONAL_LIGHT_NUMBER\n@import buildin.header.directional_light\n#endif\n#ifdef SPOT_LIGHT_NUMBER\n@import buildin.header.spot_light\n#endif\n\n// Import util functions and uniforms needed\n@import buildin.util.calculate_attenuation\n\n@import buildin.plugin.compute_shadow_map\n\n\nfloat G_Smith(float glossiness, float ndv, float ndl)\n{\n    // float k = (roughness+1.0) * (roughness+1.0) * 0.125;\n    float roughness = 1.0 - glossiness;\n    float k = roughness * roughness / 2.0;\n    float G1V = ndv / (ndv * (1.0 - k) + k);\n    float G1L = ndl / (ndl * (1.0 - k) + k);\n    return G1L * G1V;\n}\n\nvec3 F_Schlick(float ldn) {\n    return specularColor + (1.0 - specularColor) * pow(1.0 - ldn, 5.0);\n}\n\nfloat D_Phong(float g, float ndh) {\n    // from black ops 2\n    float a = pow(8192.0, g);\n    return (a + 2.0) / 8.0 * pow(ndh, a);\n}\n\nfloat D_GGX(float g, float ndh) {\n    float r = 1.0 - g;\n    float a = r * r;\n    float tmp = ndh * ndh * (a - 1.0) + 1.0;\n    return a / (PI * tmp * tmp);\n}\n\nvoid main()\n{\n    #ifdef RENDER_TEXCOORD\n        gl_FragColor = vec4(v_Texcoord, 1.0, 1.0);\n        return;\n    #endif\n\n    vec4 finalColor = vec4(v_Color, alpha);\n\n    vec3 eyePos = viewInverse[3].xyz;\n    vec3 V = normalize(eyePos - v_WorldPosition);\n    float g = glossiness;\n\n    #ifdef DIFFUSEMAP_ENABLED\n        vec4 tex = texture2D(diffuseMap, v_Texcoord);\n        #ifdef SRGB_DECODE\n            tex.rgb = pow(tex.rgb, vec3(2.2));\n        #endif\n        finalColor.rgb *= tex.rgb;\n        #ifdef DIFFUSEMAP_ALPHA_ALPHA\n            finalColor.a *= tex.a;\n        #endif\n        #ifdef DIFFUSEMAP_ALPHA_GLOSS\n            g *= tex.a;\n        #endif\n    #endif\n\n    vec3 N = v_Normal;\n    #ifdef NORMALMAP_ENABLED\n        N = texture2D(normalMap, v_Texcoord).xyz * 2.0 - 1.0;\n        mat3 tbn = mat3(v_Tangent, v_Bitangent, v_Normal);\n        N = normalize(tbn * N);\n    #endif\n\n    #ifdef RENDER_NORMAL\n        gl_FragColor = vec4(N, 1.0);\n        return;\n    #endif\n\n    #ifdef RENDER_GLOSSINESS\n        gl_FragColor = vec4(vec3(g), 1.0);\n        return;\n    #endif\n\n    float ndv = dot(N, V);\n\n    // Diffuse part of all lights\n    vec3 diffuseTerm = vec3(0.0, 0.0, 0.0);\n    // Specular part of all lights\n    vec3 specularTerm = vec3(0.0, 0.0, 0.0);\n    \n    #ifdef AMBIENT_LIGHT_NUMBER\n        for(int i = 0; i < AMBIENT_LIGHT_NUMBER; i++)\n        {\n            // Hemisphere ambient lighting from cryengine\n            diffuseTerm += ambientLightColor[i] * (clamp(N.y * 0.7, 0.0, 1.0) + 0.3);\n            // diffuseTerm += ambientLightColor[i];\n        }\n    #endif\n    #ifdef POINT_LIGHT_NUMBER\n        #if defined(POINT_LIGHT_SHADOWMAP_NUMBER)\n            float shadowContribs[POINT_LIGHT_NUMBER];\n            if(shadowEnabled)\n            {\n                computeShadowOfPointLights(v_WorldPosition, shadowContribs);\n            }\n        #endif\n        for(int i = 0; i < POINT_LIGHT_NUMBER; i++)\n        {\n\n            vec3 lightPosition = pointLightPosition[i];\n            vec3 lc = pointLightColor[i];\n            float range = pointLightRange[i];\n\n            vec3 L = lightPosition - v_WorldPosition;\n\n            // Calculate point light attenuation\n            float dist = length(L);\n            float attenuation = lightAttenuation(dist, range); \n            L /= dist;\n            vec3 H = normalize(L + V);\n            float ndl = clamp(dot(N, L), 0.0, 1.0);\n            float ndh = clamp(dot(N, H), 0.0, 1.0);\n            float ldn = clamp(dot(L, N), 0.0, 1.0);\n\n            float shadowContrib = 1.0;\n            #if defined(POINT_LIGHT_SHADOWMAP_NUMBER)\n                if(shadowEnabled)\n                {\n                    shadowContrib = shadowContribs[i];\n                }\n            #endif\n\n            vec3 li = lc * ndl * attenuation * shadowContrib;\n            diffuseTerm += li;\n            specularTerm += li * F_Schlick(ldn) * D_Phong(g, ndh);\n        }\n    #endif\n\n    #ifdef DIRECTIONAL_LIGHT_NUMBER\n        #if defined(DIRECTIONAL_LIGHT_SHADOWMAP_NUMBER)\n            float shadowContribs[DIRECTIONAL_LIGHT_NUMBER];\n            if(shadowEnabled)\n            {\n                computeShadowOfDirectionalLights(v_WorldPosition, shadowContribs);\n            }\n        #endif\n        for(int i = 0; i < DIRECTIONAL_LIGHT_NUMBER; i++)\n        {\n\n            vec3 L = -normalize(directionalLightDirection[i]);\n            vec3 lc = directionalLightColor[i];\n\n            vec3 H = normalize(L + V);\n            float ndl = clamp(dot(N, L), 0.0, 1.0);\n            float ndh = clamp(dot(N, H), 0.0, 1.0);\n            float ldn = clamp(dot(L, N), 0.0, 1.0);\n\n            float shadowContrib = 1.0;\n            #if defined(DIRECTIONAL_LIGHT_SHADOWMAP_NUMBER)\n                if(shadowEnabled)\n                {\n                    shadowContrib = shadowContribs[i];\n                }\n            #endif\n\n            vec3 li = lc * ndl * shadowContrib;\n\n            diffuseTerm += li;\n            specularTerm += li * F_Schlick(ldn) * D_Phong(g, ndh);\n        }\n    #endif\n\n    #ifdef SPOT_LIGHT_NUMBER\n        #if defined(SPOT_LIGHT_SHADOWMAP_NUMBER)\n            float shadowContribs[SPOT_LIGHT_NUMBER];\n            if(shadowEnabled)\n            {\n                computeShadowOfSpotLights(v_WorldPosition, shadowContribs);\n            }\n        #endif\n        for(int i = 0; i < SPOT_LIGHT_NUMBER; i++)\n        {\n            vec3 lightPosition = spotLightPosition[i];\n            vec3 spotLightDirection = -normalize(spotLightDirection[i]);\n            vec3 lc = spotLightColor[i];\n            float range = spotLightRange[i];\n            float a = spotLightUmbraAngleCosine[i];\n            float b = spotLightPenumbraAngleCosine[i];\n            float falloffFactor = spotLightFalloffFactor[i];\n\n            vec3 L = lightPosition - v_WorldPosition;\n            // Calculate attenuation\n            float dist = length(L);\n            float attenuation = lightAttenuation(dist, range); \n\n            // Normalize light direction\n            L /= dist;\n            // Calculate spot light fall off\n            float c = dot(spotLightDirection, L);\n\n            float falloff;\n            // Fomular from real-time-rendering\n            falloff = clamp((c - a) /( b - a), 0.0, 1.0);\n            falloff = pow(falloff, falloffFactor);\n\n            vec3 H = normalize(L + V);\n            float ndl = clamp(dot(N, L), 0.0, 1.0);\n            float ndh = clamp(dot(N, H), 0.0, 1.0);\n            float ldn = clamp(dot(L, N), 0.0, 1.0);\n\n            float shadowContrib = 1.0;\n            #if defined(SPOT_LIGHT_SHADOWMAP_NUMBER)\n                if (shadowEnabled)\n                {\n                    shadowContrib = shadowContribs[i];\n                }\n            #endif\n\n            vec3 li = lc * attenuation * (1.0-falloff) * shadowContrib * ndl;\n\n            diffuseTerm += li;\n            specularTerm += li * F_Schlick(ldn) * D_Phong(g, ndh);\n        }\n    #endif\n\n    finalColor.rgb *= diffuseTerm;\n    finalColor.rgb += specularTerm;\n    finalColor.rgb += emission;\n\n    #ifdef ENVIRONMENTMAP_ENABLED\n        vec3 envTex = textureCube(environmentMap, reflect(-V, N)).xyz;\n        finalColor.rgb = finalColor.rgb + envTex * g;\n    #endif\n\n    #ifdef GAMMA_ENCODE\n        finalColor.rgb = pow(finalColor.rgb, vec3(1 / 2.2));\n    #endif\n    gl_FragColor = finalColor;\n}\n\n@end';});

define('worldcup-high/InstancedMesh',['require','qtek','./instanced_standard.essl'],function(require) {

    var qtek = require('qtek');

    var Renderable = qtek.Renderable;
    var StaticGeometry = qtek.StaticGeometry;
    var Shader = qtek.Shader;
    var Material = qtek.Material;
    var meshUtil = qtek.util.mesh;
    var Matrix4 = qtek.math.Matrix4;
    var Matrix3 = qtek.math.Matrix3;

    Shader['import'](require('./instanced_standard.essl'));

    var shaderCache = {};

    var normalMatrix = new Matrix3();
    var tmpMat4 = new Matrix4();

    var InstancedMesh = Renderable.derive({

        _instancedMeshMatrices : null,

        _normalInView: false,

        _camera: null

    }, function() {

        this._meshes = [];

        if (!this.material) {
            this.material = new Material();
        }
    }, {

        addMesh: function(mesh) {
            this._meshes.push(mesh);
        },
        
        removeMesh: function(mesh) {
            this._meshes.splice(this._meshes.indexOf(mesh), 1);
        },

        instancing: function(options) {
            options = options || {};
            var len = this._meshes.length;
            if (options.normalInView && options.camera) {
                this._normalInView = true;

                this._camera = options.camera;
            }
            if (!shaderCache[len]) {
                shaderCache[len] = new Shader({
                    vertex: options.vertexShader || Shader.source('instanced_standard.vertex'),
                    fragment: options.fragmentShader || Shader.source('instanced_standard.fragment')
                });
                shaderCache[len].define('vertex', 'INSTANCING_NUMBER', len);
            }
            var shader = shaderCache[len];
            if (this.material.shader !== shader) {
                this.material.attachShader(shader);
            }
            var sampleGeometry = this._meshes[0].geometry;
            for (var i = 0; i < this._meshes.length; i++) {
                if (this._meshes[i].geometry !== sampleGeometry) {
                    throw new Error('Geometry of instanced meshes must be the same');
                }
            }

            for (var i = 0; i < this._meshes.length; i++) {
                var mesh = this._meshes[i];
                var geo = mesh.geometry;
                var nVertex = geo.getVertexNumber();

                // Make sure the vertices will not be affected by the transform when merging
                qtek.math.Matrix4.identity(mesh.localTransform);

                // Make mesh not renderable
                mesh.visible = false;
            }

            var result = meshUtil.merge(this._meshes, false);

            this.geometry = result.geometry;

            var nMeshVertex = sampleGeometry.getVertexNumber();
            var nVertex = nMeshVertex * this._meshes.length;

            this.geometry.createAttribute('meshIndex', 'float', 1);
            this.geometry.attributes.meshIndex.init(nVertex);

            var off = 0;
            for (var i = 0; i < this._meshes.length; i++) {
                for (var k = 0; k < nMeshVertex; k++) {
                    this.geometry.attributes.meshIndex.value[off++] = i;
                }
            }
        },

        render: function(gl, globalMaterial) {
            var len = this._meshes.length;
            var uniforms = this.material.uniforms;
            var meshMatrix = uniforms.meshMatrix.value;
            var meshNormalMatrix = uniforms.meshNormalMatrix.value;
            var meshColor = uniforms.meshColor.value;
            if (!meshMatrix || meshMatrix.length !== len * 16) {
                meshMatrix = uniforms.meshMatrix.value = new Float32Array(len * 16);
            }
            if (!meshNormalMatrix || meshNormalMatrix.length !== len * 9) {
                meshNormalMatrix = uniforms.meshNormalMatrix.value = new Float32Array(len * 9);
            }
            if (!meshColor || meshColor.length !== len * 3) {
                meshColor = uniforms.meshColor.value = new Float32Array(len * 3);
            }

            for (var i = 0; i < len; i++) {
                var mesh = this._meshes[i];
                if (this._normalInView) {
                    Matrix4.multiply(tmpMat4, this._camera.viewMatrix, mesh.worldTransform);
                    Matrix4.invert(tmpMat4, tmpMat4);
                } else {
                    Matrix4.invert(tmpMat4, mesh.worldTransform);
                }
                Matrix4.transpose(tmpMat4, tmpMat4);
                Matrix3.fromMat4(normalMatrix, tmpMat4);
                for (var j = 0; j < 16; j++) {
                    meshMatrix[i * 16 + j] = mesh.worldTransform._array[j];
                }
                for (var j = 0; j < 9; j++) {
                    meshNormalMatrix[i * 9 + j] = normalMatrix._array[j];
                }
                for (var j = 0; j < 3; j++) {
                    meshColor[i * 3 + j] = mesh.material.uniforms.color.value[j];
                }
            }

            Renderable.prototype.render.call(this, gl, globalMaterial);
        }
    });

    return InstancedMesh;
});
define('worldcup-high/instancing',['require','./InstancedMesh','qtek'],function(require) {

    var InstancedMesh = require('./InstancedMesh');
    var qtek = require('qtek');

    return function(cubeList, options) {
        if (typeof(options) == 'number') {
            var max = options;
            options = {};
        } else {
            options = options || {};
            var max = options.max || 20;
        }

        var n = 0;
        var res = [];

        if (cubeList.length > max) {
            var count = 0;
            var instancedMesh = new InstancedMesh();
            for (var i = 0; i < max; i++) {
                n++;
                instancedMesh.addMesh(cubeList[i]);
                count++;
            }
            instancedMesh.instancing(options);
            res.push(instancedMesh);

            for (var i = 1; i < Math.floor(cubeList.length / max); i++) {
                var instancedMesh = new InstancedMesh({
                    geometry: instancedMesh.geometry,
                    material: new qtek.Material({
                        shader: instancedMesh.material.shader
                    })
                });
                for (var k = 0; k < max; k++) {
                    instancedMesh.addMesh(cubeList[n++]);
                }
                res.push(instancedMesh);
            }
        }

        if (cubeList.length - 1 > n) {
            var instancedMesh = new InstancedMesh();
            for (var i = n; i < cubeList.length; i++) {
                instancedMesh.addMesh(cubeList[i]);
            }
            instancedMesh.instancing(options);

            res.push(instancedMesh);
        }

        return res;
    }
});
define('worldcup-high/bokeh.essl',[],function () { return '@export bokeh\n\n#define SAMPLES 3\n#define RINGS 3\n\nvarying vec2 v_Texcoord;\n\nuniform sampler2D tColor;\nuniform sampler2D tDepth;\nuniform float textureWidth;\nuniform float textureHeight;\n\nconst float PI = 3.14159265;\n\nfloat width = textureWidth; //texture width\nfloat height = textureHeight; //texture height\n\nvec2 texel = vec2(1.0/width,1.0/height);\n\nuniform float focalDepth: 40;  //focal distance value in meters, but you may use autofocus option below\nuniform float focalLength: 35; //focal length in mm\nuniform float fstop: 2.2; //f-stop value\n\n/*\nmake sure that these two values are the same for your camera, otherwise distances will be wrong.\n*/\n\nuniform float znear: 0.1; // camera clipping start\nuniform float zfar: 2000; // camera clipping end\n\n//------------------------------------------\n//user variables\n\nconst int samples = SAMPLES; //samples on the first ring\nconst int rings = RINGS; //ring count\n\nconst int maxringsamples = rings * samples;\n\nfloat CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)\n\n// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)\n// if center of screen use vec2(0.5, 0.5);\n\nuniform float maxblur: 1.0;\n//clamp value of max blur (0.0 = no blur, 1.0 default)\n\nuniform float threshold: 0.5; // highlight threshold;\nuniform float gain: 2.0; // highlight gain;\n\nuniform float bias: 0.5; // bokeh edge bias\nuniform float fringe: 0.7; // bokeh chromatic aberration / fringing\n\nuniform float dithering: 0.0001;\n\nconst vec3 lumcoeff = vec3(0.299,0.587,0.114);\n\nvec3 color(vec2 coords,float blur) {\n    //processing the sample\n\n    vec3 col = vec3(0.0);\n\n    col.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;\n    col.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;\n    col.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;\n\n    float lum = dot(col.rgb, lumcoeff);\n    float thresh = max((lum-threshold)*gain, 0.0);\n    return col+mix(vec3(0.0),col,thresh*blur);\n}\n\nvec2 rand(vec2 coord) {\n    // generating noise / pattern texture for dithering\n\n    float noiseX = ((fract(1.0-coord.s*(width/2.0))*0.25)+(fract(coord.t*(height/2.0))*0.75))*2.0-1.0;\n    float noiseY = ((fract(1.0-coord.s*(width/2.0))*0.75)+(fract(coord.t*(height/2.0))*0.25))*2.0-1.0;\n\n    noiseX = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233))) * 43758.5453),0.0,1.0)*2.0-1.0;\n    noiseY = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233)*2.0)) * 43758.5453),0.0,1.0)*2.0-1.0;\n\n    return vec2(noiseX,noiseY);\n}\n\nfloat linearize(float depth) {\n    return -zfar * znear / (depth * (zfar - znear) - zfar);\n}\n\nfloat gather(float i, float j, int ringsamples, inout vec4 col, float w, float h, float blur) {\n    float rings2 = float(rings);\n    float step = PI*2.0 / float(ringsamples);\n    float pw = cos(j*step)*i;\n    float ph = sin(j*step)*i;\n    float p = 1.0;\n\n    // col.rgb += color(v_Texcoord.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;\n    // col.a += texture2D(tColor, v_Texcoord.xy + vec2(pw*w,ph*h) * blur).a * mix(1.0, i/rings2, bias);\n    vec4 tex = texture2D(tColor, v_Texcoord.xy + vec2(pw * w, ph * h) * blur);\n\n    float lum = dot(tex.rgb, lumcoeff);\n    float thresh = max((lum-threshold) * gain, 0.0);\n    tex.rgb += mix(vec3(0.0), tex.rgb, thresh*blur);\n\n    tex *= mix(1.0, i/rings2, bias) * p;\n\n    col.rgb += tex.rgb;\n    col.a += tex.a;\n    \n    return 1.0 * mix(1.0, i /rings2, bias) * p;\n}\n\nvoid main() {\n    //scene depth calculation\n\n    float depth = linearize(texture2D(tDepth,v_Texcoord.xy).x);\n\n    //focal plane calculation\n    float f = focalLength; // focal length in mm\n    float d = focalDepth*1000.0; // focal plane in mm\n    float o = depth*1000.0; // depth in mm\n\n    float a = (o*f)/(o-f);\n    float b = (d*f)/(d-f);\n    float c = (d-f)/(d*fstop*CoC);\n\n    float blur = abs(a-b)*c;\n\n    blur = clamp(blur,0.0,1.0);\n\n    // calculation of pattern for dithering\n\n    vec2 noise = rand(v_Texcoord.xy)*dithering*blur;\n\n    // getting blur x and y step factor\n\n    float w = (1.0/width)*blur*maxblur+noise.x;\n    float h = (1.0/height)*blur*maxblur+noise.y;\n\n    // calculation of final color\n\n    vec4 col = vec4(0.0);\n\n    if(blur < 0.05) {\n        //some optimization thingy\n        col = texture2D(tColor, v_Texcoord.xy);\n    } else {\n        col = texture2D(tColor, v_Texcoord.xy);\n        float s = 1.0;\n        int ringsamples;\n\n        for (int i = 1; i <= rings; i++) {\n            /*unboxstart*/\n            ringsamples = i * samples;\n\n            for (int j = 0 ; j < maxringsamples ; j++) {\n                if (j >= ringsamples) break;\n                s += gather(float(i), float(j), ringsamples, col, w, h, blur);\n            }\n            /*unboxend*/\n        }\n\n        col /= s; //divide by sample count\n    }\n\n    gl_FragColor.rgb = col.rgb;\n    gl_FragColor.a = col.a;\n}\n\n@end';});

define('worldcup-high/bokeh',['require','qtek','./bokeh.essl'],function(require) {

    var qtek = require('qtek');

    qtek.Shader['import'](require('./bokeh.essl'));

    return function (renderer, scene, camera) {
        
        var floatEnabled = qtek.core.glinfo.getExtension(renderer.gl, 'OES_texture_float');
        var depthTextureEnabled = qtek.core.glinfo.getExtension(renderer.gl, 'WEBGL_depth_texture');
        // var depthTextureEnabled = null;

        var compositor = new qtek.compositor.Compositor();
        var sceneNode = new qtek.compositor.SceneNode({
            name: "scene",
            scene: scene,
            camera: camera,
            outputs: {
                color: {
                    parameters: {
                        // Half Float
                        type: floatEnabled ? 36193 : qtek.Texture.UNSIGNED_BYTE,
                        width: function(renderer) {return renderer.width},
                        height: function(renderer) {return renderer.height},
                        minFilter: qtek.Texture.NEAREST,
                        magFilter: qtek.Texture.NEAREST
                    }
                },
                depth: {
                    attachment: 'DEPTH_ATTACHMENT',
                    parameters: {
                        width: function(renderer) {return renderer.width},
                        height: function(renderer) {return renderer.height},
                        type: qtek.Texture.UNSIGNED_SHORT,
                        format: qtek.Texture.DEPTH_COMPONENT,
                        minFilter: qtek.Texture.NEAREST,
                        magFilter: qtek.Texture.NEAREST
                    }
                }
            }
        });

        var bokehNode = new qtek.compositor.Node({
            name: 'bokeh',
            shader: qtek.Shader.source('bokeh'),
            inputs: {
                tColor: {
                    node: sceneNode,
                    pin: 'color'
                },
                tDepth: {
                    node: sceneNode,
                    pin: 'depth'
                }
            }
        });

        // Try compiling shader
        var errMsg = bokehNode.pass.material.shader.bind(renderer.gl);
        if (errMsg || !depthTextureEnabled) {
            compositor.updateParameters = function() {};
            compositor.setFocalPlane = function() {};
            compositor.setFStop = function() {};
            compositor.getLastNode = function() {
                return sceneNode;
            }

            sceneNode.outputs = null;

            compositor.addNode(sceneNode);

        } else {
            compositor.addNode(bokehNode);
            compositor.addNode(sceneNode);

            compositor.updateParameters = function() {
                bokehNode.setParameter('textureWidth', renderer.width);
                bokehNode.setParameter('textureHeight', renderer.height);

                bokehNode.setParameter('znear', camera.near);
                bokehNode.setParameter('zfar', camera.far);
            }

            compositor.setFocalPlane = function(val) {
                bokehNode.setParameter('focalDepth', val);
            }

            compositor.setFStop = function(fstop) {
                bokehNode.setParameter('fstop', fstop);
            }

            compositor.getLastNode = function() {
                return bokehNode;
            }

            bokehNode.setParameter('focalDepth', 30);
            bokehNode.setParameter('fstop', 0.8);
            bokehNode.setParameter('maxBlur', 1.6);
            bokehNode.setParameter('gain', 2);

            camera.fov = 2 * Math.atan(24 / (35 * 2)) / (Math.PI * 2) * 360;
            // bokehNode.setParameter('shaderFocus', true);
        }

        return compositor;
    }

});
define('worldcup-high/mosaic',['require'],function (require) {
    
    var canvas;

    var ctx;

    function mosaic(img, sx, sy, sw, sh, scale, flat) {
        if (!canvas) {
            canvas = document.createElement('canvas');
            ctx = canvas.getContext('2d');
        }
        sx = sx || 0;
        sy = sy ||0;

        sw = sw || img.width;
        sh = sh || img.height;

        scale = scale || 1;
        var tw = Math.round(sw * scale);
        var th = Math.round(sh * scale);

        if (typeof(flat) == 'undefined') {
            flat = true;
        }

        canvas.width = tw;
        canvas.height = th;

        ctx.drawImage(img, sx, sy, sw, sh, 0, 0, tw, th);
        var pixels = ctx.getImageData(0, 0, tw, th).data;

        var positionArr = [];
        var colorArr = [];
        var scaleArr = [];

        for (var i = 0; i < pixels.length;) {
            var idx = i / 4;

            var r = pixels[i++];
            var g = pixels[i++];
            var b = pixels[i++];
            var a = pixels[i++];
            // Transparent pixel
            // TODO threshold
            if (a < 150) {
                continue;
            }

            var x = (idx % tw) / tw * 2 - 1;
            var y = 1 - Math.floor(idx / tw) / th * 2;
            // Scale to fit the aspect
            if (tw < th) {
                x *= tw / th;
            } else {
                y *= th / tw;
            }

            var z = Math.random() * 0.2;

            if (flat) {
                positionArr.push(x);
                positionArr.push(y);
                positionArr.push(z);

                colorArr.push(r);
                colorArr.push(g);
                colorArr.push(b);
            } else {
                var arr = new Float32Array(3);
                arr[0] = x;
                arr[1] = y;
                arr[2] = z;
                positionArr.push(arr);

                arr = new Float32Array(3);
                arr[0] = r;
                arr[1] = g;
                arr[2] = b;
                colorArr.push(arr);
            }
            
            scaleArr.push(a / 255);
        }

        if (flat) {
            positionArr = new Float32Array(positionArr);
            colorArr = new Float32Array(colorArr);
        }
        scaleArr = new Float32Array(scaleArr);
        return {
            position: positionArr,
            color: colorArr,
            scale: scaleArr
        }
    }

    return mosaic;
});
define('worldcup-high/tracksData',{
  "cameras": [
    {
      "position": [
        -29.809999465942383,
        -11.139999389648438,
        1050
      ],
      "target": [
        -33.481990814208984,
        -6.167515754699707,
        843.4835205078125
      ],
      "time": 0,
      "focalPlane": 20,
      "playbackRatio": 0.1,
      "title": "START"
    },
    {
      "position": [
        -35.939998626708984,
        -7.999997615814209,
        798.6199951171875
      ],
      "target": [
        -35.939998626708984,
        -6.989999771118164,
        748.7100219726562
      ],
      "time": 1000,
      "focalPlane": 20,
      "playbackRatio": 1,
      "title": "1934"
    },
    {
      "position": [
        -36.570003509521484,
        -7.000006198883057,
        720.7099609375
      ],
      "target": [
        -36.84000015258789,
        -5.449999809265137,
        671.9600219726562
      ],
      "time": 1700,
      "focalPlane": 20,
      "playbackRatio": 1.1,
      "title": "1938"
    },
    {
      "position": [
        -37.560001373291016,
        -6.900000095367432,
        674.4600219726562
      ],
      "target": [
        -36.560001373291016,
        -6.349999904632568,
        624.8800048828125
      ],
      "time": 2200,
      "focalPlane": 20,
      "playbackRatio": 1.1,
      "title": "1950"
    },
    {
      "position": [
        -39.230003356933594,
        -6.459999084472656,
        604.1699829101562
      ],
      "target": [
        -42.88999938964844,
        -6.400000095367432,
        554.2999877929688
      ],
      "time": 2700,
      "focalPlane": 20,
      "playbackRatio": 1.1,
      "title": "1954"
    },
    {
      "position": [
        -39.20000457763672,
        -5.940000057220459,
        536.6800537109375
      ],
      "target": [
        -37.68000030517578,
        -4.980000019073486,
        488.989990234375
      ],
      "time": 3200,
      "focalPlane": 20,
      "playbackRatio": 1,
      "title": "1958"
    },
    {
      "position": [
        -50.980003356933594,
        -6.529997825622559,
        459.4401550292969
      ],
      "target": [
        -47.4900016784668,
        -8.079999923706055,
        416.5799865722656
      ],
      "time": 3700,
      "focalPlane": 20,
      "playbackRatio": 0.6,
      "title": "1962"
    },
    {
      "position": [
        -70.48999786376953,
        0.6100013852119446,
        417.6600036621094
      ],
      "target": [
        -72.23999786376953,
        -1.75,
        371.1300048828125
      ],
      "time": 4400,
      "focalPlane": 22,
      "playbackRatio": 0.5,
      "title": "1966_2"
    },
    {
      "position": [
        -80.83999633789062,
        3.250002384185791,
        406.73004150390625
      ],
      "target": [
        -83.05000305175781,
        0.5,
        370.8399963378906
      ],
      "time": 4620,
      "focalPlane": 20,
      "playbackRatio": 1,
      "title": "1966_3"
    },
    {
      "position": [
        -113.02999877929688,
        5.149994850158691,
        399.4100036621094
      ],
      "target": [
        -113.53652954101562,
        0.6817731857299805,
        347.6117858886719
      ],
      "time": 5000,
      "focalPlane": 30,
      "playbackRatio": 0.4,
      "title": "1970"
    },
    {
      "position": [
        -120.760009765625,
        -1.1299997568130493,
        350.1700134277344
      ],
      "target": [
        -121.0199966430664,
        -1.5800000429153442,
        302.3999938964844
      ],
      "time": 5500,
      "focalPlane": 20,
      "playbackRatio": 1,
      "title": "1974"
    },
    {
      "position": [
        -120.17999267578125,
        -5.820000171661377,
        272.5100402832031
      ],
      "target": [
        -118.22000122070312,
        -4.130000114440918,
        222.55999755859375
      ],
      "time": 6000,
      "focalPlane": 20,
      "playbackRatio": 1,
      "title": "1978"
    },
    {
      "position": [
        -121.67001342773438,
        1.0000025033950806,
        204.53001403808594
      ],
      "target": [
        -124.93000030517578,
        -1.7799999713897705,
        153.8000030517578
      ],
      "time": 6500,
      "focalPlane": 32,
      "playbackRatio": 1.2,
      "title": "1982"
    },
    {
      "position": [
        -130.86997985839844,
        -3.9999992847442627,
        131.27000427246094
      ],
      "target": [
        -137.03355407714844,
        -5.7953925132751465,
        81.68384552001953
      ],
      "time": 7500,
      "focalPlane": 49,
      "playbackRatio": 0.6,
      "title": "1986_1"
    },
    {
      "position": [
        -143.3211669921875,
        -8.805667877197266,
        42.59990692138672
      ],
      "target": [
        -149.2100067138672,
        -8.569999694824219,
        -5.059999942779541
      ],
      "time": 8000,
      "focalPlane": 34,
      "playbackRatio": 1.2,
      "title": "1990"
    },
    {
      "position": [
        -146.39321899414062,
        -6.2767720222473145,
        -55.69948196411133
      ],
      "target": [
        -150.37725830078125,
        -6.279989719390869,
        -105.5405044555664
      ],
      "time": 8500,
      "focalPlane": 39,
      "playbackRatio": 0.4,
      "title": "1994"
    },
    {
      "position": [
        -163.75997924804688,
        -1.2499998807907104,
        -108.79000091552734
      ],
      "target": [
        -166.5531005859375,
        -1.2041370868682861,
        -157.61117553710938
      ],
      "time": 8800,
      "focalPlane": 43,
      "playbackRatio": 0.2,
      "title": "1998"
    },
    {
      "position": [
        -143.49000549316406,
        0.9199949502944946,
        -209.56002807617188
      ],
      "target": [
        -134.25,
        0.47999998927116394,
        -257.5799865722656
      ],
      "time": 9400,
      "focalPlane": 44,
      "playbackRatio": 1,
      "title": "2002"
    },
    {
      "position": [
        -128.0900115966797,
        -8.000001907348633,
        -309.5199890136719
      ],
      "target": [
        -116.2300033569336,
        -8.390000343322754,
        -363.0899963378906
      ],
      "time": 10000,
      "focalPlane": 41,
      "playbackRatio": 1,
      "title": "2006"
    },
    {
      "position": [
        -91.1100082397461,
        -9.920001029968262,
        -384.9900207519531
      ],
      "target": [
        -74.01902770996094,
        -11.87058162689209,
        -431.9676513671875
      ],
      "time": 10500,
      "focalPlane": 20,
      "playbackRatio": 1,
      "title": "2010"
    },
    {
      "position": [
        -59.116294860839844,
        -6.2231059074401855,
        -427.33709716796875
      ],
      "target": [
        -59.821746826171875,
        -10.304927825927734,
        -477.16552734375
      ],
      "time": 11000,
      "focalPlane": 27,
      "playbackRatio": 0.1,
      "title": "2010_2"
    },
    {
      "position": [
        -58.55990982055664,
        -5.995090484619141,
        -500.0406188964844
      ],
      "target": [
        -58.796600341796875,
        -8.212443351745605,
        -539.9780883789062
      ],
      "time": 11160,
      "focalPlane": 20,
      "playbackRatio": 1,
      "title": "2014_1"
    },
    {
      "position": [
        -65.56366729736328,
        -4.385082721710205,
        -675.0667114257812
      ],
      "target": [
        -64.98773193359375,
        -4.36747407913208,
        -725.0634155273438
      ],
      "time": 11500,
      "focalPlane": 45,
      "playbackRatio": 0.1,
      "title": "2014_2"
    }
  ],
  "players": [
    {
      "position": [
        -19.1299991607666,
        -7,
        800
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 2.5,
      "scale": 1,
      "rotation": 0,
      "title": "1930"
    },
    {
      "position": [
        -43.81999969482422,
        -9,
        817
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 2.6,
      "scale": 0.8,
      "rotation": 0,
      "title": "1930"
    },
    {
      "position": [
        -31.940000534057617,
        -6,
        739.6231689453125
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 1.9,
      "scale": 1,
      "rotation": 0,
      "title": "1934"
    },
    {
      "position": [
        -35.939998626708984,
        -11,
        758.6199951171875
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 3,
      "scale": 0.6,
      "rotation": 0,
      "title": "1934"
    },
    {
      "position": [
        -4.570000171661377,
        -7,
        672.7100219726562
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 2.3,
      "scale": 1,
      "rotation": 0,
      "title": "1938"
    },
    {
      "position": [
        -28.56999969482422,
        -13,
        689.7100219726562
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 3,
      "scale": 0.6,
      "rotation": 0,
      "title": "1938"
    },
    {
      "position": [
        -36.959999084472656,
        -6,
        615.6699829101562
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 2,
      "scale": 1.2,
      "rotation": 0,
      "title": "1950"
    },
    {
      "position": [
        -32.959999084472656,
        -13,
        633.6699829101562
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 3,
      "scale": 0.6,
      "rotation": 0,
      "title": "1950"
    },
    {
      "position": [
        -33,
        -7,
        543.6199951171875
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 2.2,
      "scale": 1,
      "rotation": 0,
      "title": "1954"
    },
    {
      "position": [
        -40,
        -13,
        554.6199951171875
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 3,
      "scale": 0.6,
      "rotation": 0,
      "title": "1954"
    },
    {
      "position": [
        -36.40999984741211,
        -6,
        471.8800048828125
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 2,
      "scale": 1,
      "rotation": 0,
      "title": "1958"
    },
    {
      "position": [
        -38.4900016784668,
        -12,
        488.739990234375
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 3,
      "scale": 0.6,
      "rotation": 0,
      "title": "1958"
    },
    {
      "position": [
        -45.4900016784668,
        -8,
        418.739990234375
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 2,
      "scale": 1,
      "rotation": 0,
      "title": "1962"
    },
    {
      "position": [
        -63.130001068115234,
        -12,
        432.3800048828125
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 3,
      "scale": 0.6,
      "rotation": 0,
      "title": "1962"
    },
    {
      "position": [
        -65.12999725341797,
        -7,
        376.3900146484375
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 2.2,
      "scale": 1,
      "rotation": 0,
      "title": "1966"
    },
    {
      "position": [
        -58.130001068115234,
        -13,
        376.3900146484375
      ],
      "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAKCAYAAADVTVykAAAACXBIWXMAAC4jAAAuIwF4pT92AAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAG8SURBVHjadJS9S5ZhFMZ/moqglBiEKc4tQiEuteTU11BjEEVDDQ1NUUMtEopDuLQkNUVTS5vRfxBBvX2+YC1iKpXxShT2Iam/hs5jx6fHAzfn3Nd1neec5z43N+qA+kB9ot5RKa0zwRX2UB2q0J1Sn6oL6okKHnVcramz6h4V3Gz1UsKFxC2UtH1J15vwt2pXRfGjSXNPbSkaeK1+CuJ+SmhXVwIfC2yX+iWwa0n7OLBXW/z5NnU5Fd/gmoF9wEv+2nf+2U6gLeKp8J+BRsTd4Y8B+yN3AhgE+tlsY0AH8AG4BRwAtgMUndSiu5upu1a1EfhHdTL++mdgh0NXj/0b9VvEq+rF4Heo67FepDE01OGi2HSA46WjO6i+T0lz4X9VzP6KOhF3oLDmaLQoeF69rS4FNovalD58dYv5DajH0/xHgjsd+/Wk708NdKrnIn6eNCc3Oow5d8Sslvnf1oA6cAnoAr4Co8EthW+KewBwJOX+SHEv0BnxcPhF1J7U8eWKE2hVHyXNocS1qe8SN5PiyYoT+R1vQGFnUXerz2JVPSB71fk4whsVfLd6N13AGfV6STOoTqXCtRgNfwYA/mWNZ+FrtsUAAAAASUVORK5CYII=",
      "cubeSize": 3,
      "scale": 0.6,
      "rotation": 0,
      "title": "1966"
    },
    {
      "position": [
        -94.55000305175781,
        0,
        376.3900146484375
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 2.1,
      "scale": 1,
      "rotation": 0,
      "title": "1970"
    },
    {
      "position": [
        -120.11000061035156,
        0,
        377.010009765625
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 3,
      "scale": 0.7,
      "rotation": 0,
      "title": "1970"
    },
    {
      "position": [
        -114.29000091552734,
        -6,
        299.4599914550781
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 2.4,
      "scale": 1,
      "rotation": 0,
      "title": "1974"
    },
    {
      "position": [
        -116.29000091552734,
        -13,
        308.4599914550781
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 3,
      "scale": 0.6,
      "rotation": 0,
      "title": "1974"
    },
    {
      "position": [
        -127.91000366210938,
        -9,
        231.25
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 1.8,
      "scale": 1,
      "rotation": 0,
      "title": "1978"
    },
    {
      "position": [
        -122.91000366210938,
        -13,
        231.25
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 3,
      "scale": 0.6,
      "rotation": 0,
      "title": "1978"
    },
    {
      "position": [
        -115.66999816894531,
        0,
        169.52999877929688
      ],
      "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC8AAAAeCAYAAAC8AUekAAAACXBIWXMAAC4jAAAuIwF4pT92AAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAcQSURBVHja7Jd9bFXlHcc/z3Ne7+1te297W6BFiSBCgYUGhk4hsMkMLy4TNWP8g8kmBFkCyySZM8M4xqbJ5qZzLHNuY6JmDmE6soAwlAlMJzAZ422U0haBttD33rb37ZzzPPujV1ZYS6tONhN+/53nnPOcz/n9vr+XR2it6WvV9Q0MxRSakDCxhYHi33sIIRgxPM6KB1ay7hc/ZWRxGQDnWhuYd/t8/vj6Vjo7EnheFoFAaY1SehzwI2A3cATYful+Rdy96HFqziZ4dM1S2tsSaK2RXCWLWGFO19VQe6oO13VRSuMFCsuUOLb5tNL6TuAHwPK+70khQCuSqTRCiEv2NK8WfKwwxom6Kn6y7ncsWLyc8+fq8XyFbUlunXL9sqJo5G9ZTxUbtpsCIKcIKQ0QEsOUaK3+N/BaKWygO5miPeHR0Z0FBOfbve3xd3b9/ObbKo+lPWdmV2PNeRX4CCnRGiJhE881qa1poGjE9R8YfhSQB9QAmY/6E6YpcWyJYxkADxtO3pyWHjnn+I7fIrW3M93T9R3olYdEY5fm8+TWNqoON/LFSROGDH8HsBa4JXfdDrwIrPwo8EJcTLMvAI+ZKkVneDxV2Rhh1XGPjFvdaI1SivKyYrYcqGbd1mrsQhfB0GSzAHj1ctkCK4DpwNTBIH3fv3zpugCy+YXRpBuOPBoE/irD6P28pZNk7JL1SVHWLdCgwbJN0hmbDdt2EnFAa4PLCmO/1eaGfsD72hRgjUQghUAP8FA0Gu17uVHDGROj/t29O861XqhfFQpH+sbDN3VmlaO6sVUPtu6htNBg3+691B49Qjwe5fKSPhD80kGTD71MIjAQEzX6L8AruVs/1lp/CyC/oBcu8NKf7U6mF55v6yAUihp73tpW8Mun1lBcWkafyvcm0AGglMJ2HLQZpupELUKKgfOnn7UbhyDd0t6fIJyTEcAxYIIQYonWmmQyQ6QgRjYQN4VtzUPLFlMxupyfPb85qBjmG6lEMwoDQQCw4X23OG6IjC8xm/9O3GhHW3n9en0g+KYhpF1CodFwQMIxDROBCaDRSseySvP5e5cQHTuX7p6uiRVqPzMnldKWkqxbvcRoCaLqUHtSmFLn3Kq/opTeWBiLe0WlZTz75FpmxY5RVvwpgt6A9Gv9yeb5IXh+S59gPgd4oEFI3ML4V5tPHiR15hCRaJzR4ysrCsbMoK7uNM0tbTR3pvG6WqQrkkIJM9cD9O3RopL57506zuMPLmLXlucIx4ajpcXAWdU//H7gkSuA9wh4UAFKa0A8AYxCyEOmE6bxyN6K6h0bXk621ld4WMtSHY2VtalhtLgTCOt2LL8TUyURgM7V82hxKdXHD654avX9ow7vexNhGLihyIByuRI8wPeAbwPZy9YPAJOBVnIeyUWg0TDtT3vJxNMXjr6tlV34pZjrHR/bs+MZN0iUgKDeqeQ95xZazDHUubeSkfmYurfn+YGP44RmR4tKT8fiwx4xDBPP9xiE/YqD2WNAObAQuB+4Dbg512n7SQMZBL73dcO2bjRN4w9hv5nyzD+IBmdRQmJojyZ7PLWhGSSM4RfBARJtLUycOoPPzL6L1ubG71qmub0wzx2bSPpkswpjgIoz2FTZAmwC1gN/HayASqGRUHvBHn93rTv95QZnsu42SjB1FoHCVj04qgtLpy9KBsCybRIdrbQ21RMKhclk/TntXemTC2eV1JaXOIuSmeBDwX8gk9rDEyGarHG02mMWVYdmjegyhs2zdOqFK71XEItTV3WYo/v+jOEUkMp4FOSHuPNzRTdMG+u+1NiSflZrnWfbFoZhXMyF//I8L3LtPoWterSjei4Y2tuukfflRov/iBZaEymIcebUMdo7OwiFnHd/+I0FL2ZF6e55Kw80nDwfEIuIpcmOrraaU2df7+rq2WBZ5k1XdSQG1gH5uVx6v0RSVFrG2Zp/8vbOV0n5gikTRoXvvWNq+da91dmRY8c1zl08vSzd0cQrm9+wTdOcnU5lsGzzPmCt+LDHQI0mJCwsIVFoDNsl6G7mxJ7XqBaVYEeQ2kepgMJYCW4ojyDwAW4XQryhgVh8OHu2bWT9E9/EsGycUIRM1uP7K+9h5sQYjWoEh9U08h39G4FenU5nJ2Wz2a8FgbpLCPHxel4IgeOGqTqyn7amBmzHBcQu38s+Y7uhB3wvy/ZNv8LzPAqKSkh0JRk5LEZJLEJLZ5pGP3g47Xi/V6lktZQSIWhQSv9JCDEaaPlY4aU0cNwwOzb9moMHdlIcG9F7eFd6uRBij+9nHyooLJ5cMmIkge+/1tmdeuHLc6fVjbmupLLx3Jm3sDly8cCvLpnla6+C5gUqUEhp4FphbCeUawkSrYKXQkakzQmF56sgaAc2IzhqSInW+h0hhrD7YC34/9kkn2C7Bn8N/hr8J8j+NQCTBv7p7JkqXQAAAABJRU5ErkJggg==",
      "cubeSize": 2.8,
      "scale": 1,
      "rotation": 0,
      "title": "1982"
    },
    {
      "position": [
        -127.66999816894531,
        -5,
        167.52999877929688
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 3,
      "scale": 0.6,
      "rotation": 0,
      "title": "1982"
    },
    {
      "position": [
        -141.27000427246094,
        -3,
        79.66999816894531
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 1.3,
      "scale": 1.5,
      "rotation": 0,
      "title": "1986"
    },
    {
      "position": [
        -136.8699951171875,
        -10,
        104.2300033569336
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 3,
      "scale": 0.5,
      "rotation": 0,
      "title": "1986"
    },
    {
      "position": [
        -141,
        -9,
        4.360000133514404
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 2,
      "scale": 1,
      "rotation": 0,
      "title": "1990"
    },
    {
      "position": [
        -152.1199951171875,
        -13,
        4.364166259765625
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 3,
      "scale": 0.6,
      "rotation": 0,
      "title": "1990"
    },
    {
      "position": [
        -148,
        -7,
        -87.63999938964844
      ],
      "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEcAAAAtCAYAAAD833YjAAAACXBIWXMAAC4jAAAuIwF4pT92AAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAXASURBVHja7Jt7aFNXHMe/v3NPcm8eTWOb2mhrtT66qnRuOMG6odSJOjZmZSriZA/dJrKXwtgGY+zRPypzG+whwkAZc6vMgQ7coCgDnTp1zPrYhm21pY1WW23TmuZ1c+89Z3/0MZtEmPvzxi8knNxc8seH3+t8zw1JKXFP2cXuIbgH53+JZ7v40PqdmReJgTk86DtWB2OgHUz1jXyzAsBTAE4C2AkAHVf77AsnuySIcZDDBSlMEBFMS0ywhKhXHXymlHLFMKBzuZdWUgKMw1VaDRiAaQn0Dca+Y0Qzh4u6D8D+nK05VqIPeeU1kKXzcfV6/+769Utr6p9egs6uMDq7wkgaZjlX2Ku2rjl3lDDRGzNx//xV2xrWFD+/8NEanDnbitdqF8iJBT7a/csZRBL6MgBf5BqcYhB7UeoDm0yvv3RhzQLo165h2oQAPtu6mhDIR28k1vrx/mN1uRY5XwN4FgD8KqHpukTDKcNaN8cwVNPSotdS8BrWUgkcBuVWzXljBMyIgm4TdU0BZVPjJO1ga/4mQSAE9MPMigCWzeec27QIwPaxDR3wcIGExbC/Iw9723zBJSVx1HZruGxMgcd13t5wkhZBt2i6IehIoWaBDUMZ7VqS4GQSU7wGiFB0tldF4yEFk/21mPX4XHunlYPhhSl5xtG5gSS6Yhy6RWCUbSwEhMSeQs3CLH8SHqYDvqn2jpy9i7si41QrVuw2savZf7T+bIA4sxZmAWQCaB7aXhAgBYQesXfkTMtP7fM6xBNxg2Hjg333zfDr467Hebbo4QC8ObUrj6QUJC3WGrfYK0gpwS1V4YqYyWRKZP2NspyCU+gyUegyEXCZOyDw7bKqsLqlKkznb7jQHnGgLeKAbhE4SQBw5pRl8frx4Oi6X+dvriy/tf79qg7M0G4JUt0sFOXyp5CXoinW51TkrzkFZ+/lvH+3U2CT91zgqF9eiLcXXSVc+Qvw+WX7YCU1hlyFQbdZPWxV5AYcJTkwur7ZHbn58rp52PrWk0gl+ikVOAtvy89sPA3AkB4A2JxTcHa/u2x0HY2n2qofmHxIhb40rmjwzl6MVmWi2PPl9xhXkGCMeLmwqUmfFc5jj8weU7ONVLwyOhgFYwxJM4GKykrasHah/OSb45heWpDncDDYkU9WOPFYxiDHGBtqbJYA9GSEPniphoJ+jg93nVJLiuw56vxXJ/DUyIKIYJomIKLYvOZhBAvcrKmlB6HuyOgr1/yczwGsuh1QPGHA7THxzobqtT8evYSA32W7yKFsJ57xWH+2e08AWDCcY+Ccg3MFILUcoI6cKchQMi9LKQ9yh7pA5eqIcYGUHmswzUSHoozNTlXLtzEcyixFmqb+kBjord++YxeOnDiNi+1XoAgz7GCATPNG25sv2BdOojHzxNN0OtvyrMEDB776dGVTKIznauagpTtWcCUchcqV3JlzrJudmXCEgJKfd23fexvhAFA2bTz0/vj4WFxHelrZGs74Ii3rzWZS5E8tdYK4QKL7JuLC4VNtOgDeeePZ4h/zWUiACMrcQHJJU6eGUNSBNdMiKC9KHIBh3wc1ssLZerJ4bKcaeltS4jGCPQkubyQUarziubR8UnRbzGBID5y6FTaGU+IxMhsYMDVhMRS7TCrzGuiK89+3nQuAs8ycqrNz5Nzh0NJ0KUM+qSEIPoe46HOkYGfdTcFIH14aYXPdDZze29bNAM7YHc7dPGVhjkzPRPgIIDCnF8RVQIrcgaO4CtKKEEGkomWMa5BSxCGsBkiBZM/f0PsugUgZOtQb1Wobbx+6/hjbyoUJrXh2dSz0G2KhU25SnAFpJruMWyFYqdgQHBsqq2VRUlyQBsdSVX/ZdSPaM04YCZDCWwnKM8zpPg1SgLRJJxTqsHFaOb3paaUZg90+4hq40wNIWYEhd/BPQM4DoOdOQc60LG4xp6cWwGxIORFABYDOYSguu8Khe/99uLP+GQASFTyU4hownQAAAABJRU5ErkJggg==",
      "cubeSize": 1.8,
      "scale": 1,
      "rotation": 0,
      "title": "1994-01"
    },
    {
      "position": [
        -140.97999572753906,
        -10,
        -87.41999816894531
      ],
      "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACEAAAAKCAYAAAA6jzeaAAAACXBIWXMAAC4jAAAuIwF4pT92AAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAG5SURBVHjafJM7aFVBFEUXDwOGYIiIFhYabERE/KIgKFjbWYkfJIqCprVJIaYQY2EjNinEykqwEkTBD6LRRgIm4AdU/D4wamL8xmpZuB9OLu/mwGXP7Flz7p175qAuV6+pk+oVlcqzTr3j/3irHq4wa9SbBfNOPdomF+oetalOqGdVUF8Wm8crG7YVa1Pqp2LeH2ZL4X1N8lYcr+Rbqk4X65dVGsA08Jt/McnsGIiOAAuBxcDtePui/dFHQA+wBLgRb38l3yWgG/iQ+RRAA9gA3Ir5s7KpNzpaeOPR+dFl0ccFMxZdUHiDwA7gFDBcvm9eJj3RH5WPeAWsAg4Af4CHwNqsvY62TrU7f/U+sD7ei+h24CTwBDgBnJt16NRqNDW6WKnhSvVzUcOn6kzGB8OsUD8WzDP1V8aHwoxkfk8dyMU1d+xC62XPY55vc5u7ckE3qw/CvVE7CqYzzCb1bphmsT5mfXxBbajvY5ypaSvUvmJjXw2zt2COFP5qdavaq25MF6kOqR2o3UXbDNYk31Ukv1rD7CyY63McZlG1pA2gs2jRb7SP09EmcKyGGYpOzMEAdAEzGX8H+DsAyOLUjUZ4JlMAAAAASUVORK5CYII=",
      "cubeSize": 3,
      "scale": 0.6,
      "rotation": 0,
      "title": "1994"
    },
    {
      "position": [
        -166.67999267578125,
        -7,
        -164.07000732421875
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 2,
      "scale": 1,
      "rotation": 0,
      "title": "1998-01"
    },
    {
      "position": [
        -165.3800048828125,
        3,
        -177.6199951171875
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 1.6,
      "scale": 1,
      "rotation": 0,
      "title": "1998-02"
    },
    {
      "position": [
        -171.3800048828125,
        -7,
        -174.6199951171875
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 3,
      "scale": 0.6,
      "rotation": 0,
      "title": "1998"
    },
    {
      "position": [
        -132.88999938964844,
        -4,
        -262.2200012207031
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 3,
      "scale": 0.7,
      "rotation": 0,
      "title": "2002-01"
    },
    {
      "position": [
        -114.88999938964844,
        -11,
        -288.6199951171875
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 2.9,
      "scale": 0.8,
      "rotation": 0,
      "title": "2002-02"
    },
    {
      "position": [
        -142.89999389648438,
        -8,
        -249.83999633789062
      ],
      "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAKCAYAAADRuIyZAAAACXBIWXMAAC4jAAAuIwF4pT92AAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAHNSURBVHjadJQxSFdRFIe/xDQFKagI6q+DJUJCW0G0RLQFRdmiTfEHl6CMGhqioZaWoKTJJSkQgqCxraFQ+kOCQxCkaQaRBglpZkX6tZxHx5ceuLzf+c7vnXu5992H2qW+8V8sqyPqOZU0DqrPku+h2lLynFRHo76g3i3Vb6pfUo8ZdUjdiXol4Kw65do4EQ32JZYb1dIkRxP/nPSD5JkP9kFdSp5x1FZ1TzKfSobbwR5HPhr5XnU12OFgbyMfXqdPJVin2pjmelEYWGdcTw06gv2I/EzyjQWrRl7E/uRZDNa7wVzvo/68jrXRA9wKPQBMAB1AU7B3yTuXdCWev4CpxL/Gcxv/Rw1oD13NCzkGDId+CVwKvTt5viW9I7FCzwM/Q9cD20MvlBbxBDgUuhuYLrboSNraV6XtO5BqbYkvB+uMofo91dvTe12JDyV+vuCox1NhTG2K4ma1Tm1Ik96I2uX0Dmpzys8GG4z8U+SN6qNgK+rVtLgGStf1T+l6FjtwMbGPSV9LzQY38JyOen9prhn1d/FPqgdGgC1xXi3AVmAWWEpnOxCeC0AbMAncB+6lc+8LfxVoBV4Dd4Cn6cMdB1aATcCu+KZWgem/AwDkNmlyMRNGtgAAAABJRU5ErkJggg==",
      "cubeSize": 3,
      "scale": 0.6,
      "rotation": 0,
      "title": "2002"
    },
    {
      "position": [
        -108.2699966430664,
        -7,
        -356.2200012207031
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 2,
      "scale": 1,
      "rotation": 0,
      "title": "2006"
    },
    {
      "position": [
        -135.52000427246094,
        -11,
        -354.7799987792969
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 3,
      "scale": 0.6,
      "rotation": 0,
      "title": "2006"
    },
    {
      "position": [
        -58.4900016784668,
        -8,
        -456.0299987792969
      ],
      "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEQAAAAjCAYAAAAt4qxQAAAACXBIWXMAAC4jAAAuIwF4pT92AAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAABNfSURBVHja3Jp5lFXVlcZ/59x731jvvXpVRQ0UBcUsYFLIoBETB0QSJSooaowmMaJxihqNJumk7cSgGYkxHRGSdkSjMQEHcIgDCgTUMDiDDMVUVVDz+Ib77nRO/1GASqOYpO3u1eeu9YZ17rpvn++c/e29v/3EnDOm8XGGEKB1//sPfz2Q8ioTz9WYkQx9W48nu3sCRiQLQODmSdXWUDJm0iGflW9tpmXtGsx40Yf+npmKUn/Dn8i+3YCZin5gzvLg5UkBnSUayzvYToFSCr3vu4bRhpSnSyEe0Fq3Hm6dkv//IwrUANbHufl/ERCx/2U68B1g6P4ZHSiskjgyaqGV/rufLKVECoEUAgMCAV8Gzvg/C4jyPbxCHjQXAE8DPwceANL73aVj6RvY29owoqF/DG4hMKTEsqytUois1vr4/z1AtEYY5ofaGq8eJMqPPQbPscvQ2kCADtSxyvbGIQXhmgG0L3ubfH0LRtT6h80ItMIL/DItyAkh1ggOf30igBjhMNk9u8nubTyUn4j2Fev06+dfTzhs/s0qL+4Ocg6hsmRr+sQju53GPnZevQDpZjDSyX/EZcqBc4HpUhpotOs6rieECGkOf5mfCDsYBjpw6dy8mUzDNoQpKB07GRFIndu4W78885q46m1J+zv2VIaPHK4T5Ulyb+/cvfurjzZn32wlWuqgfBNhGPs3TPFe1MAIQOhDsZKQwHxghhDCE1J+V/t6oZTS0TD549huflIuI60QvhPg9mWRsRCdm9aw7dIHcZqz0YhM326UDThry9WP5IYXpRPR2nJ2XP/Ap/ve3rUonKp63hyRXmJK0ZRvy6A8hZDivUVryIXAwUP5GhX0zymliESinwX5eY2OCkm0u6PtMq1ZWFpe0aVUUKn35w3/44Ds5xEpkcJEmhbKd3FaOgny/Cw2pPQStzug0KFKtnz9QYRWmHEZS40aPsNpy8/w2pxZ0WGhU8Jp08tu7wU/OMB28YJk9eQcO6VHrE2Q30eggdIUItHz02XlCc/J09LYEFQPGfansy++gpXPLC169/V1sYpBQ8Iq8J1/BpAIMEdruqXkIcMUtLd4+J4+HNDvRwYhQUpZjs9lQca5xu3VRCs1FadU0LW+B69TIWIxAs/HTJkEBfOEpiW7LiwaV3Fv5bmTUFr3Z4WAVQiYVFfCyOoYhqMO+FE4ZNBQv+WdVc8scx07F6r7zGf9K2/6mTugatDli+++c5IKgt1Aida6+SMB+YiFGcANSjE3FBYoRWTbxsI9X7qkhLIKE98/PBDA0QhjdpAPJpCM1VZ/74zhzb95jtzeDPGhRUHtly2jZlYl3W/5bL2tGzMhMRMR3OYMDi03hbtiq2qum749VF1MYLv7smCbTw87BvMQe9nZ0rijpWG3GjN+MmfPuTyUKC6dd+ct32f5E49xyllne6Zl2ofbSNP3PhwQKTkxFBb09QS0N3szz76o5J5Lv11FEHjkMwop+51a+yG0MkGA1gK0HIAyf4vQM7U292pP9ZBXbuUVUx/Ib2p8peOe5UOMovQ3UDJtxjROm4vyNFLoDtVt/zRcVXR8zbQvnFl05NAlfs75vGrsbNV+/wlRboG+eDvh0iqU5x2AXkpxdLqy5re33P1IxAqF99MN4487gVN21rcbhnlD4Ps9+xLCDwekp8f/sDzSC3xeKNjByYEvSBXL4eddXDoe5GY7qwIh8ACUEydeux7ppFC9FSiRA0Spa1ijBMFPtDJ+JwyRwXciQbbQbRYndCya/HRquHF9IEFYkpbnCkglcNDrnObu24bNOmrhkF9/7Sm3s/dEu755dtDrzGcfsSrHRQf6A+sSUB74wYIcYng8HCbvg+s4mIbBlJM+vzadLv363b+cu0lKiWF+NEuY8+4adMiJcNTQne1qybJHOr99/LRU2bgJ0bGplFiWzxQ6gEYhuF9rHpdYQbTY46Hlf2Dv5gouueAMpBXZ7iOnaSG6LK0wwgbEQvl8fRudT7xBfEDynJblttX6qo2Zkrg9ivAAia3VJqUVZiqW93O5qwrbm1fogv9VLVgIBAiBbztoPzh4o+dIKSfoICCbV4DGkALfV1ng+4aUm4SUBzLYjwRk6MjwoU+IZOKg2tjVdZNTxVAAwM4Gg4KAQVIyXitONS2xyHXVtd1NVraxqY/ujEkw5ihWN7qedHJdRrSIQV4XVe27cXtytCx8CVxXBuFQqdsdIPYojEBjVRgoqb2YJ+utcIjAV/hdmU3K9u7SQszxg6AaaNBaI8MRjFDoAMkCg4ArPrhYAaClwfxe210+YlwdEz53MqufWkKqdMBHA2Ln1SEipq4zJIsjCV3reQrPdgmUxJACKfttMUzMSNy4+JUV+Y2Lbrdv08DwYXGMcCTh4tdJLTbElLJ3DRhC5md/JrpiPaRTGJZRIXw1pSbsk4oqCAK68iG2G5F6EXWWOSFFceAj7ABpGA8GQXCG53njgQY/l6V0/DFEKivw7QPkN21fNXvweAT4F61BGgZmKIR+D0SEAN8TOAWBIECjAYGp9X9JH4hEjKswIrXfvOYl0qkYt8w9EbfQiVvQCIkWgmeiRUZk1xZ36uL/yF0XSxhrtDLtXD53nCpkL6spK6pra3EeL07ELiok4r21UpBWAR4Kww2siBkUbbAj/MZNQa3BkXtCHOd0G25US09pogQ42idQQauQkrAVGoIUCDuH+GB4M4ALDgHG28DN+0MdQLa3m/a9TaggAMBzobQqxJhJaXzPPFDFmFr9l2A5QghmaCQte22eeLSBG2/8HMl4BCefRUhDWKa4A/Rflv3RvunNV92bJ58YfdWxQ+xpasfJ9Lw0cvjQ+3fubq+ko71KKK93hWFiJxJY0ShhMN+NRUP3pgfQWwluXzWzzl/F+Xu3djU/NiXjqDCR3iRWLIS0wtO01mNdP/CCXBYjmSZcWYHyDxh9AXDyIQD5EbBZAFIIXF8xfspJFJcMIBKLo7VGKZNQ9F1SZU8TCo9AyjBaB5jhqDg4vEwzw3ogKBYumMVJ0+7l/gde55qrjgHRh9YGSnM5yPXpUn7senplPqNn5bLK7etSSw0jvdq0oDdjx5v7mv3S7m5+mShi+/ChEA+DI8bRGK687maXC4+LctHFTXxh/Fou751ibimPBq6rudBw+EZbEx3dBSsWTz1hBO6LZlGCks+cgBmP4eddhBAjgZ9x6Dgae381abs+dZOP5qjJR3/gpq7e9ax+9o+UlGukVGitMUMR42BFIFjxZIaO1hyz5wzn9C+O4Fe3reeC88eRTsXJZWyCwDijkAsWn3Zu9PSxR4VWJtPmSinjFPID2Nt2N7XD5hKKRHKBEyVkRfCUBcroP+FKlscqfCvf4PLj5yPM/tTj7No0jD+tm9zCuJ0uXZrNyQxBRxe5vPfncCjyWCyeyJVMmoIXihHk3bgQYjbwfaDqQ7gx/4EVCUHB7Q/VltD4WhC1BHa2F3mQTGHe/avMB4hGSrHtL4tzmUgo2DV7Tvd9cy6uu3nxki1FLzy/jfPO+xRSOmgNnqePTyTlQxOOsxpARMFqhfiyhx94ac2N14+kq8dl3m+O5viT6li8Okvj5hBaCTD96nxzO4sfqeCmbx3LpEo45wcdLkbr71HKwc4RwkBLA8/NO4XAdxKDhxOOxSlknVmGIecCI4GPUo7GAo/u/xKPmDww/za62/Zy1b/+hH2JG/oQFbO5cf17tY5hCrraAiuRlKZEPLl9U99tI8amWPH8rHlKe8LJdfcX2aIfPNdjhusG/ZqFgKKUvqhgc1n9pvonHAeixhCS8SyLb+pg+No4zTtUiKg/anBxggVX1XHanDFs/FsFzS13zsXKLKMsycihVUycciKr3nmWZ5e/QPWQYVw5/hiAi7QQC4HwxyigrgNeAtZo3X9Csr3dNO/egVIa46MUs6CQwbN7UYFLJBqhrMKcWlwiop3twdY75uYA//bqmvii8vIorucfolzpd1RpCLSWFb099q1I6vo0UduWgEU0DGcfm2dgaVicWlfN2vtmcdrJR+BuLlBh2tvOPGnQ/M+MqeDKL0xk69PzuGLm8WxraqNQKGDbNlqpswXcrhVhPp5eVLKPWJOmIejqaKe9uYlEcfrwEuLw405h3MlfJD2wku2bNsdMM3wqQjKgms6qGgkIpYLC73zHx5CHFti00ggUQqQor4iP832emjE1/VB1TfFs5StyecFvf9LD9786yrnopCOWVRQn9ZYN9Tw973YyzV0rH59/SfaVRd9g/kWnvE8oFoRCYexs5vJH7114dyGfS8XCBsEHFbQWYBlwDbDgILOmaa2vjoVN1q35K88veZDi0vLDC0RjZpxLLB7iNJ3jju/9oPLNdevGjhw37sVQKLJSaMhlC3iueivw5cPRiHG+EBql9pf/giAIkPhEi0ro7urmqSfqOfvc4dUL7jmvWsremdm+jnsNqTZms+YfzqyrbZFG+HXbqC5kul6MZjb/md1rQovffu4Zr6BCnPmLnx7wB6UUhml+K1pU9OsnH76P2tFjszO+9LXXAs3mIFCvC0EHsAN47X3rcYFr9/ND2DIv7u3uWrTt7Q2NJeVVKBUc/oR0t+yhZWc9g4eMNG69597v1VSmREdTw7WFbL4v09df0WolcoZlPMKBegC01mjlEYmG34oly5+s39r1xKVffejfVr7YPHfk6MhLWvtrhfD3arJf14h5EnX7oBPfMQYeO7qxqX7nk80vvM7gYz7H5nc2THx24Z08t+jh/T5YCdwkBC/s2rLx16ZpUVFT82xzw+7pwOmGIS7TWi8EFh8EBsB3gXp0/5PClhxWyOcu3bT+FcKx+MfyNVMK4yQhzJJX391y+ZjRo6dd9KPb79n45jvvxItCTJy4mpAlMROCIFDTPM9FINFaYRgmsXhiO1KfC8mGxqatrFrZbifi0NnRXtzWuitUXVMSkxgXGoZ3lTRCsat++qTa+84q+0tNaqloCs5Z/lwHI04xf1w2OnFET0/qmwJGFWBRBMbMvvgKerq76ens/J1hGDdGYrHMh0WG9w0HuDTQ+uFkPFRp57M8OH/e1/LZLKnidEwrvWMf2b77Hgnqg3o6Zsl0LdPnbm3ypi15aXOhUycW1o47iuqRIxgxLoIK+iVe0zTziUSEokSYRHGcWCKpX9vQ+ujUKX/YcvnXFtmjqm376IlJEqkQ8Xi0x7QibeDuUsq4xbQiJ0gj+aVXNhhFj7+8+tbmPR0/rziq+LG6G4s/N3Bw2X2uM/Yrk8/9yqpQLPpEBMYorRlVN7HhF/ct+WHVwJqr3byd+TvEyxXxqDV7746tT/78hiv1hr++OLh2xKibvELh23t375jv+94KCb8HjgSRBnElcMR7EqIwbgcdjkWslZ7v53sduS4jk4T8LO0tBQzDRQpJLuctkWbk4qKEWWZZcZoaWtQNVz9+1sq/uVNHjij6jVfI/+nW26Y5qdI4JUlNOCzxHA9bX0gme+zWsJkzfnHda3NvWbjoX9Z69dmZ31W9Yz41pvj1pU1N533xu07dCTPqAjvPitUv8cqmtR2RaM3Vp06dvrSrUKA9a+MUPn7DypRizc4t757/+ssrLxv96Qmnuq5TZVpWasr0GdWxeFF53tWXhkxxXklZ3RslAyZ91s7vvScaq7p0n6aqW0EjJXeGTInnaxAGnq959ZXdoAuAJBSSa3fuzN6w7pW934kVhca07M0Zjbvd4bf9cgKXfXPmIrvrrbOyHfLfipKh+qIibMduI+uchct0pG5POr5x19QpJ58zedxUVmxctrDFWr7LeHnPH0pro0kruZS+7sa/LJy/58lb73745pqhsbLjjkoEzU0L0DWSI8qTDKzpQKlWEIePFLq/Ys9aodCvrFD439v2NKaqa4clTz797M8rIab4vjdMCKsKrY6PxgaSy+4+T2t1P4jV5qHSiv2fpBSgBSCQUhCLGfevXtX+mOP4Zw2q4ejKKoZkM275jvquklFjh8ysjPTNNITztOPIZ0DeIYWHIXqRIvOVIFDnNLZ1kU4kOfO4c6a+9dquqdsbnnqjpHLG72KqqzYQj1+6dANtA4cMvaUkWbTph9dWv1w9JA4E+yqS9cBficrZFGzdb9thWplCCLTWnhCiQ2vdEfj+AgULDMOyLIv0xrfvmtmy55mfpEsnlQaB83vQc/6uNoTWEA4bfZbl3zd4CPfZNty18J1UV1f7gKu+9dlBgwenbzBEeEYm4yUtkzv6d0qgEZ2GNJHCoDvTix1EB6erpqYG9L65prW99zRpDhjx9OpMUyzMzEGjQ8Udnc6v/uOP7d2jR/RRsPdtk5bY7nKmTBnDmBFH4Prqn2mSeALatPJ/H/jOdiHMZVAYA8z7h/synge+DyUl9JaWpXtdx63v6rRXl5YWnSGleOOg2x/V6J8juDZkhlt9p/P64qqJDV2tE2hteaYhXyhuWLwcEhHVHQTeNamkePD5v+ZY+nzmvZMgDBoblnHLDyYxfsy4fxaQfaqgAUIu1zq4ALgEWPXf1qiSUmIY0gf96CGmXeDH+w7ZDimMR3M9zZRVT6e1tRWCZoZUGeTzrPQVK7WCdMqgpPigqiMooago8Um01R7bl9O0/U/+HSIAGoE2TX9SZ1pJpBFB069FaA7XJPhERx4I/nMAgJwSZ99nn8oAAAAASUVORK5CYII=",
      "cubeSize": 1.6,
      "scale": 1,
      "rotation": 0,
      "title": "2010"
    },
    {
      "position": [
        -74.48999786376953,
        -12,
        -428.0299987792969
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 3,
      "scale": 0.6,
      "rotation": 0,
      "title": "2010"
    },
    {
      "position": [
        -63.880001068115234,
        -3,
        -717.3900146484375
      ],
      "image": "data:image/png;base64,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",
      "cubeSize": 1.8,
      "scale": 1,
      "rotation": 0,
      "title": "2014"
    }
  ]
});
define('worldcup-high/skyData',[],function() {
    return 'data:image/jpeg;base64,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AAABAAAAAAAScHJpbnRPdXRwdXRPcHRpb25zAAAAFwAAAABDcHRuYm9vbAAAAAAAQ2xicmJvb2wAAAAAAFJnc01ib29sAAAAAABDcm5DYm9vbAAAAAAAQ250Q2Jvb2wAAAAAAExibHNib29sAAAAAABOZ3R2Ym9vbAAAAAAARW1sRGJvb2wAAAAAAEludHJib29sAAAAAABCY2tnT2JqYwAAAAEAAAAAAABSR0JDAAAAAwAAAABSZCAgZG91YkBv4AAAAAAAAAAAAEdybiBkb3ViQG/gAAAAAAAAAAAAQmwgIGRvdWJAb+AAAAAAAAAAAABCcmRUVW50RiNSbHQAAAAAAAAAAAAAAABCbGQgVW50RiNSbHQAAAAAAAAAAAAAAABSc2x0VW50RiNQeGxAcsAAAAAAAAAAAAp2ZWN0b3JEYXRhYm9vbAEAAAAAUGdQc2VudW0AAAAAUGdQcwAAAABQZ1BDAAAAAExlZnRVbnRGI1JsdAAAAAAAAAAAAAAAAFRvcCBVbnRGI1JsdAAAAAAAAAAAAAAAAFNjbCBVbnRGI1ByY0BZAAAAAAAAAAAAEGNyb3BXaGVuUHJpbnRpbmdib29sAAAAAA5jcm9wUmVjdEJvdHRvbWxvbmcAAAAAAAAADGNyb3BSZWN0TGVmdGxvbmcAAAAAAAAADWNyb3BSZWN0UmlnaHRsb25nAAAAAAAAAAtjcm9wUmVjdFRvcGxvbmcAAAAAADhCSU0D7QAAAAAAEAEsAAAAAQACASwAAAABAAI4QklNBCYAAAAAAA4AAAAAAAAAAAAAP4AAADhCSU0D8gAAAAAACgAA////////AAA4QklNBA0AAAAAAAQAAAAeOEJJTQQZAAAAAAAEAAAAHjhCSU0D8wAAAAAACQAAAAAAAAAAAQA4QklNBAoAAAAAAAEAADhCSU0nEAAAAAAACgABAAAAAAAAAAI4QklNA/UAAAAAAEgAL2ZmAAEAbGZmAAYAAAAAAAEAL2ZmAAEAoZmaAAYAAAAAAAEAMgAAAAEAWgAAAAYAAAAAAAEANQAAAAEALQAAAAYAAAAAAAE4QklNA/gAAAAAAHAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAA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4VezGAKPuBHAX//ZADhCSU0EIQAAAAAAVQAAAAEBAAAADwBBAGQAbwBiAGUAIABQAGgAbwB0AG8AcwBoAG8AcAAAABMAQQBkAG8AYgBlACAAUABoAG8AdABvAHMAaABvAHAAIABDAFMANgAAAAEAOEJJTQQGAAAAAAAHAAgAAAABAQD/4RpDaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjMtYzAxMSA2Ni4xNDU2NjEsIDIwMTIvMDIvMDYtMTQ6NTY6MjcgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wUmlnaHRzPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvcmlnaHRzLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IFdpbmRvd3MiIHhtcDpDcmVhdGVEYXRlPSIyMDA5LTA0LTA2VDIyOjIyOjQwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAxNC0wNi0wOVQxMzoyOToxNiswODowMCIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAxNC0wNi0wOVQxMzoyOToxNiswODowMCIgZGM6Zm9ybWF0PSJpbWFnZS9qcGVnIiBwaG90b3Nob3A6RGF0ZUNyZWF0ZWQ9IjIwMDktMDQtMDZUMjI6MjI6NDAiIHBob3Rvc2hvcDpMZWdhY3lJUFRDRGlnZXN0PSJBMEJFRkM4QjNCOEQ2NjAwN0M3RDgxQTcxQzQ1QTc0QSIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgcGhvdG9zaG9wOklDQ1Byb2ZpbGU9InNSR0IgdjEuMzEgKENhbm9uKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowNjgwMTE3NDA3MjA2ODExODIyQUI1MUU2RjE2QTkxRSIgeG1wTU06RG9jdW1lbnRJRD0idXVpZDo5MzQ5QkRFQjZBMjNERTExOEY1MUU3MTNDQjhDOEY3NiIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ1dWlkOjkzNDlCREVCNkEyM0RFMTE4RjUxRTcxM0NCOEM4Rjc2IiB4bXBSaWdodHM6TWFya2VkPSJGYWxzZSI+IDxwaG90b3Nob3A6RG9jdW1lbnRBbmNlc3RvcnM+IDxyZGY6QmFnPiA8cmRmOmxpPnhtcC5kaWQ6ODhDMjUzRUNDOUU1REYxMUIxN0M5RjcxQTFCMUE3MjA8L3JkZjpsaT4gPC9yZGY6QmFnPiA8L3Bob3Rvc2hvcDpEb2N1bWVudEFuY2VzdG9ycz4gPHhtcE1NOkhpc3Rvcnk+IDxyZGY6U2VxPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6QjM2QjExMjdDODY4REYxMTgwMzBDNEUwMTRBMkM2NDkiIHN0RXZ0OndoZW49IjIwMTAtMDUtMjZUMTU6MTg6MDYrMDI6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDUzUgV2luZG93cyIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY29udmVydGVkIiBzdEV2dDpwYXJhbWV0ZXJzPSJmcm9tIGltYWdlL3RpZmYgdG8gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iZGVyaXZlZCIgc3RFdnQ6cGFyYW1ldGVycz0iY29udmVydGVkIGZyb20gaW1hZ2UvdGlmZiB0byBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpCNDZCMTEyN0M4NjhERjExODAzMEM0RTAxNEEyQzY0OSIgc3RFdnQ6d2hlbj0iMjAxMC0wNS0yNlQxNToxODowNiswMjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpCNTZCMTEyN0M4NjhERjExODAzMEM0RTAxNEEyQzY0OSIgc3RFdnQ6d2hlbj0iMjAxMC0wNS0yNlQxNToxOToxNSswMjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDowM0Q3REU3RjMyRDZERjExQTBDNUY1MDJFMzZCNUUxQSIgc3RFdnQ6d2hlbj0iMjAxMC0xMC0xMlQyMDo1NzoxMiswMjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjb252ZXJ0ZWQiIHN0RXZ0OnBhcmFtZXRlcnM9ImZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS90aWZmIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJkZXJpdmVkIiBzdEV2dDpwYXJhbWV0ZXJzPSJjb252ZXJ0ZWQgZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3RpZmYiLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjA0RDdERTdGMzJENkRGMTFBMEM1RjUwMkUzNkI1RTFBIiBzdEV2dDp3aGVuPSIyMDEwLTEwLTEyVDIwOjU3OjEyKzAyOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ1M1IFdpbmRvd3MiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjk3REY1RkIzNkVFRURGMTE5MTZBQzZBNzA5NjZEOEJDIiBzdEV2dDp3aGVuPSIyMDEwLTExLTEyVDE2OjEzKzAxOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ1M1IFdpbmRvd3MiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjBBRTk1QTM5ODFERkUwMTFCRjVDODE4NjNBOEIxREM0IiBzdEV2dDp3aGVuPSIyMDExLTA5LTE1VDExOjU4OjU3KzAyOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ1M1IFdpbmRvd3MiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjUyQzg2QjQyOENERkUwMTFCRjVDODE4NjNBOEIxREM0IiBzdEV2dDp3aGVuPSIyMDExLTA5LTE1VDEzOjE3OjQ1KzAyOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ1M1IFdpbmRvd3MiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOkQxNzE3NjE1NEJFMEUwMTE5RTUzRkQ4NEFGQjg3NzlDIiBzdEV2dDp3aGVuPSIyMDExLTA5LTE2VDEyOjAzOjEwKzAyOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ1M1IFdpbmRvd3MiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjg0MzMzMTkwMjQzRUUxMTE4NEY5ODlDNDNGNTAwRDgyIiBzdEV2dDp3aGVuPSIyMDEyLTAxLTEzVDIxOjI0OjE2KzAxOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ1M1IFdpbmRvd3MiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNvbnZlcnRlZCIgc3RFdnQ6cGFyYW1ldGVycz0iZnJvbSBpbWFnZS90aWZmIHRvIGltYWdlL2pwZWciLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImRlcml2ZWQiIHN0RXZ0OnBhcmFtZXRlcnM9ImNvbnZlcnRlZCBmcm9tIGltYWdlL3RpZmYgdG8gaW1hZ2UvanBlZyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6ODUzMzMxOTAyNDNFRTExMTg0Rjk4OUM0M0Y1MDBEODIiIHN0RXZ0OndoZW49IjIwMTItMDEtMTNUMjE6MjQ6MTYrMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDUzUgV2luZG93cyIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MDY4MDExNzQwNzIwNjgxMTgyMkFCNTFFNkYxNkE5MUUiIHN0RXZ0OndoZW49IjIwMTQtMDYtMDlUMTM6Mjk6MTYrMDg6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDUzYgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjg0MzMzMTkwMjQzRUUxMTE4NEY5ODlDNDNGNTAwRDgyIiBzdFJlZjpkb2N1bWVudElEPSJ1dWlkOjkzNDlCREVCNkEyM0RFMTE4RjUxRTcxM0NCOEM4Rjc2IiBzdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ9InV1aWQ6OTM0OUJERUI2QTIzREUxMThGNTFFNzEzQ0I4QzhGNzYiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPD94cGFja2V0IGVuZD0idyI/Pv/iDFRJQ0NfUFJPRklMRQABAQAADERVQ0NNAkAAAG1udHJSR0IgWFlaIAfTAAQABAAAAAAAAGFjc3BNU0ZUAAAAAENBTk9aMDA5AAAAAAAAAAAAAAAAAAD21gABAAAAANMtQ0FOTwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADnJUUkMAAAEsAAAIDGdUUkMAAAEsAAAIDGJUUkMAAAEsAAAIDHJYWVoAAAk4AAAAFGdYWVoAAAlMAAAAFGJYWVoAAAlgAAAAFGNoYWQAAAl0AAAALGNwcnQAAAmgAAAAQGRtbmQAAAngAAAAfGRtZGQAAApcAAAAlHd0cHQAAArwAAAAFHRlY2gAAAsEAAAADGRlc2MAAApcAAAAlHVjbUkAAAsQAAABNGN1cnYAAAAAAAAEAAAAAAQACQAOABMAGAAd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';
});
define('worldcup-high/logoData',[],function() {
    return 'data:image/png;base64,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';
});
define('worldcup-high/grassData',[],function() {
    return 'data:image/jpeg;base64,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aGVuUHJpbnRpbmdib29sAAAAAA5jcm9wUmVjdEJvdHRvbWxvbmcAAAAAAAAADGNyb3BSZWN0TGVmdGxvbmcAAAAAAAAADWNyb3BSZWN0UmlnaHRsb25nAAAAAAAAAAtjcm9wUmVjdFRvcGxvbmcAAAAAADhCSU0D7QAAAAAAEABIAAAAAQACAEgAAAABAAI4QklNBCYAAAAAAA4AAAAAAAAAAAAAP4AAADhCSU0EDQAAAAAABAAAAB44QklNBBkAAAAAAAQAAAAeOEJJTQPzAAAAAAAJAAAAAAAAAAABADhCSU0ECgAAAAAAAQEAOEJJTScQAAAAAAAKAAEAAAAAAAAAAjhCSU0D9QAAAAAASAAvZmYAAQBsZmYABgAAAAAAAQAvZmYAAQChmZoABgAAAAAAAQAyAAAAAQBaAAAABgAAAAAAAQA1AAAAAQAtAAAABgAAAAAAAThCSU0D+AAAAAAAcAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAA4QklNBAgAAAAAABUAAAABAAACQAAAAkAAAAABAAAQAAEAOEJJTQQeAAAAAAAEAAAAADhCSU0EGgAAAAADPwAAAAYAAAAAAAAAAAAAAQAAAAEAAAAABQBnAHIAYQBzAHMAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAEAAAAAAABudWxsAAAAAgAAAAZib3VuZHNPYmpjAAAAAQAAAAAAAFJjdDEAAAAEAAAAAFRvcCBsb25nAAAAAAAAAABMZWZ0bG9uZwAAAAAAAAAAQnRvbWxvbmcAAAEAAAAAAFJnaHRsb25nAAABAAAAAAZzbGljZXNWbExzAAAAAU9iamMAAAABAAAAAAAFc2xpY2UAAAASAAAAB3NsaWNlSURsb25nAAAAAAAAAAdncm91cElEbG9uZwAAAAAAAAAGb3JpZ2luZW51bQAAAAxFU2xpY2VPcmlnaW4AAAANYXV0b0dlbmVyYXRlZAAAAABUeXBlZW51bQAAAApFU2xp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AAABAQAAAA8AQQBkAG8AYgBlACAAUABoAG8AdABvAHMAaABvAHAAAAATAEEAZABvAGIAZQAgAFAAaABvAHQAbwBzAGgAbwBwACAAQwBTADYAAAABADhCSU0EBgAAAAAABwAHAAAAAQEA/+ESsGh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8APD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS4zLWMwMTEgNjYuMTQ1NjYxLCAyMDEyLzAyLzA2LTE0OjU2OjI3ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtbG5zOnhtcFJpZ2h0cz0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3JpZ2h0cy8iIHhtbG5zOklwdGM0eG1wQ29yZT0iaHR0cDovL2lwdGMub3JnL3N0ZC9JcHRjNHhtcENvcmUvMS4wL3htbG5zLyIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOjIwNTI1NDY5MTAwREUwMTE5QkU4RkM3MUU1MzEzNjAxIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjY4ODBGQThDODVERjExRTBCQjZDQjMxOTNDMTQxNENDIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjA3ODAxMTc0MDcyMDY4MTE4MDgzQTdEQUQzNjM5MjU5IiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzYgKE1hY2ludG9zaCkiIHhtcDpNZXRhZGF0YURhdGU9IjIwMTQtMDYtMTBUMTQ6MTA6MTErMDg6MDAiIHhtcDpDcmVhdGVEYXRlPSIyMDExLTA1LTI0VDEwOjI4OjU4KzA4OjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAxNC0wNi0xMFQxNDoxMDoxMSswODowMCIgZGM6Zm9ybWF0PSJpbWFnZS9qcGVnIiBwaG90b3Nob3A6SGVhZGxpbmU9IkdyYXNzIEdyZWVuIFRleHR1cmVzIiBwaG90b3Nob3A6RGF0ZUNyZWF0ZWQ9IjIwMTEtMDUtMjQiIHBob3Rvc2hvcDpMZWdhY3lJUFRDRGlnZXN0PSJDMjEwREM2OEVEQkM3RDAxQTY4RjRCQzZGMTM3RDlFQiIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgeG1wUmlnaHRzOk1hcmtlZD0iVHJ1ZSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkI2OUI2QjI5REU4NUUwMTE4RDM0RUMzNDJDRjQ1RjYzIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjIwNTI1NDY5MTAwREUwMTE5QkU4RkM3MUU1MzEzNjAxIi8+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjNBQUM4RURGREY4NUUwMTFBNTNDREFGOEUzQzBDODEzIiBzdEV2dDp3aGVuPSIyMDExLTA1LTI0VDEwOjI4OjU5KzAyOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ2FtZXJhIFJhdyA2LjQiIHN0RXZ0OmNoYW5nZWQ9Ii9tZXRhZGF0YSIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MDI4MDExNzQwNzIwNjgxMTgyMkE5OUFDNTZCM0RGOEIiIHN0RXZ0OndoZW49IjIwMTQtMDYtMDJUMTg6Mzg6MTArMDg6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDUzYgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjA3ODAxMTc0MDcyMDY4MTE4MDgzQTdEQUQzNjM5MjU5IiBzdEV2dDp3aGVuPSIyMDE0LTA2LTEwVDE0OjEwOjExKzA4OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ1M2IChNYWNpbnRvc2gpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDwvcmRmOlNlcT4gPC94bXBNTTpIaXN0b3J5PiA8ZGM6Y3JlYXRvcj4gPHJkZjpTZXE+IDxyZGY6bGk+U2ltb24gTXVycmF5PC9yZGY6bGk+IDwvcmRmOlNlcT4gPC9kYzpjcmVhdG9yPiA8ZGM6ZGVzY3JpcHRpb24+IDxyZGY6QWx0PiA8cmRmOmxpIHhtbDpsYW5nPSJ4LWRlZmF1bHQiPkdyZWVuIEdyYXNzIFRleHR1cmU8L3JkZjpsaT4gPC9yZGY6QWx0PiA8L2RjOmRlc2NyaXB0aW9uPiA8ZGM6c3ViamVjdD4gPHJkZjpCYWc+IDxyZGY6bGk+Z3Jhc3MgZ3JvdW5kIHBsYW50IG5hdHVyZSBncm91bmQgdGV4dHVyZXMgZnJlZSBpbWFnZXMgY2cgcGhvdG9zIHNlYW1sZXNzPC9yZGY6bGk+IDwvcmRmOkJhZz4gPC9kYzpzdWJqZWN0PiA8ZGM6cmlnaHRzPiA8cmRmOkFsdD4gPHJkZjpsaSB4bWw6bGFuZz0ieC1kZWZhdWx0Ij53d3cuZ29vZHRleHR1cmVzLmNvbTwvcmRmOmxpPiA8L3JkZjpBbHQ+IDwvZGM6cmlnaHRzPiA8SXB0YzR4bXBDb3JlOkNyZWF0b3JDb250YWN0SW5mbyBJcHRjNHhtcENvcmU6Q2lFbWFpbFdvcms9InN1cHBvcnRAZ29vZHRleHR1cmVzLmNvbSIgSXB0YzR4bXBDb3JlOkNpVXJsV29yaz0id3d3Lmdvb2R0ZXh0dXJlcy5jb20iLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPD94cGFja2V0IGVuZD0idyI/Pv/uAA5BZG9iZQBkQAAAAAH/2wCEAAEBAQEBAQEBAQECAQEBAgIBAQEBAgICAgICAgIDAgMDAwMCAwMEBAQEBAMFBQUFBQUHBwcHBwgICAgICAgICAgBAQEBAgICBAMDBAcFBAUHCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICP/AABEIAQABAAMBEQACEQEDEQH/3QAEACD/xAGiAAAABgIDAQAAAAAAAAAAAAAHCAYFBAkDCgIBAAsBAAAGAwEBAQAAAAAAAAAAAAYFBAMHAggBCQAKCxAAAgECBQIDBAYGBQUBAwZvAQIDBBEFBiESAAcxQRMIUSJhFHGBMpEJoSPwwUKxFdEW4fFSMxckYhhDNCWCChlyUyZjkkQ1olSyGnM2wtInRTdG4vKDk6OzZFUow9MpOOPzR0hWZSo5OklKV1hZWmZ0dYSFZ3Z3aIaHlJWkpbS1xMXU1eTl9PWWl6antrfGx9bX5uf292lqeHl6iImKmJmaqKmquLm6yMnK2Nna6Onq+Pn6EQABAwIDBAcGAwQDBgcHAWkBAgMRAAQhBRIxBkHwUWEHEyJxgZGhscEIMtEU4SPxQhVSCRYzYtJyJILCkpNDF3ODorJjJTRT4rM1JkRUZEVVJwqEtBgZGigpKjY3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';
});
define('worldcup-high/Ground',['require','qtek','./grassData'],function (require) {
    
    var qtek = require('qtek');

    var grassData = require('./grassData');

    var Ground = qtek.Mesh.derive(function() {

        var planeGeo = new qtek.geometry.Plane();
        var material = new qtek.Material({
            shader: qtek.shader.library.get('buildin.physical', 'diffuseMap')
        });

        material.set('glossiness', 0.1);
        material.set('color', [1.5, 1.5, 1.5]);

        var diffuseTex = new qtek.texture.Texture2D({
            wrapS: qtek.Texture.REPEAT,
            wrapT: qtek.Texture.REPEAT,
            anisotropic: 8
        });
        diffuseTex.load(grassData);

        material.set('diffuseMap', diffuseTex);
        material.set('uvRepeat', [160, 160]);

        return {
            geometry : planeGeo,
            material: material
        }
    }, function() {

        this.scale.set(2000, 2000, 1);
        this.rotation.rotateX(-Math.PI/2);
        this.position.y = -16;
    })

    return Ground;
});
define('worldcup-high/Leaves',['require','qtek'],function (require) {
    
    var qtek = require('qtek');

    var rand = Math.random;

    var shader = qtek.shader.library.get('buildin.physical');

    var Leaves = function(camera) {

        this.leaves = [];

        this.camera = camera;

        this.xRange = 200;
        this.zRange = 200;
        
        this.planeGeo = new qtek.geometry.Plane();
    }

    Leaves.prototype._resetLeaaf = function(node) {
        node.position._array[0] = this.xRange - rand() * this.xRange * 2;
        node.position._array[1] = -10 + rand() * 40;
        node.position._array[2] = -rand() * this.zRange - 10;

        if (this.camera) {
            // Before camera
            node.position._array[0] += this.camera.position._array[0];
            node.position._array[1] += this.camera.position._array[1];
            node.position._array[2] += this.camera.position._array[2];
        }
        
        node.life = 1000 + rand() * 2000;

        qtek.math.Vector3.set(
            node.scale,
            rand() * 0.3 + 0.1,
            rand() * 0.3 + 0.1, 
            1
        );
        qtek.math.Quaternion.rotateX(node.rotation, node.rotation, rand() * Math.PI * 2);
        qtek.math.Quaternion.rotateZ(node.rotation, node.rotation, rand() * Math.PI * 2);
    }

    Leaves.prototype.init = function(number) {
        
        this.leaves.length = 0;

        for (var i = 0; i < number; i++) {
            var material = new qtek.Material({
                shader: shader
            });
            material.set('color', [0.7, rand(), rand()]);

            var mesh = new qtek.Mesh({
                geometry: this.planeGeo,
                material: material,
                culling: false
            });

            this._resetLeaaf(mesh);

            this.leaves.push(mesh);
        }

        return this.leaves;
    }

    Leaves.prototype.update = function(deltaTime) {

        for (var i = 0; i < this.leaves.length; i++) {
            var leaf = this.leaves[i];
            qtek.math.Quaternion.rotateY(leaf.rotation, leaf.rotation, deltaTime / 1000);
            leaf.position._array[1] -= deltaTime / 1000;
            leaf.life -= deltaTime;
            if (leaf.life < 0) {
            // if (leaf.z < -20) {
                this._resetLeaaf(leaf);
            // }
            }
        }
    }

    Leaves.prototype.dispose = function() {
        
    }

    return Leaves;
});
define('worldcup-high/MainScene',['require','./instancing','./bokeh','./mosaic','./cubeGeo','./tracksData','./skyData','./logoData','./closeData','./Ground','./Leaves','qtek'],function(require) {

    var instancing = require('./instancing');
    var bokeh = require('./bokeh');
    var mosaic = require('./mosaic');

    var cubeGeo = require('./cubeGeo');
    var tracks = require('./tracksData');

    var skyData = require('./skyData');
    var logoData = require('./logoData');

    var closeData = require('./closeData');

    var Ground = require('./Ground');
    var Leaves = require('./Leaves');

    var qtek = require('qtek');

    var specularColor = [0.5, 0.5, 0.5];
    var emission = [0, 0, 0];
    var lineColor = [0, 0, 0];

    var closeStyle = {
        position: 'fixed',
        right: '30px',
        top: '30px',

        width: '21px',
        height: '21px',

        backgroundSize: '21px 21px',
        backgroundRepeat: 'no-repeat',

        backgroundImage: 'url(' + closeData +')',

        cursor: 'pointer',

        zIndex: 10010
    }

    var fadeInStyle = {
        position: 'fixed',
        left: '0px',
        right: '0px',
        top: '0px',
        bottom: '0px',

        backgroundColor: 'black',
        opacity: 0,
        zIndex: 10001
    }

    var cameraFar = 260;

    function MainScene(renderer, animation, container) {

        this.renderer = renderer;
        this.animation = animation;

        this.container = container;

        this.compositor = null;

        this._odx = 0;

        this._cubes = [];

        this._players = [];

        this.onMouseMove = this.onMouseMove.bind(this);
    }

    function isMacFireFox() {
        return window.navigator.userAgent.indexOf('Firefox') >= 0
            && window.navigator.userAgent.indexOf('Mac OS') >= 0
    }

    MainScene.prototype.init = function(callback) {
        var self = this;
        /////////////// Basic Scene
        var scene = this.scene = new qtek.Scene();
        var camera = this.camera = new qtek.camera.Perspective();

        var light = new qtek.light.Directional({
            intensity: 1
        });
        light.position.set(0, 40, 70);
        light.lookAt(qtek.math.Vector3.ZERO);
        scene.add(light);

        scene.add(new Ground());

        /////////////// Skydome
        var skyTexture = new qtek.texture.Texture2D({
            flipY: false
        });
        skyTexture.load(skyData);
        var skydome = new qtek.plugin.Skydome({
            geometry: new qtek.geometry.Sphere({
                widthSegments: 30,
                heightSegements: 30,
                thetaLength : Math.PI / 1.8
            }),
            scene: scene
        });
        skydome.rotation.rotateY(Math.PI);
        skydome.material.set('diffuseMap', skyTexture);

        /////////////// Leaves FX
        this.leaves = new Leaves(camera);
        var leafList = this.leaves.init(2000);

        leafList.forEach(function(mesh) {
            mesh.visible = false;
            scene.add(mesh);
        });

        instancing(leafList, 20).forEach(function(mesh) {
            scene.add(mesh);
        });

        ////////////// Bokeh FX
        this.compositor = bokeh(this.renderer, scene, camera);

        ////////////// Players
        var count = tracks.players.length;
        for (var i = 0; i < tracks.players.length; i++) {
            this._createPlayer(tracks.players[i], function() {
                count--;
                if (count == 0) {
                    callback && callback();
                }
            });
        }

        ////////////// Logo data
        var logoImg = new Image();
        logoImg.onload = function() {
            var logoCubeData = mosaic(logoImg, 0, 0, logoImg.width, logoImg.height, 1, false);

            // Explosion data
            var randomExplodedPositions = [];
            var minR = 10;
            var maxR = 40;
            var minTheta = -Math.PI / 3;
            var maxTheta = Math.PI / 3;
            var rand = Math.random;

            for (var i = 0; i < logoCubeData.position.length; i++) {
                logoCubeData.position[i][0] *= 12;
                logoCubeData.position[i][1] *= 12;
                logoCubeData.position[i][2] *= 1;
                logoCubeData.color[i][0] /= 255;
                logoCubeData.color[i][1] /= 255;
                logoCubeData.color[i][2] /= 255;

                var r = rand() * (maxR - minR) + minR;
                var theta = rand() * (maxTheta - minTheta) + minTheta;
                var phi = rand() * Math.PI * 2;
                var arr = new Float32Array(3);
                arr[0] = Math.cos(phi) * r * Math.cos(theta);
                arr[1] = Math.sin(theta) * r;
                arr[2] = Math.sin(phi) * r * Math.cos(theta);
                randomExplodedPositions.push(arr);
            }

            self._logoCubeData = logoCubeData;
            self._randomExplodedPositions = randomExplodedPositions;
        }

        logoImg.src = logoData;
    }

    MainScene.prototype._createPlayer = function(obj, callback) {

        var img = new Image();
        var shader = qtek.shader.library.get('buildin.physical');
        
        var players = this._players;
        var cubes = this._cubes;
        var scene =  this.scene;

        var geo = cubeGeo.get();
        
        img.onload = function() {

            var res = mosaic(img, 0, 0, 0, 0, 0.8);
            
            var positionArr = res.position;
            var colorArr = res.color;

            var playerRoot = new qtek.Node();
            playerRoot.frustumCulling = true;

            var playerCubeList = [];

            for (var i = 0, j = 0; i< positionArr.length;) {
                var x = positionArr[i++];
                var y = positionArr[i++];
                var z = positionArr[i++];

                var r = colorArr[j++];
                var g = colorArr[j++];
                var b = colorArr[j++];

                var cubeMat = new qtek.Material({
                    shader: shader
                });

                cubeMat.set('color', [r / 255, g / 255, b / 255]);

                var mesh = new qtek.Mesh({
                    material: cubeMat,
                    geometry: geo
                });

                mesh.position.set(x * 15, y * 15, z);

                mesh.rotation.rotateX(Math.random() * Math.PI * 2);
                mesh.rotation.rotateZ(Math.random() * Math.PI * 2);

                var scale = obj.cubeSize * 0.12;
                mesh.scale.set(scale, scale, scale);
                mesh.visible = false;

                playerRoot.add(mesh);

                playerCubeList.push(mesh);

                cubes.push(mesh);
            }

            playerRoot.position.setArray(obj.position);
            playerRoot.rotation.rotateY(obj.rotation);
            playerRoot.scale.set(obj.scale, obj.scale, obj.scale);
            playerRoot.name = obj.title;

            scene.add(playerRoot);

            players.push(playerRoot);

            var instancedMeshes = instancing(playerCubeList, {
                max: 20
            });

            instancedMeshes.forEach(function(mesh) {
                mesh.frustumCulling = false;
                mesh.material.set('glossiness', 0.6)
                scene.add(mesh);
            });
            
            playerRoot._instancedMeshes = instancedMeshes;

            callback();
        }

        img.src = obj.image;
    }

    MainScene.prototype.start = function() {

        this.renderer.canvas.style.position = 'fixed';
        this.renderer.canvas.style.left = '0px';
        this.renderer.canvas.style.top = '0px';

        var self = this;

        if (!isMacFireFox()) {
            this.renderer.canvas.style.display = 'none';
        }

        setTimeout(function() { // Put in next tick
            // Mac  firefox 
            if (isMacFireFox()) {
                self._createCloseDom();

                self._trackAnimation(function() {
                    self._explosionAnimation();
                });
            } else {
                self._fadeIn(function() {

                    self._createCloseDom();

                    self._trackAnimation(function() {
                        self._explosionAnimation();
                    });
                });
            }
        }, 20)
    }

    MainScene.prototype._createCloseDom = function() {
        var closeDom = document.createElement('div');
        closeDom.className = 'OP_LOG_BTN';
        closeDom.id = 'worldcup-fx-webgl-main-close';

        qtek.core.util.extend(closeDom.style, closeStyle);

        this.container.appendChild(closeDom);

        var self = this;
        closeDom.onclick = function() {
            self.container.removeChild(closeDom);
            if (self._fadeInDom) {
                self._fadeInDom.parentNode.removeChild(self._fadeInDom);
                self._fadeInDom = null;
            }
            self.trigger('close');
        }
    }

    MainScene.prototype._fadeIn = function(prepareTrackAnimation) {
        var fadeInDom = document.createElement('div');
        document.body.appendChild(fadeInDom);

        this._fadeInDom = fadeInDom;

        fadeInStyle.opacity = 0;
        qtek.core.util.extend(fadeInDom.style, fadeInStyle);

        var self = this;

        function during(target) {
            fadeInDom.style.opacity = target.opacity;
        }

        this.animation.animate(fadeInStyle)
            .when(1000, {
                opacity: 1
            })
            .during(during)
            .done(function() {

                self.animation.animate(fadeInStyle)
                .when(1000, {
                    opacity: 0
                })
                .during(during)
                .done(function() {
                    fadeInDom.parentNode.removeChild(fadeInDom);
                    self._fadeInDom = null;
                })
                .start();

                self.renderer.canvas.style.display = 'block';

                prepareTrackAnimation();
            })
            .start();
    }

    MainScene.prototype.stop = function() {
        document.body.removeEventListener('mousemove', this.onMouseMove);
    }

    MainScene.prototype.dispose = function() {
        this.stop();
        if (this.scene) {
            this.renderer.disposeScene(this.scene);
        }
        this.scene = null;
        this.camera = null;
        this.compositor = null;
    }

    MainScene.prototype.frame = function(deltaTime) {
        if (!this.scene) {
            return;
        }
        var camera = this.camera;
        var scene = this.scene;
        var compositor = this.compositor;
        var renderer = this.renderer;

        var players = this._players;
        var cubes = this._cubes;

        camera.far = cameraFar;
        camera.aspect = renderer.canvas.width / renderer.canvas.height;

        // Culling
        camera.update(true);
        
        var posInView = new qtek.math.Vector3();
        for (var i = 0; i < players.length; i++) {
            var player = players[i];
            if (!player.frustumCulling) {
                var hidden = false;
            } else {
                player.getWorldPosition(posInView);

                qtek.math.Vector3.transformMat4(posInView, posInView, camera.viewMatrix);

                var hidden = (-posInView._array[2] > camera.far + 1) || (posInView._array[2] >= 0);
            }
            
            for (var j = 0; j < player._instancedMeshes.length; j++) {
                player._instancedMeshes[j].visible = !hidden;
            }
        }

        compositor.updateParameters();
        compositor.render(renderer);

        for (var i = 0; i < cubes.length; i++) {
            qtek.math.Quaternion.rotateY(cubes[i].rotation, cubes[i].rotation, deltaTime / 500);
        }

        this.leaves.update(deltaTime);
    }

    MainScene.prototype._trackAnimation = function(callback) {

        var camera = this.camera;
        var animation = this.animation;
        var compositor = this.compositor;

        var obj = {
            focalPlane: 10,
            playbackRatio: 1
        }
        var positionDeferred = animation.animate(camera.position).delay(1200);
        var rotationDeferred = animation.animate(camera, {
            interpolater: qtek.math.Quaternion.slerp
        }).delay(1200);
        var focalPlaneDeferred = animation.animate(obj).delay(1200);
        var playbackRatioDeferred = animation.animate(obj).delay(1200);

        var ghostCamera = new qtek.camera.Perspective();
        var target = new qtek.math.Vector3();

        if (tracks.cameras.length > 0) {
            camera.position.setArray(tracks.cameras[0].position);
            target.setArray(tracks.cameras[0].target);
            camera.lookAt(target);
        }

        for (var i = 0; i < tracks.cameras.length; i++) {
            var kf = tracks.cameras[i];
            var time = kf.time;
            positionDeferred.when(time, {
                _array: kf.position
            });
            ghostCamera.position.setArray(kf.position);
            target.setArray(kf.target);
            ghostCamera.lookAt(target);
            rotationDeferred.when(time, {
                rotation: ghostCamera.rotation.clone()
            });
            focalPlaneDeferred.when(time, {
                focalPlane: kf.focalPlane
            });
            playbackRatioDeferred.when(time, {
                playbackRatio: kf.playbackRatio
            });
        }

        var clips = [];

        positionDeferred.during(function() {
            camera.position._dirty = true;
        })
        .done(callback)
        .start('spline');

        rotationDeferred.start();

        focalPlaneDeferred.during(function() {
            compositor.setFocalPlane(obj.focalPlane);
        }).start();
        playbackRatioDeferred.during(function() {
            for (var i = 0; i < clips.length; i++) {
                clips[i].playbackRatio = obj.playbackRatio;
            }
        }).start();

        clips = positionDeferred.getClips()
            .concat(rotationDeferred.getClips())
            .concat(focalPlaneDeferred.getClips())
            .concat(playbackRatioDeferred.getClips());
    }

    MainScene.prototype._explosionAnimation = function() {

        var animation = this.animation;
        var camera = this.camera;

        var len = this._cubes.length;
        var count = this._randomExplodedPositions.length;

        var self = this;

        if (this.compositor) {
            this.compositor.setFStop(0.2);
        }

        var done = function() {
            count--;
            if (count == 0) {
                self._regroupAnimation();
            }
        }

        var during = function(target) {
            target._dirty = true;
        }

        var lastPlayer = this._players[this._players.length - 1];

        for (var i = 0; i < count; i++) { 

            var cube = this._cubes[len - i - 1];
            cube.parent.frustumCulling = false;
            if (cube.parent != lastPlayer) {
                lastPlayer.add(cube);
            }

            animation.animate(cube.position)
                .when(700, {
                    _array: this._randomExplodedPositions[i]
                })
                .during(during)
                .done(done)
                .start('ExponentialOut');

            animation.animate(cube.material.uniforms.color)
                .when(700, {
                    value: this._logoCubeData.color[i]
                })
                .start('ExponentialOut');
        }

        var newPos = new qtek.math.Vector3();
        qtek.math.Vector3.scaleAndAdd(newPos, camera.position, camera.localTransform.forward, -25);
        animation.animate(camera.position)
            .when(700, {
                _array: newPos._array
            })
            .during(during)
            .start('ExponentialOut');
    }
    
    MainScene.prototype._regroupAnimation = function() {
        var len = this._cubes.length;
        var count = this._randomExplodedPositions.length;
        var self = this;

        var animation = this.animation;
        var camera = this.camera;

        var done = function() {
            count--;
            if (count == 0) {
                document.body.addEventListener('mousemove', self.onMouseMove);

                ///////////// 
                var obj = {
                    rotation : 0
                }
                var prev = obj.rotation;

                animation.animate(obj)
                    .when(1000, {
                        rotation: Math.PI / 2.5
                    })
                    .during(function() {
                        self.camera.rotateAround(lastPlayer.position, qtek.math.Vector3.UP, obj.rotation - prev);
                        prev = obj.rotation;
                    })
                    .done(function() {
                        var pos = camera.position.clone().scaleAndAdd(camera.localTransform.forward, -300);
                        var prev = 0;
                        animation.animate(camera.position)
                            .when(2000, {
                                _array: pos._array
                            })
                            .during(function(target, percent) {
                                camera.rotation.rotateX(Math.PI / 5 * (percent - prev));
                                prev = percent;
                            })
                            .start('CubicIn');

                        self.trigger('done');
                    })
                    .start('CubicInOut');

            }
        }
        var during = function(target) {
            target._dirty = true;
        }

        var lastPlayer = this._players[this._players.length - 1];
        
        var scale = [0.1, 0.1, 0.1];
        for (var i = 0; i < count; i++) {
            var cube = this._cubes[len - i - 1];

            var delay = Math.random() * 100;

            scale[0] = 0.1 * this._logoCubeData.scale[i];
            scale[1] = 0.1 * this._logoCubeData.scale[i];
            scale[2] = 0.1 * this._logoCubeData.scale[i];
            
            animation.animate(cube.position)
                .when(800, {
                    _array: this._logoCubeData.position[i]
                })
                .during(during)
                .done(done)
                .delay(delay)
                .start('ExponentialIn');

            animation.animate(cube.scale)
                .when(800, {
                    _array: scale
                })
                .done(done)
                .delay(delay)
                .start('ExponentialIn');
        }

        var newPos = new qtek.math.Vector3();
        qtek.math.Vector3.scaleAndAdd(newPos, camera.position, camera.localTransform.forward, 25);
        animation.animate(camera.position)
            .when(800, {
                _array: newPos._array
            })
            .during(during)
            .start('ExponentialIn');
    }

    MainScene.prototype.onMouseMove = function(e) {
        // var dx = e.pageX - this.renderer.width / 2;
        // var offx = (dx - this._odx) / 700;

        // var lastPlayer = this._players[this._players.length - 1];

        // this.camera.rotateAround(lastPlayer.position, qtek.math.Vector3.UP, offx);

        // this._odx = dx;
    }

    qtek.core.util.extend(MainScene.prototype, qtek.core.mixin.notifier);

    return MainScene
});
define('worldcup-high/GenieEffect',['require','qtek'],function (require) {
        
    var qtek = require('qtek');

    function lerp(x, y, t) {
        return (y - x) * t + x;
    }

    var GenieEffect = function(opts) {
        opts = opts || {};

        this.segments = opts.segments || 30;

        this.side = opts.side || 'right';

        this.position = opts.position || 0.8;

        this.mesh = new qtek.Mesh({
            geometry: new qtek.StaticGeometry({
                hint: qtek.Geometry.DYNAMIC_DRAW
            }),
            material: new qtek.Material({
                shader: qtek.shader.library.get('buildin.basic', 'diffuseMap')
            }),
            culling: false
        });

        // this.mesh.material.shader.define('fragment', 'RENDER_TEXCOORD');

        this.mesh.position.x = -1;
        this.mesh.position.y = -1;
        this.mesh.position.z = -1;
        this.mesh.scale.set(2, 2, 2);
        this.mesh.update();

        var nVertices = Math.pow(this.segments + 1, 2);
        this.mesh.geometry.attributes.position.init(nVertices);
        this.mesh.geometry.attributes.texcoord0.init(nVertices);

        this._camera = new qtek.camera.Orthographic({
            far: 100
        });
        this._camera.update();

        this._frameBuffer = new qtek.FrameBuffer();

        switch (this.side) {
            case "right":
            default:
                this._coords = [
                    [0, 0],  // Left bottom
                    [0, 1],   // Left top
                    [1, 0],    // Right bottom
                    [1, 1],    // Right top
                ];

                break;
        }

        var coords = this.mesh.geometry.attributes.texcoord0.value;
        var faces = [];

        var off1 = 0;
        var segs = this.segments;

        for (var i = 0; i <= segs; i++) {
            var s = i / segs;

            for (var j = 0; j <= segs; j++) {
                var t = j / segs;


                coords[off1++] = s;
                coords[off1++] = t;

                if (i < segs && j < segs) {

                    var idx = j + i * (segs + 1);

                    faces.push(idx);
                    faces.push(idx+1);
                    faces.push(idx+segs+1);

                    faces.push(idx+segs+1);
                    faces.push(idx+1);
                    faces.push(idx+segs+2);
                }
            }
        }

        this.mesh.geometry.faces = new Uint16Array(faces);

        this.scene = new qtek.Scene();
        this.scene.add(this.mesh);
    }

    GenieEffect.prototype.update = function(percent) {
        if (this.side == 'right' || this.side == 'left') {
            var dim1 = 1;
            var dim2 = 0;
        } else {
            var dim1 = 0;
            var dim2 = 1;
        }

        if (percent > 1) {
            percent = 1;
        } else if (percent < 0) {
            percent = 0
        }

        var stage;
        // Stage 1
        if (percent < 0.5) {
            stage = 1;

            percent = percent / 0.5;

            var pos = this.position;

            this._coords[2][dim1] = lerp(0, pos, percent);
            this._coords[3][dim1] = lerp(1, pos, percent);
        }
        // Stage 2
        else {
            stage = 2;

            percent = (percent - 0.5) / 0.5;

            this._coords[0][dim2] = lerp(0, 1, percent);
            this._coords[1][dim2] = lerp(0, 1, percent);
        }

        var segs = this.segments;
        var off0 = 0;

        var position = this.mesh.geometry.attributes.position.value;

        for (var i = 0; i <= segs; i++) {
            var s = i / segs;

            var x = lerp(this._coords[0][0], this._coords[2][0], s);

            if (stage == 1) {
                var p = qtek.animation.easing.QuadraticInOut(s);
            } else {
                var p = qtek.animation.easing.QuadraticInOut(s * (1 - percent) + percent);
            }

            // Side 1
            var y0 = lerp(this._coords[0][1], this._coords[2][1], p);
            // Side 2
            var y1 = lerp(this._coords[1][1], this._coords[3][1], p);
            
            for (var j = 0; j <= segs; j++) {
                var t = j / segs;

                var y = lerp(y0, y1, t);

                position[off0++] = x;
                position[off0++] = y;
                position[off0++] = 0;
            }
        }

        this.mesh.geometry.dirty();

        return percent >= 1;
    }

    GenieEffect.prototype.beforeRender = function(renderer) {
        if (!this._texture || this._texture.width !== renderer.width || this._texture.height !== renderer.height) {
            if (this._texture) {
                this._texture.dispose(renderer.gl);
            }
            this._texture = new qtek.texture.Texture2D({
                width: renderer.width,
                height: renderer.height
            });

            this.mesh.material.set('diffuseMap', this._texture);
        }

        this._frameBuffer.attach(renderer.gl, this._texture);
        this._frameBuffer.bind(renderer);
    }

    GenieEffect.prototype.render = function(renderer) {
        var gl = renderer.gl;
        renderer.render(this.scene, this._camera);
    }

    GenieEffect.prototype.afterRender = function(renderer) {
        this._frameBuffer.unbind(renderer);
    }

    GenieEffect.prototype.dispose = function() {
        
    }

    return GenieEffect;
});
define('worldcup-high/main',['require','qtek','./EntryScene','./MainScene','./GenieEffect'],function (require) {

    var qtek = require('qtek');

    var EntryScene = require('./EntryScene');

    var MainScene = require('./MainScene');

    var GenieEffect = require('./GenieEffect');

    var entryScene;

    var mainScene;

    var currentScene;

    var genieEffect;
    var genieEffectTime = 0;
    var genieEffectTimeTotal = 1000;

    var closed = false;

    var renderer;
    var animation;

    function close() {
        var dom = document.getElementById('worldcup-fx-webgl-main-close');
        if (dom) {
            dom.parentNode.removeChild(dom);
        }
        if (closed) {
            return;
        }
        closed = true;

        genieEffect = new GenieEffect();
        genieEffectTime = 0;

        if (currentScene && currentScene.compositor) {
            var lastNode = currentScene.compositor.getLastNode();
            if (lastNode.scene) {
                lastNode.scene.on('beforerender', beforeRender);
                lastNode.scene.on('afterrender', afterRender);
            }
            else if (lastNode.pass) {
                lastNode.pass.on('beforerender', beforeRender);
                lastNode.pass.on('afterrender', afterRender);
            }
        }
    }

    function beforeRender() {
        genieEffect.beforeRender(currentScene.renderer);
    }

    function afterRender() {
        genieEffect.afterRender(currentScene.renderer);
        genieEffect.render(currentScene.renderer);
    }

    function fitToScreen() {
        if (renderer) {
            renderer.resize(window.innerWidth, window.innerHeight);
        }
    }

    var playingBGM = false;

    var main = {
        start: function() {

            var container = document.querySelector('.opr-worldcup_2014');
            if (!container) {
                container = document.body;
            }

            renderer = new qtek.Renderer();
            renderer.canvas.style.position = 'fixed';
            renderer.canvas.id = 'worldcup-fx-webgl-main';
            renderer.canvas.className = 'OP_LOG_BTN';
            renderer.canvas.style.zIndex = 10000;

            container.appendChild(renderer.canvas);

            animation = new qtek.animation.Animation();
            animation.start();
            animation.on('frame', function(deltaTime) {
                var finished = main.frame(deltaTime);
                if (finished) {
                    main.dispose();
                }
            });

            main.renderer = renderer;
            main.animation = animation;

            // // entryScene = new EntryScene(renderer, animation, container);
            // // entryScene.init();
            // // entryScene.start();

            // // currentScene = entryScene;

            // // entryScene.on('enter', function() {
            // //     if (currentScene == entryScene) {
            // //         entryScene.dispose();

            // //         mainScene = new MainScene(renderer, animation, container);

            // //         fitToScreen();
            // //         renderer.setDevicePixelRatio(1.0);

            // //         window.addEventListener('resize', fitToScreen);
                    
            // //         setTimeout(function() {
            // //             playingBGM = true;
            // //             main.playBGM();
            // //         }, 100);

            // //         mainScene.init();
            // //         mainScene.start();

            // //         currentScene = mainScene;

            // //         mainScene.on('done', function() {
            // //             // setTimeout(close, 2000);
            // //         });
            // //         mainScene.on('close', function() {
            // //             close();
            // //         });
            // //     }
            // // });

            // // entryScene.on('close', function() {
            // //     main.dispose();
            // // });
            
            mainScene = new MainScene(renderer, animation, container);
            mainScene.init();
            mainScene.start();

            fitToScreen();
            renderer.setDevicePixelRatio(1.0);
            currentScene = mainScene;

            mainScene.on('done', function() {
                main.onDone();
            });
        },

        frame: function(dTime) {
            if (genieEffect) {
                genieEffectTime += dTime;
                genieEffect.update(genieEffectTime / genieEffectTimeTotal);
            }

            if (currentScene) {
                currentScene.frame(dTime);
            }

            if (genieEffectTime - dTime > genieEffectTimeTotal) {
                return true;
            }
        },

        dispose: function() {
            mainScene && mainScene.dispose();
            entryScene && entryScene.dispose();

            mainScene = null;
            entryScene = null;
            currentScene = null;
            
            genieEffect && genieEffect.dispose();
            genieEffect = null;

            animation.off('frame');
            animation && animation.stop();
            animation = null;

            window.removeEventListener('resize', fitToScreen);
            if (renderer) {
                renderer.canvas.parentNode.removeChild(renderer.canvas);
            }
            renderer = null;

            if (playingBGM) {
                main.stopBGM();
                playingBGM = false;   
            }
        },

        playBGM: function() { console.log('BGM Start') },

        stopBGM: function() { console.log('BGM Stop') },

        onDone: function() { console.log('DONE') }
    }

    main.start();

    return main;
});
define('worldcup-high', ['worldcup-high/main'], function (main) { return main; });
